var Wf = e => { throw TypeError(e) }; var du = (e, t, n) => t.has(e) || Wf("Cannot " + n); var N = (e, t, n) => (du(e, t, "read from private field"), n ? n.call(e) : t.get(e)), de = (e, t, n) => t.has(e) ? Wf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), se = (e, t, n, r) => (du(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), De = (e, t, n) => (du(e, t, "access private method"), n); var Qi = (e, t, n, r) => ({ set _(s) { se(e, t, s, n) }, get _() { return N(e, t, r) } }); function K0(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const s in r) if (s !== "default" && !(s in e)) { const o = Object.getOwnPropertyDescriptor(r, s); o && Object.defineProperty(e, s, o.get ? o : { enumerable: !0, get: () => r[s] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const o of s) if (o.type === "childList") for (const i of o.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && r(i) }).observe(document, { childList: !0, subtree: !0 }); function n(s) { const o = {}; return s.integrity && (o.integrity = s.integrity), s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? o.credentials = "include" : s.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function r(s) { if (s.ep) return; s.ep = !0; const o = n(s); fetch(s.href, o) } })(); function fm(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var pm = { exports: {} }, Tl = {}, hm = { exports: {} }, ue = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Li = Symbol.for("react.element"), Q0 = Symbol.for("react.portal"), G0 = Symbol.for("react.fragment"), q0 = Symbol.for("react.strict_mode"), Y0 = Symbol.for("react.profiler"), X0 = Symbol.for("react.provider"), J0 = Symbol.for("react.context"), ew = Symbol.for("react.forward_ref"), tw = Symbol.for("react.suspense"), nw = Symbol.for("react.memo"), rw = Symbol.for("react.lazy"), Hf = Symbol.iterator; function sw(e) { return e === null || typeof e != "object" ? null : (e = Hf && e[Hf] || e["@@iterator"], typeof e == "function" ? e : null) } var mm = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, vm = Object.assign, gm = {}; function co(e, t, n) { this.props = e, this.context = t, this.refs = gm, this.updater = n || mm } co.prototype.isReactComponent = {}; co.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; co.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function ym() { } ym.prototype = co.prototype; function gd(e, t, n) { this.props = e, this.context = t, this.refs = gm, this.updater = n || mm } var yd = gd.prototype = new ym; yd.constructor = gd; vm(yd, co.prototype); yd.isPureReactComponent = !0; var Zf = Array.isArray, xm = Object.prototype.hasOwnProperty, xd = { current: null }, wm = { key: !0, ref: !0, __self: !0, __source: !0 }; function Sm(e, t, n) { var r, s = {}, o = null, i = null; if (t != null) for (r in t.ref !== void 0 && (i = t.ref), t.key !== void 0 && (o = "" + t.key), t) xm.call(t, r) && !wm.hasOwnProperty(r) && (s[r] = t[r]); var a = arguments.length - 2; if (a === 1) s.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; s.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) s[r] === void 0 && (s[r] = a[r]); return { $$typeof: Li, type: e, key: o, ref: i, props: s, _owner: xd.current } } function ow(e, t) { return { $$typeof: Li, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function wd(e) { return typeof e == "object" && e !== null && e.$$typeof === Li } function iw(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var Kf = /\/+/g; function fu(e, t) { return typeof e == "object" && e !== null && e.key != null ? iw("" + e.key) : t.toString(36) } function Sa(e, t, n, r, s) { var o = typeof e; (o === "undefined" || o === "boolean") && (e = null); var i = !1; if (e === null) i = !0; else switch (o) { case "string": case "number": i = !0; break; case "object": switch (e.$$typeof) { case Li: case Q0: i = !0 } }if (i) return i = e, s = s(i), e = r === "" ? "." + fu(i, 0) : r, Zf(s) ? (n = "", e != null && (n = e.replace(Kf, "$&/") + "/"), Sa(s, t, n, "", function (u) { return u })) : s != null && (wd(s) && (s = ow(s, n + (!s.key || i && i.key === s.key ? "" : ("" + s.key).replace(Kf, "$&/") + "/") + e)), t.push(s)), 1; if (i = 0, r = r === "" ? "." : r + ":", Zf(e)) for (var a = 0; a < e.length; a++) { o = e[a]; var l = r + fu(o, a); i += Sa(o, t, n, l, s) } else if (l = sw(e), typeof l == "function") for (e = l.call(e), a = 0; !(o = e.next()).done;)o = o.value, l = r + fu(o, a++), i += Sa(o, t, n, l, s); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return i } function Gi(e, t, n) { if (e == null) return e; var r = [], s = 0; return Sa(e, r, "", "", function (o) { return t.call(n, o, s++) }), r } function aw(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var gt = { current: null }, _a = { transition: null }, lw = { ReactCurrentDispatcher: gt, ReactCurrentBatchConfig: _a, ReactCurrentOwner: xd }; function _m() { throw Error("act(...) is not supported in production builds of React.") } ue.Children = { map: Gi, forEach: function (e, t, n) { Gi(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Gi(e, function () { t++ }), t }, toArray: function (e) { return Gi(e, function (t) { return t }) || [] }, only: function (e) { if (!wd(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; ue.Component = co; ue.Fragment = G0; ue.Profiler = Y0; ue.PureComponent = gd; ue.StrictMode = q0; ue.Suspense = tw; ue.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lw; ue.act = _m; ue.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = vm({}, e.props), s = e.key, o = e.ref, i = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, i = xd.current), t.key !== void 0 && (s = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) xm.call(t, l) && !wm.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: Li, type: e.type, key: s, ref: o, props: r, _owner: i } }; ue.createContext = function (e) { return e = { $$typeof: J0, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: X0, _context: e }, e.Consumer = e }; ue.createElement = Sm; ue.createFactory = function (e) { var t = Sm.bind(null, e); return t.type = e, t }; ue.createRef = function () { return { current: null } }; ue.forwardRef = function (e) { return { $$typeof: ew, render: e } }; ue.isValidElement = wd; ue.lazy = function (e) { return { $$typeof: rw, _payload: { _status: -1, _result: e }, _init: aw } }; ue.memo = function (e, t) { return { $$typeof: nw, type: e, compare: t === void 0 ? null : t } }; ue.startTransition = function (e) { var t = _a.transition; _a.transition = {}; try { e() } finally { _a.transition = t } }; ue.unstable_act = _m; ue.useCallback = function (e, t) { return gt.current.useCallback(e, t) }; ue.useContext = function (e) { return gt.current.useContext(e) }; ue.useDebugValue = function () { }; ue.useDeferredValue = function (e) { return gt.current.useDeferredValue(e) }; ue.useEffect = function (e, t) { return gt.current.useEffect(e, t) }; ue.useId = function () { return gt.current.useId() }; ue.useImperativeHandle = function (e, t, n) { return gt.current.useImperativeHandle(e, t, n) }; ue.useInsertionEffect = function (e, t) { return gt.current.useInsertionEffect(e, t) }; ue.useLayoutEffect = function (e, t) { return gt.current.useLayoutEffect(e, t) }; ue.useMemo = function (e, t) { return gt.current.useMemo(e, t) }; ue.useReducer = function (e, t, n) { return gt.current.useReducer(e, t, n) }; ue.useRef = function (e) { return gt.current.useRef(e) }; ue.useState = function (e) { return gt.current.useState(e) }; ue.useSyncExternalStore = function (e, t, n) { return gt.current.useSyncExternalStore(e, t, n) }; ue.useTransition = function () { return gt.current.useTransition() }; ue.version = "18.3.1"; hm.exports = ue; var v = hm.exports; const oe = fm(v), Cm = K0({ __proto__: null, default: oe }, [v]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uw = v, cw = Symbol.for("react.element"), dw = Symbol.for("react.fragment"), fw = Object.prototype.hasOwnProperty, pw = uw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, hw = { key: !0, ref: !0, __self: !0, __source: !0 }; function km(e, t, n) { var r, s = {}, o = null, i = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (i = t.ref); for (r in t) fw.call(t, r) && !hw.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) s[r] === void 0 && (s[r] = t[r]); return { $$typeof: cw, type: e, key: o, ref: i, props: s, _owner: pw.current } } Tl.Fragment = dw; Tl.jsx = km; Tl.jsxs = km; pm.exports = Tl; var d = pm.exports, bm = { exports: {} }, Dt = {}, Em = { exports: {} }, Tm = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(P, D) { var Q = P.length; P.push(D); e: for (; 0 < Q;) { var re = Q - 1 >>> 1, ve = P[re]; if (0 < s(ve, D)) P[re] = D, P[Q] = ve, Q = re; else break e } } function n(P) { return P.length === 0 ? null : P[0] } function r(P) { if (P.length === 0) return null; var D = P[0], Q = P.pop(); if (Q !== D) { P[0] = Q; e: for (var re = 0, ve = P.length, Ke = ve >>> 1; re < Ke;) { var Le = 2 * (re + 1) - 1, bt = P[Le], qe = Le + 1, ee = P[qe]; if (0 > s(bt, Q)) qe < ve && 0 > s(ee, bt) ? (P[re] = ee, P[qe] = Q, re = qe) : (P[re] = bt, P[Le] = Q, re = Le); else if (qe < ve && 0 > s(ee, Q)) P[re] = ee, P[qe] = Q, re = qe; else break e } } return D } function s(P, D) { var Q = P.sortIndex - D.sortIndex; return Q !== 0 ? Q : P.id - D.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; e.unstable_now = function () { return o.now() } } else { var i = Date, a = i.now(); e.unstable_now = function () { return i.now() - a } } var l = [], u = [], c = 1, p = null, h = 3, w = !1, S = !1, m = !1, x = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, f = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function y(P) { for (var D = n(u); D !== null;) { if (D.callback === null) r(u); else if (D.startTime <= P) r(u), D.sortIndex = D.expirationTime, t(l, D); else break; D = n(u) } } function _(P) { if (m = !1, y(P), !S) if (n(l) !== null) S = !0, K(k); else { var D = n(u); D !== null && J(_, D.startTime - P) } } function k(P, D) { S = !1, m && (m = !1, g(R), R = -1), w = !0; var Q = h; try { for (y(D), p = n(l); p !== null && (!(p.expirationTime > D) || P && !Y());) { var re = p.callback; if (typeof re == "function") { p.callback = null, h = p.priorityLevel; var ve = re(p.expirationTime <= D); D = e.unstable_now(), typeof ve == "function" ? p.callback = ve : p === n(l) && r(l), y(D) } else r(l); p = n(l) } if (p !== null) var Ke = !0; else { var Le = n(u); Le !== null && J(_, Le.startTime - D), Ke = !1 } return Ke } finally { p = null, h = Q, w = !1 } } var T = !1, b = null, R = -1, F = 5, V = -1; function Y() { return !(e.unstable_now() - V < F) } function O() { if (b !== null) { var P = e.unstable_now(); V = P; var D = !0; try { D = b(!0, P) } finally { D ? z() : (T = !1, b = null) } } else T = !1 } var z; if (typeof f == "function") z = function () { f(O) }; else if (typeof MessageChannel < "u") { var j = new MessageChannel, X = j.port2; j.port1.onmessage = O, z = function () { X.postMessage(null) } } else z = function () { x(O, 0) }; function K(P) { b = P, T || (T = !0, z()) } function J(P, D) { R = x(function () { P(e.unstable_now()) }, D) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (P) { P.callback = null }, e.unstable_continueExecution = function () { S || w || (S = !0, K(k)) }, e.unstable_forceFrameRate = function (P) { 0 > P || 125 < P ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < P ? Math.floor(1e3 / P) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return h }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (P) { switch (h) { case 1: case 2: case 3: var D = 3; break; default: D = h }var Q = h; h = D; try { return P() } finally { h = Q } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (P, D) { switch (P) { case 1: case 2: case 3: case 4: case 5: break; default: P = 3 }var Q = h; h = P; try { return D() } finally { h = Q } }, e.unstable_scheduleCallback = function (P, D, Q) { var re = e.unstable_now(); switch (typeof Q == "object" && Q !== null ? (Q = Q.delay, Q = typeof Q == "number" && 0 < Q ? re + Q : re) : Q = re, P) { case 1: var ve = -1; break; case 2: ve = 250; break; case 5: ve = 1073741823; break; case 4: ve = 1e4; break; default: ve = 5e3 }return ve = Q + ve, P = { id: c++, callback: D, priorityLevel: P, startTime: Q, expirationTime: ve, sortIndex: -1 }, Q > re ? (P.sortIndex = Q, t(u, P), n(l) === null && P === n(u) && (m ? (g(R), R = -1) : m = !0, J(_, Q - re))) : (P.sortIndex = ve, t(l, P), S || w || (S = !0, K(k))), P }, e.unstable_shouldYield = Y, e.unstable_wrapCallback = function (P) { var D = h; return function () { var Q = h; h = D; try { return P.apply(this, arguments) } finally { h = Q } } } })(Tm); Em.exports = Tm; var mw = Em.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var vw = v, It = mw; function I(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Nm = new Set, ei = {}; function is(e, t) { qs(e, t), qs(e + "Capture", t) } function qs(e, t) { for (ei[e] = t, e = 0; e < t.length; e++)Nm.add(t[e]) } var Fn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), tc = Object.prototype.hasOwnProperty, gw = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Qf = {}, Gf = {}; function yw(e) { return tc.call(Gf, e) ? !0 : tc.call(Qf, e) ? !1 : gw.test(e) ? Gf[e] = !0 : (Qf[e] = !0, !1) } function xw(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function ww(e, t, n, r) { if (t === null || typeof t > "u" || xw(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function yt(e, t, n, r, s, o, i) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = s, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = i } var tt = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { tt[e] = new yt(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; tt[t] = new yt(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { tt[e] = new yt(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { tt[e] = new yt(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { tt[e] = new yt(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { tt[e] = new yt(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { tt[e] = new yt(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { tt[e] = new yt(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { tt[e] = new yt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Sd = /[\-:]([a-z])/g; function _d(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Sd, _d); tt[t] = new yt(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Sd, _d); tt[t] = new yt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Sd, _d); tt[t] = new yt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { tt[e] = new yt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); tt.xlinkHref = new yt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { tt[e] = new yt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Cd(e, t, n, r) { var s = tt.hasOwnProperty(t) ? tt[t] : null; (s !== null ? s.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (ww(t, n, s, r) && (n = null), r || s === null ? yw(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : s.mustUseProperty ? e[s.propertyName] = n === null ? s.type === 3 ? !1 : "" : n : (t = s.attributeName, r = s.attributeNamespace, n === null ? e.removeAttribute(t) : (s = s.type, n = s === 3 || s === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var Hn = vw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, qi = Symbol.for("react.element"), ys = Symbol.for("react.portal"), xs = Symbol.for("react.fragment"), kd = Symbol.for("react.strict_mode"), nc = Symbol.for("react.profiler"), Pm = Symbol.for("react.provider"), Rm = Symbol.for("react.context"), bd = Symbol.for("react.forward_ref"), rc = Symbol.for("react.suspense"), sc = Symbol.for("react.suspense_list"), Ed = Symbol.for("react.memo"), Jn = Symbol.for("react.lazy"), Am = Symbol.for("react.offscreen"), qf = Symbol.iterator; function yo(e) { return e === null || typeof e != "object" ? null : (e = qf && e[qf] || e["@@iterator"], typeof e == "function" ? e : null) } var je = Object.assign, pu; function Ao(e) {
  if (pu === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); pu = t && t[1] || "" } return `
`+ pu + e
} var hu = !1; function mu(e, t) {
  if (!e || hu) return ""; hu = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (u) { var r = u } Reflect.construct(e, [], t) } else { try { t.call() } catch (u) { r = u } e.call(t.prototype) } else { try { throw Error() } catch (u) { r = u } e() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var s = u.stack.split(`
`), o = r.stack.split(`
`), i = s.length - 1, a = o.length - 1; 1 <= i && 0 <= a && s[i] !== o[a];)a--; for (; 1 <= i && 0 <= a; i--, a--)if (s[i] !== o[a]) {
        if (i !== 1 || a !== 1) do if (i--, a--, 0 > a || s[i] !== o[a]) {
          var l = `
`+ s[i].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= i && 0 <= a); break
      }
    }
  } finally { hu = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Ao(e) : ""
} function Sw(e) { switch (e.tag) { case 5: return Ao(e.type); case 16: return Ao("Lazy"); case 13: return Ao("Suspense"); case 19: return Ao("SuspenseList"); case 0: case 2: case 15: return e = mu(e.type, !1), e; case 11: return e = mu(e.type.render, !1), e; case 1: return e = mu(e.type, !0), e; default: return "" } } function oc(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case xs: return "Fragment"; case ys: return "Portal"; case nc: return "Profiler"; case kd: return "StrictMode"; case rc: return "Suspense"; case sc: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Rm: return (e.displayName || "Context") + ".Consumer"; case Pm: return (e._context.displayName || "Context") + ".Provider"; case bd: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Ed: return t = e.displayName || null, t !== null ? t : oc(e.type) || "Memo"; case Jn: t = e._payload, e = e._init; try { return oc(e(t)) } catch { } }return null } function _w(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return oc(t); case 8: return t === kd ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function Sr(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function jm(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Cw(e) { var t = jm(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var s = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return s.call(this) }, set: function (i) { r = "" + i, o.call(this, i) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (i) { r = "" + i }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Yi(e) { e._valueTracker || (e._valueTracker = Cw(e)) } function Om(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = jm(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function za(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function ic(e, t) { var n = t.checked; return je({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function Yf(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = Sr(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function Mm(e, t) { t = t.checked, t != null && Cd(e, "checked", t, !1) } function ac(e, t) { Mm(e, t); var n = Sr(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? lc(e, t.type, n) : t.hasOwnProperty("defaultValue") && lc(e, t.type, Sr(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Xf(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function lc(e, t, n) { (t !== "number" || za(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var jo = Array.isArray; function As(e, t, n, r) { if (e = e.options, t) { t = {}; for (var s = 0; s < n.length; s++)t["$" + n[s]] = !0; for (n = 0; n < e.length; n++)s = t.hasOwnProperty("$" + e[n].value), e[n].selected !== s && (e[n].selected = s), s && r && (e[n].defaultSelected = !0) } else { for (n = "" + Sr(n), t = null, s = 0; s < e.length; s++) { if (e[s].value === n) { e[s].selected = !0, r && (e[s].defaultSelected = !0); return } t !== null || e[s].disabled || (t = e[s]) } t !== null && (t.selected = !0) } } function uc(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(I(91)); return je({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Jf(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(I(92)); if (jo(n)) { if (1 < n.length) throw Error(I(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: Sr(n) } } function Im(e, t) { var n = Sr(t.value), r = Sr(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function ep(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Lm(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function cc(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Lm(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Xi, Dm = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, s) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, s) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Xi = Xi || document.createElement("div"), Xi.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Xi.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function ti(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Uo = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, kw = ["Webkit", "ms", "Moz", "O"]; Object.keys(Uo).forEach(function (e) { kw.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Uo[t] = Uo[e] }) }); function Fm(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Uo.hasOwnProperty(e) && Uo[e] ? ("" + t).trim() : t + "px" } function Vm(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, s = Fm(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, s) : e[n] = s } } var bw = je({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function dc(e, t) { if (t) { if (bw[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(I(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(I(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(I(61)) } if (t.style != null && typeof t.style != "object") throw Error(I(62)) } } function fc(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var pc = null; function Td(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var hc = null, js = null, Os = null; function tp(e) { if (e = Vi(e)) { if (typeof hc != "function") throw Error(I(280)); var t = e.stateNode; t && (t = jl(t), hc(e.stateNode, e.type, t)) } } function zm(e) { js ? Os ? Os.push(e) : Os = [e] : js = e } function $m() { if (js) { var e = js, t = Os; if (Os = js = null, tp(e), t) for (e = 0; e < t.length; e++)tp(t[e]) } } function Um(e, t) { return e(t) } function Bm() { } var vu = !1; function Wm(e, t, n) { if (vu) return e(t, n); vu = !0; try { return Um(e, t, n) } finally { vu = !1, (js !== null || Os !== null) && (Bm(), $m()) } } function ni(e, t) { var n = e.stateNode; if (n === null) return null; var r = jl(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(I(231, t, typeof n)); return n } var mc = !1; if (Fn) try { var xo = {}; Object.defineProperty(xo, "passive", { get: function () { mc = !0 } }), window.addEventListener("test", xo, xo), window.removeEventListener("test", xo, xo) } catch { mc = !1 } function Ew(e, t, n, r, s, o, i, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u) } catch (c) { this.onError(c) } } var Bo = !1, $a = null, Ua = !1, vc = null, Tw = { onError: function (e) { Bo = !0, $a = e } }; function Nw(e, t, n, r, s, o, i, a, l) { Bo = !1, $a = null, Ew.apply(Tw, arguments) } function Pw(e, t, n, r, s, o, i, a, l) { if (Nw.apply(this, arguments), Bo) { if (Bo) { var u = $a; Bo = !1, $a = null } else throw Error(I(198)); Ua || (Ua = !0, vc = u) } } function as(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Hm(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function np(e) { if (as(e) !== e) throw Error(I(188)) } function Rw(e) { var t = e.alternate; if (!t) { if (t = as(e), t === null) throw Error(I(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var s = n.return; if (s === null) break; var o = s.alternate; if (o === null) { if (r = s.return, r !== null) { n = r; continue } break } if (s.child === o.child) { for (o = s.child; o;) { if (o === n) return np(s), e; if (o === r) return np(s), t; o = o.sibling } throw Error(I(188)) } if (n.return !== r.return) n = s, r = o; else { for (var i = !1, a = s.child; a;) { if (a === n) { i = !0, n = s, r = o; break } if (a === r) { i = !0, r = s, n = o; break } a = a.sibling } if (!i) { for (a = o.child; a;) { if (a === n) { i = !0, n = o, r = s; break } if (a === r) { i = !0, r = o, n = s; break } a = a.sibling } if (!i) throw Error(I(189)) } } if (n.alternate !== r) throw Error(I(190)) } if (n.tag !== 3) throw Error(I(188)); return n.stateNode.current === n ? e : t } function Zm(e) { return e = Rw(e), e !== null ? Km(e) : null } function Km(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Km(e); if (t !== null) return t; e = e.sibling } return null } var Qm = It.unstable_scheduleCallback, rp = It.unstable_cancelCallback, Aw = It.unstable_shouldYield, jw = It.unstable_requestPaint, Ve = It.unstable_now, Ow = It.unstable_getCurrentPriorityLevel, Nd = It.unstable_ImmediatePriority, Gm = It.unstable_UserBlockingPriority, Ba = It.unstable_NormalPriority, Mw = It.unstable_LowPriority, qm = It.unstable_IdlePriority, Nl = null, yn = null; function Iw(e) { if (yn && typeof yn.onCommitFiberRoot == "function") try { yn.onCommitFiberRoot(Nl, e, void 0, (e.current.flags & 128) === 128) } catch { } } var nn = Math.clz32 ? Math.clz32 : Fw, Lw = Math.log, Dw = Math.LN2; function Fw(e) { return e >>>= 0, e === 0 ? 32 : 31 - (Lw(e) / Dw | 0) | 0 } var Ji = 64, ea = 4194304; function Oo(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Wa(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, s = e.suspendedLanes, o = e.pingedLanes, i = n & 268435455; if (i !== 0) { var a = i & ~s; a !== 0 ? r = Oo(a) : (o &= i, o !== 0 && (r = Oo(o))) } else i = n & ~s, i !== 0 ? r = Oo(i) : o !== 0 && (r = Oo(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & s) && (s = r & -r, o = t & -t, s >= o || s === 16 && (o & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - nn(t), s = 1 << n, r |= e[n], t &= ~s; return r } function Vw(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function zw(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, s = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var i = 31 - nn(o), a = 1 << i, l = s[i]; l === -1 ? (!(a & n) || a & r) && (s[i] = Vw(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function gc(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Ym() { var e = Ji; return Ji <<= 1, !(Ji & 4194240) && (Ji = 64), e } function gu(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Di(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - nn(t), e[t] = n } function $w(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var s = 31 - nn(n), o = 1 << s; t[s] = 0, r[s] = -1, e[s] = -1, n &= ~o } } function Pd(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - nn(n), s = 1 << r; s & t | e[r] & t && (e[r] |= t), n &= ~s } } var we = 0; function Xm(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Jm, Rd, ev, tv, nv, yc = !1, ta = [], pr = null, hr = null, mr = null, ri = new Map, si = new Map, tr = [], Uw = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function sp(e, t) { switch (e) { case "focusin": case "focusout": pr = null; break; case "dragenter": case "dragleave": hr = null; break; case "mouseover": case "mouseout": mr = null; break; case "pointerover": case "pointerout": ri.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": si.delete(t.pointerId) } } function wo(e, t, n, r, s, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [s] }, t !== null && (t = Vi(t), t !== null && Rd(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, s !== null && t.indexOf(s) === -1 && t.push(s), e) } function Bw(e, t, n, r, s) { switch (t) { case "focusin": return pr = wo(pr, e, t, n, r, s), !0; case "dragenter": return hr = wo(hr, e, t, n, r, s), !0; case "mouseover": return mr = wo(mr, e, t, n, r, s), !0; case "pointerover": var o = s.pointerId; return ri.set(o, wo(ri.get(o) || null, e, t, n, r, s)), !0; case "gotpointercapture": return o = s.pointerId, si.set(o, wo(si.get(o) || null, e, t, n, r, s)), !0 }return !1 } function rv(e) { var t = Fr(e.target); if (t !== null) { var n = as(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Hm(n), t !== null) { e.blockedOn = t, nv(e.priority, function () { ev(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Ca(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = xc(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); pc = r, n.target.dispatchEvent(r), pc = null } else return t = Vi(n), t !== null && Rd(t), e.blockedOn = n, !1; t.shift() } return !0 } function op(e, t, n) { Ca(e) && n.delete(t) } function Ww() { yc = !1, pr !== null && Ca(pr) && (pr = null), hr !== null && Ca(hr) && (hr = null), mr !== null && Ca(mr) && (mr = null), ri.forEach(op), si.forEach(op) } function So(e, t) { e.blockedOn === t && (e.blockedOn = null, yc || (yc = !0, It.unstable_scheduleCallback(It.unstable_NormalPriority, Ww))) } function oi(e) { function t(s) { return So(s, e) } if (0 < ta.length) { So(ta[0], e); for (var n = 1; n < ta.length; n++) { var r = ta[n]; r.blockedOn === e && (r.blockedOn = null) } } for (pr !== null && So(pr, e), hr !== null && So(hr, e), mr !== null && So(mr, e), ri.forEach(t), si.forEach(t), n = 0; n < tr.length; n++)r = tr[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < tr.length && (n = tr[0], n.blockedOn === null);)rv(n), n.blockedOn === null && tr.shift() } var Ms = Hn.ReactCurrentBatchConfig, Ha = !0; function Hw(e, t, n, r) { var s = we, o = Ms.transition; Ms.transition = null; try { we = 1, Ad(e, t, n, r) } finally { we = s, Ms.transition = o } } function Zw(e, t, n, r) { var s = we, o = Ms.transition; Ms.transition = null; try { we = 4, Ad(e, t, n, r) } finally { we = s, Ms.transition = o } } function Ad(e, t, n, r) { if (Ha) { var s = xc(e, t, n, r); if (s === null) Tu(e, t, r, Za, n), sp(e, r); else if (Bw(s, e, t, n, r)) r.stopPropagation(); else if (sp(e, r), t & 4 && -1 < Uw.indexOf(e)) { for (; s !== null;) { var o = Vi(s); if (o !== null && Jm(o), o = xc(e, t, n, r), o === null && Tu(e, t, r, Za, n), o === s) break; s = o } s !== null && r.stopPropagation() } else Tu(e, t, r, null, n) } } var Za = null; function xc(e, t, n, r) { if (Za = null, e = Td(r), e = Fr(e), e !== null) if (t = as(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Hm(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Za = e, null } function sv(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Ow()) { case Nd: return 1; case Gm: return 4; case Ba: case Mw: return 16; case qm: return 536870912; default: return 16 }default: return 16 } } var dr = null, jd = null, ka = null; function ov() { if (ka) return ka; var e, t = jd, n = t.length, r, s = "value" in dr ? dr.value : dr.textContent, o = s.length; for (e = 0; e < n && t[e] === s[e]; e++); var i = n - e; for (r = 1; r <= i && t[n - r] === s[o - r]; r++); return ka = s.slice(e, 1 < r ? 1 - r : void 0) } function ba(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function na() { return !0 } function ip() { return !1 } function Ft(e) { function t(n, r, s, o, i) { this._reactName = n, this._targetInst = s, this.type = r, this.nativeEvent = o, this.target = i, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? na : ip, this.isPropagationStopped = ip, this } return je(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = na) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = na) }, persist: function () { }, isPersistent: na }), t } var fo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Od = Ft(fo), Fi = je({}, fo, { view: 0, detail: 0 }), Kw = Ft(Fi), yu, xu, _o, Pl = je({}, Fi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Md, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== _o && (_o && e.type === "mousemove" ? (yu = e.screenX - _o.screenX, xu = e.screenY - _o.screenY) : xu = yu = 0, _o = e), yu) }, movementY: function (e) { return "movementY" in e ? e.movementY : xu } }), ap = Ft(Pl), Qw = je({}, Pl, { dataTransfer: 0 }), Gw = Ft(Qw), qw = je({}, Fi, { relatedTarget: 0 }), wu = Ft(qw), Yw = je({}, fo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Xw = Ft(Yw), Jw = je({}, fo, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), e1 = Ft(Jw), t1 = je({}, fo, { data: 0 }), lp = Ft(t1), n1 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, r1 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, s1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function o1(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = s1[e]) ? !!t[e] : !1 } function Md() { return o1 } var i1 = je({}, Fi, { key: function (e) { if (e.key) { var t = n1[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = ba(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? r1[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Md, charCode: function (e) { return e.type === "keypress" ? ba(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? ba(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), a1 = Ft(i1), l1 = je({}, Pl, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), up = Ft(l1), u1 = je({}, Fi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Md }), c1 = Ft(u1), d1 = je({}, fo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), f1 = Ft(d1), p1 = je({}, Pl, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), h1 = Ft(p1), m1 = [9, 13, 27, 32], Id = Fn && "CompositionEvent" in window, Wo = null; Fn && "documentMode" in document && (Wo = document.documentMode); var v1 = Fn && "TextEvent" in window && !Wo, iv = Fn && (!Id || Wo && 8 < Wo && 11 >= Wo), cp = " ", dp = !1; function av(e, t) { switch (e) { case "keyup": return m1.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function lv(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var ws = !1; function g1(e, t) { switch (e) { case "compositionend": return lv(t); case "keypress": return t.which !== 32 ? null : (dp = !0, cp); case "textInput": return e = t.data, e === cp && dp ? null : e; default: return null } } function y1(e, t) { if (ws) return e === "compositionend" || !Id && av(e, t) ? (e = ov(), ka = jd = dr = null, ws = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return iv && t.locale !== "ko" ? null : t.data; default: return null } } var x1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function fp(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!x1[e.type] : t === "textarea" } function uv(e, t, n, r) { zm(r), t = Ka(t, "onChange"), 0 < t.length && (n = new Od("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Ho = null, ii = null; function w1(e) { wv(e, 0) } function Rl(e) { var t = Cs(e); if (Om(t)) return e } function S1(e, t) { if (e === "change") return t } var cv = !1; if (Fn) { var Su; if (Fn) { var _u = "oninput" in document; if (!_u) { var pp = document.createElement("div"); pp.setAttribute("oninput", "return;"), _u = typeof pp.oninput == "function" } Su = _u } else Su = !1; cv = Su && (!document.documentMode || 9 < document.documentMode) } function hp() { Ho && (Ho.detachEvent("onpropertychange", dv), ii = Ho = null) } function dv(e) { if (e.propertyName === "value" && Rl(ii)) { var t = []; uv(t, ii, e, Td(e)), Wm(w1, t) } } function _1(e, t, n) { e === "focusin" ? (hp(), Ho = t, ii = n, Ho.attachEvent("onpropertychange", dv)) : e === "focusout" && hp() } function C1(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Rl(ii) } function k1(e, t) { if (e === "click") return Rl(t) } function b1(e, t) { if (e === "input" || e === "change") return Rl(t) } function E1(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var on = typeof Object.is == "function" ? Object.is : E1; function ai(e, t) { if (on(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var s = n[r]; if (!tc.call(t, s) || !on(e[s], t[s])) return !1 } return !0 } function mp(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function vp(e, t) { var n = mp(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = mp(n) } } function fv(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? fv(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function pv() { for (var e = window, t = za(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = za(e.document) } return t } function Ld(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function T1(e) { var t = pv(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && fv(n.ownerDocument.documentElement, n)) { if (r !== null && Ld(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var s = n.textContent.length, o = Math.min(r.start, s); r = r.end === void 0 ? o : Math.min(r.end, s), !e.extend && o > r && (s = r, r = o, o = s), s = vp(n, o); var i = vp(n, r); s && i && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== i.node || e.focusOffset !== i.offset) && (t = t.createRange(), t.setStart(s.node, s.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(i.node, i.offset)) : (t.setEnd(i.node, i.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var N1 = Fn && "documentMode" in document && 11 >= document.documentMode, Ss = null, wc = null, Zo = null, Sc = !1; function gp(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Sc || Ss == null || Ss !== za(r) || (r = Ss, "selectionStart" in r && Ld(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Zo && ai(Zo, r) || (Zo = r, r = Ka(wc, "onSelect"), 0 < r.length && (t = new Od("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Ss))) } function ra(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var _s = { animationend: ra("Animation", "AnimationEnd"), animationiteration: ra("Animation", "AnimationIteration"), animationstart: ra("Animation", "AnimationStart"), transitionend: ra("Transition", "TransitionEnd") }, Cu = {}, hv = {}; Fn && (hv = document.createElement("div").style, "AnimationEvent" in window || (delete _s.animationend.animation, delete _s.animationiteration.animation, delete _s.animationstart.animation), "TransitionEvent" in window || delete _s.transitionend.transition); function Al(e) { if (Cu[e]) return Cu[e]; if (!_s[e]) return e; var t = _s[e], n; for (n in t) if (t.hasOwnProperty(n) && n in hv) return Cu[e] = t[n]; return e } var mv = Al("animationend"), vv = Al("animationiteration"), gv = Al("animationstart"), yv = Al("transitionend"), xv = new Map, yp = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Rr(e, t) { xv.set(e, t), is(t, [e]) } for (var ku = 0; ku < yp.length; ku++) { var bu = yp[ku], P1 = bu.toLowerCase(), R1 = bu[0].toUpperCase() + bu.slice(1); Rr(P1, "on" + R1) } Rr(mv, "onAnimationEnd"); Rr(vv, "onAnimationIteration"); Rr(gv, "onAnimationStart"); Rr("dblclick", "onDoubleClick"); Rr("focusin", "onFocus"); Rr("focusout", "onBlur"); Rr(yv, "onTransitionEnd"); qs("onMouseEnter", ["mouseout", "mouseover"]); qs("onMouseLeave", ["mouseout", "mouseover"]); qs("onPointerEnter", ["pointerout", "pointerover"]); qs("onPointerLeave", ["pointerout", "pointerover"]); is("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); is("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); is("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); is("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); is("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); is("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Mo = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), A1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Mo)); function xp(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Pw(r, t, void 0, e), e.currentTarget = null } function wv(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], s = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var i = r.length - 1; 0 <= i; i--) { var a = r[i], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== o && s.isPropagationStopped()) break e; xp(s, a, u), o = l } else for (i = 0; i < r.length; i++) { if (a = r[i], l = a.instance, u = a.currentTarget, a = a.listener, l !== o && s.isPropagationStopped()) break e; xp(s, a, u), o = l } } } if (Ua) throw e = vc, Ua = !1, vc = null, e } function Ee(e, t) { var n = t[Ec]; n === void 0 && (n = t[Ec] = new Set); var r = e + "__bubble"; n.has(r) || (Sv(t, e, 2, !1), n.add(r)) } function Eu(e, t, n) { var r = 0; t && (r |= 4), Sv(n, e, r, t) } var sa = "_reactListening" + Math.random().toString(36).slice(2); function li(e) { if (!e[sa]) { e[sa] = !0, Nm.forEach(function (n) { n !== "selectionchange" && (A1.has(n) || Eu(n, !1, e), Eu(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[sa] || (t[sa] = !0, Eu("selectionchange", !1, t)) } } function Sv(e, t, n, r) { switch (sv(t)) { case 1: var s = Hw; break; case 4: s = Zw; break; default: s = Ad }n = s.bind(null, t, n, e), s = void 0, !mc || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = !0), r ? s !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: s }) : e.addEventListener(t, n, !0) : s !== void 0 ? e.addEventListener(t, n, { passive: s }) : e.addEventListener(t, n, !1) } function Tu(e, t, n, r, s) { var o = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var i = r.tag; if (i === 3 || i === 4) { var a = r.stateNode.containerInfo; if (a === s || a.nodeType === 8 && a.parentNode === s) break; if (i === 4) for (i = r.return; i !== null;) { var l = i.tag; if ((l === 3 || l === 4) && (l = i.stateNode.containerInfo, l === s || l.nodeType === 8 && l.parentNode === s)) return; i = i.return } for (; a !== null;) { if (i = Fr(a), i === null) return; if (l = i.tag, l === 5 || l === 6) { r = o = i; continue e } a = a.parentNode } } r = r.return } Wm(function () { var u = o, c = Td(n), p = []; e: { var h = xv.get(e); if (h !== void 0) { var w = Od, S = e; switch (e) { case "keypress": if (ba(n) === 0) break e; case "keydown": case "keyup": w = a1; break; case "focusin": S = "focus", w = wu; break; case "focusout": S = "blur", w = wu; break; case "beforeblur": case "afterblur": w = wu; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": w = ap; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": w = Gw; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": w = c1; break; case mv: case vv: case gv: w = Xw; break; case yv: w = f1; break; case "scroll": w = Kw; break; case "wheel": w = h1; break; case "copy": case "cut": case "paste": w = e1; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": w = up }var m = (t & 4) !== 0, x = !m && e === "scroll", g = m ? h !== null ? h + "Capture" : null : h; m = []; for (var f = u, y; f !== null;) { y = f; var _ = y.stateNode; if (y.tag === 5 && _ !== null && (y = _, g !== null && (_ = ni(f, g), _ != null && m.push(ui(f, _, y)))), x) break; f = f.return } 0 < m.length && (h = new w(h, S, null, n, c), p.push({ event: h, listeners: m })) } } if (!(t & 7)) { e: { if (h = e === "mouseover" || e === "pointerover", w = e === "mouseout" || e === "pointerout", h && n !== pc && (S = n.relatedTarget || n.fromElement) && (Fr(S) || S[Vn])) break e; if ((w || h) && (h = c.window === c ? c : (h = c.ownerDocument) ? h.defaultView || h.parentWindow : window, w ? (S = n.relatedTarget || n.toElement, w = u, S = S ? Fr(S) : null, S !== null && (x = as(S), S !== x || S.tag !== 5 && S.tag !== 6) && (S = null)) : (w = null, S = u), w !== S)) { if (m = ap, _ = "onMouseLeave", g = "onMouseEnter", f = "mouse", (e === "pointerout" || e === "pointerover") && (m = up, _ = "onPointerLeave", g = "onPointerEnter", f = "pointer"), x = w == null ? h : Cs(w), y = S == null ? h : Cs(S), h = new m(_, f + "leave", w, n, c), h.target = x, h.relatedTarget = y, _ = null, Fr(c) === u && (m = new m(g, f + "enter", S, n, c), m.target = y, m.relatedTarget = x, _ = m), x = _, w && S) t: { for (m = w, g = S, f = 0, y = m; y; y = ds(y))f++; for (y = 0, _ = g; _; _ = ds(_))y++; for (; 0 < f - y;)m = ds(m), f--; for (; 0 < y - f;)g = ds(g), y--; for (; f--;) { if (m === g || g !== null && m === g.alternate) break t; m = ds(m), g = ds(g) } m = null } else m = null; w !== null && wp(p, h, w, m, !1), S !== null && x !== null && wp(p, x, S, m, !0) } } e: { if (h = u ? Cs(u) : window, w = h.nodeName && h.nodeName.toLowerCase(), w === "select" || w === "input" && h.type === "file") var k = S1; else if (fp(h)) if (cv) k = b1; else { k = C1; var T = _1 } else (w = h.nodeName) && w.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (k = k1); if (k && (k = k(e, u))) { uv(p, k, n, c); break e } T && T(e, h, u), e === "focusout" && (T = h._wrapperState) && T.controlled && h.type === "number" && lc(h, "number", h.value) } switch (T = u ? Cs(u) : window, e) { case "focusin": (fp(T) || T.contentEditable === "true") && (Ss = T, wc = u, Zo = null); break; case "focusout": Zo = wc = Ss = null; break; case "mousedown": Sc = !0; break; case "contextmenu": case "mouseup": case "dragend": Sc = !1, gp(p, n, c); break; case "selectionchange": if (N1) break; case "keydown": case "keyup": gp(p, n, c) }var b; if (Id) e: { switch (e) { case "compositionstart": var R = "onCompositionStart"; break e; case "compositionend": R = "onCompositionEnd"; break e; case "compositionupdate": R = "onCompositionUpdate"; break e }R = void 0 } else ws ? av(e, n) && (R = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (R = "onCompositionStart"); R && (iv && n.locale !== "ko" && (ws || R !== "onCompositionStart" ? R === "onCompositionEnd" && ws && (b = ov()) : (dr = c, jd = "value" in dr ? dr.value : dr.textContent, ws = !0)), T = Ka(u, R), 0 < T.length && (R = new lp(R, e, null, n, c), p.push({ event: R, listeners: T }), b ? R.data = b : (b = lv(n), b !== null && (R.data = b)))), (b = v1 ? g1(e, n) : y1(e, n)) && (u = Ka(u, "onBeforeInput"), 0 < u.length && (c = new lp("onBeforeInput", "beforeinput", null, n, c), p.push({ event: c, listeners: u }), c.data = b)) } wv(p, t) }) } function ui(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Ka(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var s = e, o = s.stateNode; s.tag === 5 && o !== null && (s = o, o = ni(e, n), o != null && r.unshift(ui(e, o, s)), o = ni(e, t), o != null && r.push(ui(e, o, s))), e = e.return } return r } function ds(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function wp(e, t, n, r, s) { for (var o = t._reactName, i = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, s ? (l = ni(n, o), l != null && i.unshift(ui(n, l, a))) : s || (l = ni(n, o), l != null && i.push(ui(n, l, a)))), n = n.return } i.length !== 0 && e.push({ event: t, listeners: i }) } var j1 = /\r\n?/g, O1 = /\u0000|\uFFFD/g; function Sp(e) {
  return (typeof e == "string" ? e : "" + e).replace(j1, `
`).replace(O1, "")
} function oa(e, t, n) { if (t = Sp(t), Sp(e) !== t && n) throw Error(I(425)) } function Qa() { } var _c = null, Cc = null; function kc(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var bc = typeof setTimeout == "function" ? setTimeout : void 0, M1 = typeof clearTimeout == "function" ? clearTimeout : void 0, _p = typeof Promise == "function" ? Promise : void 0, I1 = typeof queueMicrotask == "function" ? queueMicrotask : typeof _p < "u" ? function (e) { return _p.resolve(null).then(e).catch(L1) } : bc; function L1(e) { setTimeout(function () { throw e }) } function Nu(e, t) { var n = t, r = 0; do { var s = n.nextSibling; if (e.removeChild(n), s && s.nodeType === 8) if (n = s.data, n === "/$") { if (r === 0) { e.removeChild(s), oi(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = s } while (n); oi(t) } function vr(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Cp(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var po = Math.random().toString(36).slice(2), mn = "__reactFiber$" + po, ci = "__reactProps$" + po, Vn = "__reactContainer$" + po, Ec = "__reactEvents$" + po, D1 = "__reactListeners$" + po, F1 = "__reactHandles$" + po; function Fr(e) { var t = e[mn]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Vn] || n[mn]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Cp(e); e !== null;) { if (n = e[mn]) return n; e = Cp(e) } return t } e = n, n = e.parentNode } return null } function Vi(e) { return e = e[mn] || e[Vn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Cs(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(I(33)) } function jl(e) { return e[ci] || null } var Tc = [], ks = -1; function Ar(e) { return { current: e } } function Te(e) { 0 > ks || (e.current = Tc[ks], Tc[ks] = null, ks--) } function ke(e, t) { ks++, Tc[ks] = e.current, e.current = t } var _r = {}, at = Ar(_r), _t = Ar(!1), Gr = _r; function Ys(e, t) { var n = e.type.contextTypes; if (!n) return _r; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var s = {}, o; for (o in n) s[o] = t[o]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function Ct(e) { return e = e.childContextTypes, e != null } function Ga() { Te(_t), Te(at) } function kp(e, t, n) { if (at.current !== _r) throw Error(I(168)); ke(at, t), ke(_t, n) } function _v(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var s in r) if (!(s in t)) throw Error(I(108, _w(e) || "Unknown", s)); return je({}, n, r) } function qa(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || _r, Gr = at.current, ke(at, e), ke(_t, _t.current), !0 } function bp(e, t, n) { var r = e.stateNode; if (!r) throw Error(I(169)); n ? (e = _v(e, t, Gr), r.__reactInternalMemoizedMergedChildContext = e, Te(_t), Te(at), ke(at, e)) : Te(_t), ke(_t, n) } var An = null, Ol = !1, Pu = !1; function Cv(e) { An === null ? An = [e] : An.push(e) } function V1(e) { Ol = !0, Cv(e) } function jr() { if (!Pu && An !== null) { Pu = !0; var e = 0, t = we; try { var n = An; for (we = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } An = null, Ol = !1 } catch (s) { throw An !== null && (An = An.slice(e + 1)), Qm(Nd, jr), s } finally { we = t, Pu = !1 } } return null } var bs = [], Es = 0, Ya = null, Xa = 0, zt = [], $t = 0, qr = null, Mn = 1, In = ""; function Lr(e, t) { bs[Es++] = Xa, bs[Es++] = Ya, Ya = e, Xa = t } function kv(e, t, n) { zt[$t++] = Mn, zt[$t++] = In, zt[$t++] = qr, qr = e; var r = Mn; e = In; var s = 32 - nn(r) - 1; r &= ~(1 << s), n += 1; var o = 32 - nn(t) + s; if (30 < o) { var i = s - s % 5; o = (r & (1 << i) - 1).toString(32), r >>= i, s -= i, Mn = 1 << 32 - nn(t) + s | n << s | r, In = o + e } else Mn = 1 << o | n << s | r, In = e } function Dd(e) { e.return !== null && (Lr(e, 1), kv(e, 1, 0)) } function Fd(e) { for (; e === Ya;)Ya = bs[--Es], bs[Es] = null, Xa = bs[--Es], bs[Es] = null; for (; e === qr;)qr = zt[--$t], zt[$t] = null, In = zt[--$t], zt[$t] = null, Mn = zt[--$t], zt[$t] = null } var jt = null, At = null, Ne = !1, Xt = null; function bv(e, t) { var n = Ut(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Ep(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, jt = e, At = vr(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, jt = e, At = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = qr !== null ? { id: Mn, overflow: In } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = Ut(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, jt = e, At = null, !0) : !1; default: return !1 } } function Nc(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Pc(e) { if (Ne) { var t = At; if (t) { var n = t; if (!Ep(e, t)) { if (Nc(e)) throw Error(I(418)); t = vr(n.nextSibling); var r = jt; t && Ep(e, t) ? bv(r, n) : (e.flags = e.flags & -4097 | 2, Ne = !1, jt = e) } } else { if (Nc(e)) throw Error(I(418)); e.flags = e.flags & -4097 | 2, Ne = !1, jt = e } } } function Tp(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; jt = e } function ia(e) { if (e !== jt) return !1; if (!Ne) return Tp(e), Ne = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !kc(e.type, e.memoizedProps)), t && (t = At)) { if (Nc(e)) throw Ev(), Error(I(418)); for (; t;)bv(e, t), t = vr(t.nextSibling) } if (Tp(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(I(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { At = vr(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } At = null } } else At = jt ? vr(e.stateNode.nextSibling) : null; return !0 } function Ev() { for (var e = At; e;)e = vr(e.nextSibling) } function Xs() { At = jt = null, Ne = !1 } function Vd(e) { Xt === null ? Xt = [e] : Xt.push(e) } var z1 = Hn.ReactCurrentBatchConfig; function Co(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(I(309)); var r = n.stateNode } if (!r) throw Error(I(147, e)); var s = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (i) { var a = s.refs; i === null ? delete a[o] : a[o] = i }, t._stringRef = o, t) } if (typeof e != "string") throw Error(I(284)); if (!n._owner) throw Error(I(290, e)) } return e } function aa(e, t) { throw e = Object.prototype.toString.call(t), Error(I(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Np(e) { var t = e._init; return t(e._payload) } function Tv(e) { function t(g, f) { if (e) { var y = g.deletions; y === null ? (g.deletions = [f], g.flags |= 16) : y.push(f) } } function n(g, f) { if (!e) return null; for (; f !== null;)t(g, f), f = f.sibling; return null } function r(g, f) { for (g = new Map; f !== null;)f.key !== null ? g.set(f.key, f) : g.set(f.index, f), f = f.sibling; return g } function s(g, f) { return g = wr(g, f), g.index = 0, g.sibling = null, g } function o(g, f, y) { return g.index = y, e ? (y = g.alternate, y !== null ? (y = y.index, y < f ? (g.flags |= 2, f) : y) : (g.flags |= 2, f)) : (g.flags |= 1048576, f) } function i(g) { return e && g.alternate === null && (g.flags |= 2), g } function a(g, f, y, _) { return f === null || f.tag !== 6 ? (f = Lu(y, g.mode, _), f.return = g, f) : (f = s(f, y), f.return = g, f) } function l(g, f, y, _) { var k = y.type; return k === xs ? c(g, f, y.props.children, _, y.key) : f !== null && (f.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Jn && Np(k) === f.type) ? (_ = s(f, y.props), _.ref = Co(g, f, y), _.return = g, _) : (_ = ja(y.type, y.key, y.props, null, g.mode, _), _.ref = Co(g, f, y), _.return = g, _) } function u(g, f, y, _) { return f === null || f.tag !== 4 || f.stateNode.containerInfo !== y.containerInfo || f.stateNode.implementation !== y.implementation ? (f = Du(y, g.mode, _), f.return = g, f) : (f = s(f, y.children || []), f.return = g, f) } function c(g, f, y, _, k) { return f === null || f.tag !== 7 ? (f = Kr(y, g.mode, _, k), f.return = g, f) : (f = s(f, y), f.return = g, f) } function p(g, f, y) { if (typeof f == "string" && f !== "" || typeof f == "number") return f = Lu("" + f, g.mode, y), f.return = g, f; if (typeof f == "object" && f !== null) { switch (f.$$typeof) { case qi: return y = ja(f.type, f.key, f.props, null, g.mode, y), y.ref = Co(g, null, f), y.return = g, y; case ys: return f = Du(f, g.mode, y), f.return = g, f; case Jn: var _ = f._init; return p(g, _(f._payload), y) }if (jo(f) || yo(f)) return f = Kr(f, g.mode, y, null), f.return = g, f; aa(g, f) } return null } function h(g, f, y, _) { var k = f !== null ? f.key : null; if (typeof y == "string" && y !== "" || typeof y == "number") return k !== null ? null : a(g, f, "" + y, _); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case qi: return y.key === k ? l(g, f, y, _) : null; case ys: return y.key === k ? u(g, f, y, _) : null; case Jn: return k = y._init, h(g, f, k(y._payload), _) }if (jo(y) || yo(y)) return k !== null ? null : c(g, f, y, _, null); aa(g, y) } return null } function w(g, f, y, _, k) { if (typeof _ == "string" && _ !== "" || typeof _ == "number") return g = g.get(y) || null, a(f, g, "" + _, k); if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case qi: return g = g.get(_.key === null ? y : _.key) || null, l(f, g, _, k); case ys: return g = g.get(_.key === null ? y : _.key) || null, u(f, g, _, k); case Jn: var T = _._init; return w(g, f, y, T(_._payload), k) }if (jo(_) || yo(_)) return g = g.get(y) || null, c(f, g, _, k, null); aa(f, _) } return null } function S(g, f, y, _) { for (var k = null, T = null, b = f, R = f = 0, F = null; b !== null && R < y.length; R++) { b.index > R ? (F = b, b = null) : F = b.sibling; var V = h(g, b, y[R], _); if (V === null) { b === null && (b = F); break } e && b && V.alternate === null && t(g, b), f = o(V, f, R), T === null ? k = V : T.sibling = V, T = V, b = F } if (R === y.length) return n(g, b), Ne && Lr(g, R), k; if (b === null) { for (; R < y.length; R++)b = p(g, y[R], _), b !== null && (f = o(b, f, R), T === null ? k = b : T.sibling = b, T = b); return Ne && Lr(g, R), k } for (b = r(g, b); R < y.length; R++)F = w(b, g, R, y[R], _), F !== null && (e && F.alternate !== null && b.delete(F.key === null ? R : F.key), f = o(F, f, R), T === null ? k = F : T.sibling = F, T = F); return e && b.forEach(function (Y) { return t(g, Y) }), Ne && Lr(g, R), k } function m(g, f, y, _) { var k = yo(y); if (typeof k != "function") throw Error(I(150)); if (y = k.call(y), y == null) throw Error(I(151)); for (var T = k = null, b = f, R = f = 0, F = null, V = y.next(); b !== null && !V.done; R++, V = y.next()) { b.index > R ? (F = b, b = null) : F = b.sibling; var Y = h(g, b, V.value, _); if (Y === null) { b === null && (b = F); break } e && b && Y.alternate === null && t(g, b), f = o(Y, f, R), T === null ? k = Y : T.sibling = Y, T = Y, b = F } if (V.done) return n(g, b), Ne && Lr(g, R), k; if (b === null) { for (; !V.done; R++, V = y.next())V = p(g, V.value, _), V !== null && (f = o(V, f, R), T === null ? k = V : T.sibling = V, T = V); return Ne && Lr(g, R), k } for (b = r(g, b); !V.done; R++, V = y.next())V = w(b, g, R, V.value, _), V !== null && (e && V.alternate !== null && b.delete(V.key === null ? R : V.key), f = o(V, f, R), T === null ? k = V : T.sibling = V, T = V); return e && b.forEach(function (O) { return t(g, O) }), Ne && Lr(g, R), k } function x(g, f, y, _) { if (typeof y == "object" && y !== null && y.type === xs && y.key === null && (y = y.props.children), typeof y == "object" && y !== null) { switch (y.$$typeof) { case qi: e: { for (var k = y.key, T = f; T !== null;) { if (T.key === k) { if (k = y.type, k === xs) { if (T.tag === 7) { n(g, T.sibling), f = s(T, y.props.children), f.return = g, g = f; break e } } else if (T.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Jn && Np(k) === T.type) { n(g, T.sibling), f = s(T, y.props), f.ref = Co(g, T, y), f.return = g, g = f; break e } n(g, T); break } else t(g, T); T = T.sibling } y.type === xs ? (f = Kr(y.props.children, g.mode, _, y.key), f.return = g, g = f) : (_ = ja(y.type, y.key, y.props, null, g.mode, _), _.ref = Co(g, f, y), _.return = g, g = _) } return i(g); case ys: e: { for (T = y.key; f !== null;) { if (f.key === T) if (f.tag === 4 && f.stateNode.containerInfo === y.containerInfo && f.stateNode.implementation === y.implementation) { n(g, f.sibling), f = s(f, y.children || []), f.return = g, g = f; break e } else { n(g, f); break } else t(g, f); f = f.sibling } f = Du(y, g.mode, _), f.return = g, g = f } return i(g); case Jn: return T = y._init, x(g, f, T(y._payload), _) }if (jo(y)) return S(g, f, y, _); if (yo(y)) return m(g, f, y, _); aa(g, y) } return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y, f !== null && f.tag === 6 ? (n(g, f.sibling), f = s(f, y), f.return = g, g = f) : (n(g, f), f = Lu(y, g.mode, _), f.return = g, g = f), i(g)) : n(g, f) } return x } var Js = Tv(!0), Nv = Tv(!1), Ja = Ar(null), el = null, Ts = null, zd = null; function $d() { zd = Ts = el = null } function Ud(e) { var t = Ja.current; Te(Ja), e._currentValue = t } function Rc(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Is(e, t) { el = e, zd = Ts = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (St = !0), e.firstContext = null) } function Wt(e) { var t = e._currentValue; if (zd !== e) if (e = { context: e, memoizedValue: t, next: null }, Ts === null) { if (el === null) throw Error(I(308)); Ts = e, el.dependencies = { lanes: 0, firstContext: e } } else Ts = Ts.next = e; return t } var Vr = null; function Bd(e) { Vr === null ? Vr = [e] : Vr.push(e) } function Pv(e, t, n, r) { var s = t.interleaved; return s === null ? (n.next = n, Bd(t)) : (n.next = s.next, s.next = n), t.interleaved = n, zn(e, r) } function zn(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var er = !1; function Wd(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Rv(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Ln(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function gr(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, pe & 2) { var s = r.pending; return s === null ? t.next = t : (t.next = s.next, s.next = t), r.pending = t, zn(e, n) } return s = r.interleaved, s === null ? (t.next = t, Bd(r)) : (t.next = s.next, s.next = t), r.interleaved = t, zn(e, n) } function Ea(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Pd(e, n) } } function Pp(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var s = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var i = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? s = o = i : o = o.next = i, n = n.next } while (n !== null); o === null ? s = o = t : o = o.next = t } else s = o = t; n = { baseState: r.baseState, firstBaseUpdate: s, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function tl(e, t, n, r) { var s = e.updateQueue; er = !1; var o = s.firstBaseUpdate, i = s.lastBaseUpdate, a = s.shared.pending; if (a !== null) { s.shared.pending = null; var l = a, u = l.next; l.next = null, i === null ? o = u : i.next = u, i = l; var c = e.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== i && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (o !== null) { var p = s.baseState; i = 0, c = u = l = null, a = o; do { var h = a.lane, w = a.eventTime; if ((r & h) === h) { c !== null && (c = c.next = { eventTime: w, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var S = e, m = a; switch (h = t, w = n, m.tag) { case 1: if (S = m.payload, typeof S == "function") { p = S.call(w, p, h); break e } p = S; break e; case 3: S.flags = S.flags & -65537 | 128; case 0: if (S = m.payload, h = typeof S == "function" ? S.call(w, p, h) : S, h == null) break e; p = je({}, p, h); break e; case 2: er = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, h = s.effects, h === null ? s.effects = [a] : h.push(a)) } else w = { eventTime: w, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = w, l = p) : c = c.next = w, i |= h; if (a = a.next, a === null) { if (a = s.shared.pending, a === null) break; h = a, a = h.next, h.next = null, s.lastBaseUpdate = h, s.shared.pending = null } } while (!0); if (c === null && (l = p), s.baseState = l, s.firstBaseUpdate = u, s.lastBaseUpdate = c, t = s.shared.interleaved, t !== null) { s = t; do i |= s.lane, s = s.next; while (s !== t) } else o === null && (s.shared.lanes = 0); Xr |= i, e.lanes = i, e.memoizedState = p } } function Rp(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], s = r.callback; if (s !== null) { if (r.callback = null, r = n, typeof s != "function") throw Error(I(191, s)); s.call(r) } } } var zi = {}, xn = Ar(zi), di = Ar(zi), fi = Ar(zi); function zr(e) { if (e === zi) throw Error(I(174)); return e } function Hd(e, t) { switch (ke(fi, t), ke(di, e), ke(xn, zi), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : cc(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = cc(t, e) }Te(xn), ke(xn, t) } function eo() { Te(xn), Te(di), Te(fi) } function Av(e) { zr(fi.current); var t = zr(xn.current), n = cc(t, e.type); t !== n && (ke(di, e), ke(xn, n)) } function Zd(e) { di.current === e && (Te(xn), Te(di)) } var Re = Ar(0); function nl(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Ru = []; function Kd() { for (var e = 0; e < Ru.length; e++)Ru[e]._workInProgressVersionPrimary = null; Ru.length = 0 } var Ta = Hn.ReactCurrentDispatcher, Au = Hn.ReactCurrentBatchConfig, Yr = 0, Ae = null, He = null, Qe = null, rl = !1, Ko = !1, pi = 0, $1 = 0; function rt() { throw Error(I(321)) } function Qd(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!on(e[n], t[n])) return !1; return !0 } function Gd(e, t, n, r, s, o) { if (Yr = o, Ae = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Ta.current = e === null || e.memoizedState === null ? H1 : Z1, e = n(r, s), Ko) { o = 0; do { if (Ko = !1, pi = 0, 25 <= o) throw Error(I(301)); o += 1, Qe = He = null, t.updateQueue = null, Ta.current = K1, e = n(r, s) } while (Ko) } if (Ta.current = sl, t = He !== null && He.next !== null, Yr = 0, Qe = He = Ae = null, rl = !1, t) throw Error(I(300)); return e } function qd() { var e = pi !== 0; return pi = 0, e } function dn() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Qe === null ? Ae.memoizedState = Qe = e : Qe = Qe.next = e, Qe } function Ht() { if (He === null) { var e = Ae.alternate; e = e !== null ? e.memoizedState : null } else e = He.next; var t = Qe === null ? Ae.memoizedState : Qe.next; if (t !== null) Qe = t, He = e; else { if (e === null) throw Error(I(310)); He = e, e = { memoizedState: He.memoizedState, baseState: He.baseState, baseQueue: He.baseQueue, queue: He.queue, next: null }, Qe === null ? Ae.memoizedState = Qe = e : Qe = Qe.next = e } return Qe } function hi(e, t) { return typeof t == "function" ? t(e) : t } function ju(e) { var t = Ht(), n = t.queue; if (n === null) throw Error(I(311)); n.lastRenderedReducer = e; var r = He, s = r.baseQueue, o = n.pending; if (o !== null) { if (s !== null) { var i = s.next; s.next = o.next, o.next = i } r.baseQueue = s = o, n.pending = null } if (s !== null) { o = s.next, r = r.baseState; var a = i = null, l = null, u = o; do { var c = u.lane; if ((Yr & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var p = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = p, i = r) : l = l.next = p, Ae.lanes |= c, Xr |= c } u = u.next } while (u !== null && u !== o); l === null ? i = r : l.next = a, on(r, t.memoizedState) || (St = !0), t.memoizedState = r, t.baseState = i, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { s = e; do o = s.lane, Ae.lanes |= o, Xr |= o, s = s.next; while (s !== e) } else s === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Ou(e) { var t = Ht(), n = t.queue; if (n === null) throw Error(I(311)); n.lastRenderedReducer = e; var r = n.dispatch, s = n.pending, o = t.memoizedState; if (s !== null) { n.pending = null; var i = s = s.next; do o = e(o, i.action), i = i.next; while (i !== s); on(o, t.memoizedState) || (St = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function jv() { } function Ov(e, t) { var n = Ae, r = Ht(), s = t(), o = !on(r.memoizedState, s); if (o && (r.memoizedState = s, St = !0), r = r.queue, Yd(Lv.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || Qe !== null && Qe.memoizedState.tag & 1) { if (n.flags |= 2048, mi(9, Iv.bind(null, n, r, s, t), void 0, null), Ge === null) throw Error(I(349)); Yr & 30 || Mv(n, t, s) } return s } function Mv(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = Ae.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Ae.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Iv(e, t, n, r) { t.value = n, t.getSnapshot = r, Dv(t) && Fv(e) } function Lv(e, t, n) { return n(function () { Dv(t) && Fv(e) }) } function Dv(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !on(e, n) } catch { return !0 } } function Fv(e) { var t = zn(e, 1); t !== null && rn(t, e, 1, -1) } function Ap(e) { var t = dn(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: hi, lastRenderedState: e }, t.queue = e, e = e.dispatch = W1.bind(null, Ae, e), [t.memoizedState, e] } function mi(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = Ae.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Ae.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function Vv() { return Ht().memoizedState } function Na(e, t, n, r) { var s = dn(); Ae.flags |= e, s.memoizedState = mi(1 | t, n, void 0, r === void 0 ? null : r) } function Ml(e, t, n, r) { var s = Ht(); r = r === void 0 ? null : r; var o = void 0; if (He !== null) { var i = He.memoizedState; if (o = i.destroy, r !== null && Qd(r, i.deps)) { s.memoizedState = mi(t, n, o, r); return } } Ae.flags |= e, s.memoizedState = mi(1 | t, n, o, r) } function jp(e, t) { return Na(8390656, 8, e, t) } function Yd(e, t) { return Ml(2048, 8, e, t) } function zv(e, t) { return Ml(4, 2, e, t) } function $v(e, t) { return Ml(4, 4, e, t) } function Uv(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Bv(e, t, n) { return n = n != null ? n.concat([e]) : null, Ml(4, 4, Uv.bind(null, t, e), n) } function Xd() { } function Wv(e, t) { var n = Ht(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Qd(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Hv(e, t) { var n = Ht(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Qd(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Zv(e, t, n) { return Yr & 21 ? (on(n, t) || (n = Ym(), Ae.lanes |= n, Xr |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, St = !0), e.memoizedState = n) } function U1(e, t) { var n = we; we = n !== 0 && 4 > n ? n : 4, e(!0); var r = Au.transition; Au.transition = {}; try { e(!1), t() } finally { we = n, Au.transition = r } } function Kv() { return Ht().memoizedState } function B1(e, t, n) { var r = xr(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Qv(e)) Gv(t, n); else if (n = Pv(e, t, n, r), n !== null) { var s = mt(); rn(n, e, r, s), qv(n, t, r) } } function W1(e, t, n) { var r = xr(e), s = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Qv(e)) Gv(t, s); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var i = t.lastRenderedState, a = o(i, n); if (s.hasEagerState = !0, s.eagerState = a, on(a, i)) { var l = t.interleaved; l === null ? (s.next = s, Bd(t)) : (s.next = l.next, l.next = s), t.interleaved = s; return } } catch { } finally { } n = Pv(e, t, s, r), n !== null && (s = mt(), rn(n, e, r, s), qv(n, t, r)) } } function Qv(e) { var t = e.alternate; return e === Ae || t !== null && t === Ae } function Gv(e, t) { Ko = rl = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function qv(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Pd(e, n) } } var sl = { readContext: Wt, useCallback: rt, useContext: rt, useEffect: rt, useImperativeHandle: rt, useInsertionEffect: rt, useLayoutEffect: rt, useMemo: rt, useReducer: rt, useRef: rt, useState: rt, useDebugValue: rt, useDeferredValue: rt, useTransition: rt, useMutableSource: rt, useSyncExternalStore: rt, useId: rt, unstable_isNewReconciler: !1 }, H1 = { readContext: Wt, useCallback: function (e, t) { return dn().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Wt, useEffect: jp, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Na(4194308, 4, Uv.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Na(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Na(4, 2, e, t) }, useMemo: function (e, t) { var n = dn(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = dn(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = B1.bind(null, Ae, e), [r.memoizedState, e] }, useRef: function (e) { var t = dn(); return e = { current: e }, t.memoizedState = e }, useState: Ap, useDebugValue: Xd, useDeferredValue: function (e) { return dn().memoizedState = e }, useTransition: function () { var e = Ap(!1), t = e[0]; return e = U1.bind(null, e[1]), dn().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = Ae, s = dn(); if (Ne) { if (n === void 0) throw Error(I(407)); n = n() } else { if (n = t(), Ge === null) throw Error(I(349)); Yr & 30 || Mv(r, t, n) } s.memoizedState = n; var o = { value: n, getSnapshot: t }; return s.queue = o, jp(Lv.bind(null, r, o, e), [e]), r.flags |= 2048, mi(9, Iv.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = dn(), t = Ge.identifierPrefix; if (Ne) { var n = In, r = Mn; n = (r & ~(1 << 32 - nn(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = pi++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = $1++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Z1 = { readContext: Wt, useCallback: Wv, useContext: Wt, useEffect: Yd, useImperativeHandle: Bv, useInsertionEffect: zv, useLayoutEffect: $v, useMemo: Hv, useReducer: ju, useRef: Vv, useState: function () { return ju(hi) }, useDebugValue: Xd, useDeferredValue: function (e) { var t = Ht(); return Zv(t, He.memoizedState, e) }, useTransition: function () { var e = ju(hi)[0], t = Ht().memoizedState; return [e, t] }, useMutableSource: jv, useSyncExternalStore: Ov, useId: Kv, unstable_isNewReconciler: !1 }, K1 = { readContext: Wt, useCallback: Wv, useContext: Wt, useEffect: Yd, useImperativeHandle: Bv, useInsertionEffect: zv, useLayoutEffect: $v, useMemo: Hv, useReducer: Ou, useRef: Vv, useState: function () { return Ou(hi) }, useDebugValue: Xd, useDeferredValue: function (e) { var t = Ht(); return He === null ? t.memoizedState = e : Zv(t, He.memoizedState, e) }, useTransition: function () { var e = Ou(hi)[0], t = Ht().memoizedState; return [e, t] }, useMutableSource: jv, useSyncExternalStore: Ov, useId: Kv, unstable_isNewReconciler: !1 }; function Qt(e, t) { if (e && e.defaultProps) { t = je({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function Ac(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : je({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var Il = { isMounted: function (e) { return (e = e._reactInternals) ? as(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = mt(), s = xr(e), o = Ln(r, s); o.payload = t, n != null && (o.callback = n), t = gr(e, o, s), t !== null && (rn(t, e, s, r), Ea(t, e, s)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = mt(), s = xr(e), o = Ln(r, s); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = gr(e, o, s), t !== null && (rn(t, e, s, r), Ea(t, e, s)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = mt(), r = xr(e), s = Ln(n, r); s.tag = 2, t != null && (s.callback = t), t = gr(e, s, r), t !== null && (rn(t, e, r, n), Ea(t, e, r)) } }; function Op(e, t, n, r, s, o, i) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, i) : t.prototype && t.prototype.isPureReactComponent ? !ai(n, r) || !ai(s, o) : !0 } function Yv(e, t, n) { var r = !1, s = _r, o = t.contextType; return typeof o == "object" && o !== null ? o = Wt(o) : (s = Ct(t) ? Gr : at.current, r = t.contextTypes, o = (r = r != null) ? Ys(e, s) : _r), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Il, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = o), t } function Mp(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Il.enqueueReplaceState(t, t.state, null) } function jc(e, t, n, r) { var s = e.stateNode; s.props = n, s.state = e.memoizedState, s.refs = {}, Wd(e); var o = t.contextType; typeof o == "object" && o !== null ? s.context = Wt(o) : (o = Ct(t) ? Gr : at.current, s.context = Ys(e, o)), s.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (Ac(e, t, o, n), s.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), t !== s.state && Il.enqueueReplaceState(s, s.state, null), tl(e, n, s, r), s.state = e.memoizedState), typeof s.componentDidMount == "function" && (e.flags |= 4194308) } function to(e, t) {
  try { var n = "", r = t; do n += Sw(r), r = r.return; while (r); var s = n } catch (o) {
    s = `
Error generating stack: `+ o.message + `
`+ o.stack
  } return { value: e, source: t, stack: s, digest: null }
} function Mu(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function Oc(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var Q1 = typeof WeakMap == "function" ? WeakMap : Map; function Xv(e, t, n) { n = Ln(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { il || (il = !0, Bc = r), Oc(e, t) }, n } function Jv(e, t, n) { n = Ln(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var s = t.value; n.payload = function () { return r(s) }, n.callback = function () { Oc(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { Oc(e, t), typeof r != "function" && (yr === null ? yr = new Set([this]) : yr.add(this)); var i = t.stack; this.componentDidCatch(t.value, { componentStack: i !== null ? i : "" }) }), n } function Ip(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new Q1; var s = new Set; r.set(t, s) } else s = r.get(t), s === void 0 && (s = new Set, r.set(t, s)); s.has(n) || (s.add(n), e = lS.bind(null, e, t, n), t.then(e, e)) } function Lp(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function Dp(e, t, n, r, s) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = s, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Ln(-1, 1), t.tag = 2, gr(n, t, 1))), n.lanes |= 1), e) } var G1 = Hn.ReactCurrentOwner, St = !1; function pt(e, t, n, r) { t.child = e === null ? Nv(t, null, n, r) : Js(t, e.child, n, r) } function Fp(e, t, n, r, s) { n = n.render; var o = t.ref; return Is(t, s), r = Gd(e, t, n, r, o, s), n = qd(), e !== null && !St ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, $n(e, t, s)) : (Ne && n && Dd(t), t.flags |= 1, pt(e, t, r, s), t.child) } function Vp(e, t, n, r, s) { if (e === null) { var o = n.type; return typeof o == "function" && !af(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, eg(e, t, o, r, s)) : (e = ja(n.type, null, r, t, t.mode, s), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & s)) { var i = o.memoizedProps; if (n = n.compare, n = n !== null ? n : ai, n(i, r) && e.ref === t.ref) return $n(e, t, s) } return t.flags |= 1, e = wr(o, r), e.ref = t.ref, e.return = t, t.child = e } function eg(e, t, n, r, s) { if (e !== null) { var o = e.memoizedProps; if (ai(o, r) && e.ref === t.ref) if (St = !1, t.pendingProps = r = o, (e.lanes & s) !== 0) e.flags & 131072 && (St = !0); else return t.lanes = e.lanes, $n(e, t, s) } return Mc(e, t, n, r, s) } function tg(e, t, n) { var r = t.pendingProps, s = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ke(Ps, Nt), Nt |= n; else { if (!(n & 1073741824)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, ke(Ps, Nt), Nt |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, ke(Ps, Nt), Nt |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, ke(Ps, Nt), Nt |= r; return pt(e, t, s, n), t.child } function ng(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Mc(e, t, n, r, s) { var o = Ct(n) ? Gr : at.current; return o = Ys(t, o), Is(t, s), n = Gd(e, t, n, r, o, s), r = qd(), e !== null && !St ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, $n(e, t, s)) : (Ne && r && Dd(t), t.flags |= 1, pt(e, t, n, s), t.child) } function zp(e, t, n, r, s) { if (Ct(n)) { var o = !0; qa(t) } else o = !1; if (Is(t, s), t.stateNode === null) Pa(e, t), Yv(t, n, r), jc(t, n, r, s), r = !0; else if (e === null) { var i = t.stateNode, a = t.memoizedProps; i.props = a; var l = i.context, u = n.contextType; typeof u == "object" && u !== null ? u = Wt(u) : (u = Ct(n) ? Gr : at.current, u = Ys(t, u)); var c = n.getDerivedStateFromProps, p = typeof c == "function" || typeof i.getSnapshotBeforeUpdate == "function"; p || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (a !== r || l !== u) && Mp(t, i, r, u), er = !1; var h = t.memoizedState; i.state = h, tl(t, r, i, s), l = t.memoizedState, a !== r || h !== l || _t.current || er ? (typeof c == "function" && (Ac(t, n, c, r), l = t.memoizedState), (a = er || Op(t, n, a, r, h, l, u)) ? (p || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount()), typeof i.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof i.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), i.props = r, i.state = l, i.context = u, r = a) : (typeof i.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { i = t.stateNode, Rv(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : Qt(t.type, a), i.props = u, p = t.pendingProps, h = i.context, l = n.contextType, typeof l == "object" && l !== null ? l = Wt(l) : (l = Ct(n) ? Gr : at.current, l = Ys(t, l)); var w = n.getDerivedStateFromProps; (c = typeof w == "function" || typeof i.getSnapshotBeforeUpdate == "function") || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (a !== p || h !== l) && Mp(t, i, r, l), er = !1, h = t.memoizedState, i.state = h, tl(t, r, i, s); var S = t.memoizedState; a !== p || h !== S || _t.current || er ? (typeof w == "function" && (Ac(t, n, w, r), S = t.memoizedState), (u = er || Op(t, n, u, r, h, S, l) || !1) ? (c || typeof i.UNSAFE_componentWillUpdate != "function" && typeof i.componentWillUpdate != "function" || (typeof i.componentWillUpdate == "function" && i.componentWillUpdate(r, S, l), typeof i.UNSAFE_componentWillUpdate == "function" && i.UNSAFE_componentWillUpdate(r, S, l)), typeof i.componentDidUpdate == "function" && (t.flags |= 4), typeof i.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof i.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = S), i.props = r, i.state = S, i.context = l, r = u) : (typeof i.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return Ic(e, t, n, r, o, s) } function Ic(e, t, n, r, s, o) { ng(e, t); var i = (t.flags & 128) !== 0; if (!r && !i) return s && bp(t, n, !1), $n(e, t, o); r = t.stateNode, G1.current = t; var a = i && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && i ? (t.child = Js(t, e.child, null, o), t.child = Js(t, null, a, o)) : pt(e, t, a, o), t.memoizedState = r.state, s && bp(t, n, !0), t.child } function rg(e) { var t = e.stateNode; t.pendingContext ? kp(e, t.pendingContext, t.pendingContext !== t.context) : t.context && kp(e, t.context, !1), Hd(e, t.containerInfo) } function $p(e, t, n, r, s) { return Xs(), Vd(s), t.flags |= 256, pt(e, t, n, r), t.child } var Lc = { dehydrated: null, treeContext: null, retryLane: 0 }; function Dc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function sg(e, t, n) { var r = t.pendingProps, s = Re.current, o = !1, i = (t.flags & 128) !== 0, a; if ((a = i) || (a = e !== null && e.memoizedState === null ? !1 : (s & 2) !== 0), a ? (o = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1), ke(Re, s & 1), e === null) return Pc(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (i = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, i = { mode: "hidden", children: i }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = i) : o = Fl(i, r, 0, null), e = Kr(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = Dc(n), t.memoizedState = Lc, e) : Jd(t, i)); if (s = e.memoizedState, s !== null && (a = s.dehydrated, a !== null)) return q1(e, t, i, r, a, s, n); if (o) { o = r.fallback, i = t.mode, s = e.child, a = s.sibling; var l = { mode: "hidden", children: r.children }; return !(i & 1) && t.child !== s ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = wr(s, l), r.subtreeFlags = s.subtreeFlags & 14680064), a !== null ? o = wr(a, o) : (o = Kr(o, i, n, null), o.flags |= 2), o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, i = e.child.memoizedState, i = i === null ? Dc(n) : { baseLanes: i.baseLanes | n, cachePool: null, transitions: i.transitions }, o.memoizedState = i, o.childLanes = e.childLanes & ~n, t.memoizedState = Lc, r } return o = e.child, e = o.sibling, r = wr(o, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Jd(e, t) { return t = Fl({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function la(e, t, n, r) { return r !== null && Vd(r), Js(t, e.child, null, n), e = Jd(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function q1(e, t, n, r, s, o, i) { if (n) return t.flags & 256 ? (t.flags &= -257, r = Mu(Error(I(422))), la(e, t, i, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, s = t.mode, r = Fl({ mode: "visible", children: r.children }, s, 0, null), o = Kr(o, s, i, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, t.mode & 1 && Js(t, e.child, null, i), t.child.memoizedState = Dc(i), t.memoizedState = Lc, o); if (!(t.mode & 1)) return la(e, t, i, null); if (s.data === "$!") { if (r = s.nextSibling && s.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(I(419)), r = Mu(o, r, void 0), la(e, t, i, r) } if (a = (i & e.childLanes) !== 0, St || a) { if (r = Ge, r !== null) { switch (i & -i) { case 4: s = 2; break; case 16: s = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: s = 32; break; case 536870912: s = 268435456; break; default: s = 0 }s = s & (r.suspendedLanes | i) ? 0 : s, s !== 0 && s !== o.retryLane && (o.retryLane = s, zn(e, s), rn(r, e, s, -1)) } return of(), r = Mu(Error(I(421))), la(e, t, i, r) } return s.data === "$?" ? (t.flags |= 128, t.child = e.child, t = uS.bind(null, e), s._reactRetry = t, null) : (e = o.treeContext, At = vr(s.nextSibling), jt = t, Ne = !0, Xt = null, e !== null && (zt[$t++] = Mn, zt[$t++] = In, zt[$t++] = qr, Mn = e.id, In = e.overflow, qr = t), t = Jd(t, r.children), t.flags |= 4096, t) } function Up(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), Rc(e.return, t, n) } function Iu(e, t, n, r, s) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: s } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = s) } function og(e, t, n) { var r = t.pendingProps, s = r.revealOrder, o = r.tail; if (pt(e, t, r.children, n), r = Re.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Up(e, n, t); else if (e.tag === 19) Up(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (ke(Re, r), !(t.mode & 1)) t.memoizedState = null; else switch (s) { case "forwards": for (n = t.child, s = null; n !== null;)e = n.alternate, e !== null && nl(e) === null && (s = n), n = n.sibling; n = s, n === null ? (s = t.child, t.child = null) : (s = n.sibling, n.sibling = null), Iu(t, !1, s, n, o); break; case "backwards": for (n = null, s = t.child, t.child = null; s !== null;) { if (e = s.alternate, e !== null && nl(e) === null) { t.child = s; break } e = s.sibling, s.sibling = n, n = s, s = e } Iu(t, !0, n, null, o); break; case "together": Iu(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Pa(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function $n(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Xr |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(I(153)); if (t.child !== null) { for (e = t.child, n = wr(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = wr(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function Y1(e, t, n) { switch (t.tag) { case 3: rg(t), Xs(); break; case 5: Av(t); break; case 1: Ct(t.type) && qa(t); break; case 4: Hd(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, s = t.memoizedProps.value; ke(Ja, r._currentValue), r._currentValue = s; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (ke(Re, Re.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? sg(e, t, n) : (ke(Re, Re.current & 1), e = $n(e, t, n), e !== null ? e.sibling : null); ke(Re, Re.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return og(e, t, n); t.flags |= 128 } if (s = t.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), ke(Re, Re.current), r) break; return null; case 22: case 23: return t.lanes = 0, tg(e, t, n) }return $n(e, t, n) } var ig, Fc, ag, lg; ig = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Fc = function () { }; ag = function (e, t, n, r) { var s = e.memoizedProps; if (s !== r) { e = t.stateNode, zr(xn.current); var o = null; switch (n) { case "input": s = ic(e, s), r = ic(e, r), o = []; break; case "select": s = je({}, s, { value: void 0 }), r = je({}, r, { value: void 0 }), o = []; break; case "textarea": s = uc(e, s), r = uc(e, r), o = []; break; default: typeof s.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Qa) }dc(n, r); var i; n = null; for (u in s) if (!r.hasOwnProperty(u) && s.hasOwnProperty(u) && s[u] != null) if (u === "style") { var a = s[u]; for (i in a) a.hasOwnProperty(i) && (n || (n = {}), n[i] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (ei.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var l = r[u]; if (a = s != null ? s[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (i in a) !a.hasOwnProperty(i) || l && l.hasOwnProperty(i) || (n || (n = {}), n[i] = ""); for (i in l) l.hasOwnProperty(i) && a[i] !== l[i] && (n || (n = {}), n[i] = l[i]) } else n || (o || (o = []), o.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (ei.hasOwnProperty(u) ? (l != null && u === "onScroll" && Ee("scroll", e), o || a === l || (o = [])) : (o = o || []).push(u, l)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }; lg = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function ko(e, t) { if (!Ne) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function st(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags & 14680064, r |= s.flags & 14680064, s.return = e, s = s.sibling; else for (s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags, r |= s.flags, s.return = e, s = s.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function X1(e, t, n) { var r = t.pendingProps; switch (Fd(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return st(t), null; case 1: return Ct(t.type) && Ga(), st(t), null; case 3: return r = t.stateNode, eo(), Te(_t), Te(at), Kd(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (ia(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Xt !== null && (Zc(Xt), Xt = null))), Fc(e, t), st(t), null; case 5: Zd(t); var s = zr(fi.current); if (n = t.type, e !== null && t.stateNode != null) ag(e, t, n, r, s), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(I(166)); return st(t), null } if (e = zr(xn.current), ia(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[mn] = t, r[ci] = o, e = (t.mode & 1) !== 0, n) { case "dialog": Ee("cancel", r), Ee("close", r); break; case "iframe": case "object": case "embed": Ee("load", r); break; case "video": case "audio": for (s = 0; s < Mo.length; s++)Ee(Mo[s], r); break; case "source": Ee("error", r); break; case "img": case "image": case "link": Ee("error", r), Ee("load", r); break; case "details": Ee("toggle", r); break; case "input": Yf(r, o), Ee("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Ee("invalid", r); break; case "textarea": Jf(r, o), Ee("invalid", r) }dc(n, o), s = null; for (var i in o) if (o.hasOwnProperty(i)) { var a = o[i]; i === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && oa(r.textContent, a, e), s = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && oa(r.textContent, a, e), s = ["children", "" + a]) : ei.hasOwnProperty(i) && a != null && i === "onScroll" && Ee("scroll", r) } switch (n) { case "input": Yi(r), Xf(r, o, !0); break; case "textarea": Yi(r), ep(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = Qa) }r = s, t.updateQueue = r, r !== null && (t.flags |= 4) } else { i = s.nodeType === 9 ? s : s.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Lm(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = i.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = i.createElement(n, { is: r.is }) : (e = i.createElement(n), n === "select" && (i = e, r.multiple ? i.multiple = !0 : r.size && (i.size = r.size))) : e = i.createElementNS(e, n), e[mn] = t, e[ci] = r, ig(e, t, !1, !1), t.stateNode = e; e: { switch (i = fc(n, r), n) { case "dialog": Ee("cancel", e), Ee("close", e), s = r; break; case "iframe": case "object": case "embed": Ee("load", e), s = r; break; case "video": case "audio": for (s = 0; s < Mo.length; s++)Ee(Mo[s], e); s = r; break; case "source": Ee("error", e), s = r; break; case "img": case "image": case "link": Ee("error", e), Ee("load", e), s = r; break; case "details": Ee("toggle", e), s = r; break; case "input": Yf(e, r), s = ic(e, r), Ee("invalid", e); break; case "option": s = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, s = je({}, r, { value: void 0 }), Ee("invalid", e); break; case "textarea": Jf(e, r), s = uc(e, r), Ee("invalid", e); break; default: s = r }dc(n, s), a = s; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? Vm(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Dm(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && ti(e, l) : typeof l == "number" && ti(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (ei.hasOwnProperty(o) ? l != null && o === "onScroll" && Ee("scroll", e) : l != null && Cd(e, o, l, i)) } switch (n) { case "input": Yi(e), Xf(e, r, !1); break; case "textarea": Yi(e), ep(e); break; case "option": r.value != null && e.setAttribute("value", "" + Sr(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? As(e, !!r.multiple, o, !1) : r.defaultValue != null && As(e, !!r.multiple, r.defaultValue, !0); break; default: typeof s.onClick == "function" && (e.onclick = Qa) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return st(t), null; case 6: if (e && t.stateNode != null) lg(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(I(166)); if (n = zr(fi.current), zr(xn.current), ia(t)) { if (r = t.stateNode, n = t.memoizedProps, r[mn] = t, (o = r.nodeValue !== n) && (e = jt, e !== null)) switch (e.tag) { case 3: oa(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && oa(r.nodeValue, n, (e.mode & 1) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[mn] = t, t.stateNode = r } return st(t), null; case 13: if (Te(Re), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Ne && At !== null && t.mode & 1 && !(t.flags & 128)) Ev(), Xs(), t.flags |= 98560, o = !1; else if (o = ia(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(I(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(I(317)); o[mn] = t } else Xs(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; st(t), o = !1 } else Xt !== null && (Zc(Xt), Xt = null), o = !0; if (!o) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Re.current & 1 ? Ze === 0 && (Ze = 3) : of())), t.updateQueue !== null && (t.flags |= 4), st(t), null); case 4: return eo(), Fc(e, t), e === null && li(t.stateNode.containerInfo), st(t), null; case 10: return Ud(t.type._context), st(t), null; case 17: return Ct(t.type) && Ga(), st(t), null; case 19: if (Te(Re), o = t.memoizedState, o === null) return st(t), null; if (r = (t.flags & 128) !== 0, i = o.rendering, i === null) if (r) ko(o, !1); else { if (Ze !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (i = nl(e), i !== null) { for (t.flags |= 128, ko(o, !1), r = i.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, i = o.alternate, i === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = i.childLanes, o.lanes = i.lanes, o.child = i.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = i.memoizedProps, o.memoizedState = i.memoizedState, o.updateQueue = i.updateQueue, o.type = i.type, e = i.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return ke(Re, Re.current & 1 | 2), t.child } e = e.sibling } o.tail !== null && Ve() > no && (t.flags |= 128, r = !0, ko(o, !1), t.lanes = 4194304) } else { if (!r) if (e = nl(i), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), ko(o, !0), o.tail === null && o.tailMode === "hidden" && !i.alternate && !Ne) return st(t), null } else 2 * Ve() - o.renderingStartTime > no && n !== 1073741824 && (t.flags |= 128, r = !0, ko(o, !1), t.lanes = 4194304); o.isBackwards ? (i.sibling = t.child, t.child = i) : (n = o.last, n !== null ? n.sibling = i : t.child = i, o.last = i) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Ve(), t.sibling = null, n = Re.current, ke(Re, r ? n & 1 | 2 : n & 1), t) : (st(t), null); case 22: case 23: return sf(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Nt & 1073741824 && (st(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : st(t), null; case 24: return null; case 25: return null }throw Error(I(156, t.tag)) } function J1(e, t) { switch (Fd(t), t.tag) { case 1: return Ct(t.type) && Ga(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return eo(), Te(_t), Te(at), Kd(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return Zd(t), null; case 13: if (Te(Re), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(I(340)); Xs() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return Te(Re), null; case 4: return eo(), null; case 10: return Ud(t.type._context), null; case 22: case 23: return sf(), null; case 24: return null; default: return null } } var ua = !1, it = !1, eS = typeof WeakSet == "function" ? WeakSet : Set, Z = null; function Ns(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Me(e, t, r) } else n.current = null } function Vc(e, t, n) { try { n() } catch (r) { Me(e, t, r) } } var Bp = !1; function tS(e, t) { if (_c = Ha, e = pv(), Ld(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var s = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var i = 0, a = -1, l = -1, u = 0, c = 0, p = e, h = null; t: for (; ;) { for (var w; p !== n || s !== 0 && p.nodeType !== 3 || (a = i + s), p !== o || r !== 0 && p.nodeType !== 3 || (l = i + r), p.nodeType === 3 && (i += p.nodeValue.length), (w = p.firstChild) !== null;)h = p, p = w; for (; ;) { if (p === e) break t; if (h === n && ++u === s && (a = i), h === o && ++c === r && (l = i), (w = p.nextSibling) !== null) break; p = h, h = p.parentNode } p = w } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Cc = { focusedElem: e, selectionRange: n }, Ha = !1, Z = t; Z !== null;)if (t = Z, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, Z = e; else for (; Z !== null;) { t = Z; try { var S = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (S !== null) { var m = S.memoizedProps, x = S.memoizedState, g = t.stateNode, f = g.getSnapshotBeforeUpdate(t.elementType === t.type ? m : Qt(t.type, m), x); g.__reactInternalSnapshotBeforeUpdate = f } break; case 3: var y = t.stateNode.containerInfo; y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(I(163)) } } catch (_) { Me(t, t.return, _) } if (e = t.sibling, e !== null) { e.return = t.return, Z = e; break } Z = t.return } return S = Bp, Bp = !1, S } function Qo(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var s = r = r.next; do { if ((s.tag & e) === e) { var o = s.destroy; s.destroy = void 0, o !== void 0 && Vc(t, n, o) } s = s.next } while (s !== r) } } function Ll(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function zc(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function ug(e) { var t = e.alternate; t !== null && (e.alternate = null, ug(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[mn], delete t[ci], delete t[Ec], delete t[D1], delete t[F1])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function cg(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Wp(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || cg(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function $c(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Qa)); else if (r !== 4 && (e = e.child, e !== null)) for ($c(e, t, n), e = e.sibling; e !== null;)$c(e, t, n), e = e.sibling } function Uc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (Uc(e, t, n), e = e.sibling; e !== null;)Uc(e, t, n), e = e.sibling } var Xe = null, Yt = !1; function Qn(e, t, n) { for (n = n.child; n !== null;)dg(e, t, n), n = n.sibling } function dg(e, t, n) { if (yn && typeof yn.onCommitFiberUnmount == "function") try { yn.onCommitFiberUnmount(Nl, n) } catch { } switch (n.tag) { case 5: it || Ns(n, t); case 6: var r = Xe, s = Yt; Xe = null, Qn(e, t, n), Xe = r, Yt = s, Xe !== null && (Yt ? (e = Xe, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Xe.removeChild(n.stateNode)); break; case 18: Xe !== null && (Yt ? (e = Xe, n = n.stateNode, e.nodeType === 8 ? Nu(e.parentNode, n) : e.nodeType === 1 && Nu(e, n), oi(e)) : Nu(Xe, n.stateNode)); break; case 4: r = Xe, s = Yt, Xe = n.stateNode.containerInfo, Yt = !0, Qn(e, t, n), Xe = r, Yt = s; break; case 0: case 11: case 14: case 15: if (!it && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { s = r = r.next; do { var o = s, i = o.destroy; o = o.tag, i !== void 0 && (o & 2 || o & 4) && Vc(n, t, i), s = s.next } while (s !== r) } Qn(e, t, n); break; case 1: if (!it && (Ns(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Me(n, t, a) } Qn(e, t, n); break; case 21: Qn(e, t, n); break; case 22: n.mode & 1 ? (it = (r = it) || n.memoizedState !== null, Qn(e, t, n), it = r) : Qn(e, t, n); break; default: Qn(e, t, n) } } function Hp(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new eS), t.forEach(function (r) { var s = cS.bind(null, e, r); n.has(r) || (n.add(r), r.then(s, s)) }) } } function Zt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var s = n[r]; try { var o = e, i = t, a = i; e: for (; a !== null;) { switch (a.tag) { case 5: Xe = a.stateNode, Yt = !1; break e; case 3: Xe = a.stateNode.containerInfo, Yt = !0; break e; case 4: Xe = a.stateNode.containerInfo, Yt = !0; break e }a = a.return } if (Xe === null) throw Error(I(160)); dg(o, i, s), Xe = null, Yt = !1; var l = s.alternate; l !== null && (l.return = null), s.return = null } catch (u) { Me(s, t, u) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)fg(t, e), t = t.sibling } function fg(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Zt(t, e), cn(e), r & 4) { try { Qo(3, e, e.return), Ll(3, e) } catch (m) { Me(e, e.return, m) } try { Qo(5, e, e.return) } catch (m) { Me(e, e.return, m) } } break; case 1: Zt(t, e), cn(e), r & 512 && n !== null && Ns(n, n.return); break; case 5: if (Zt(t, e), cn(e), r & 512 && n !== null && Ns(n, n.return), e.flags & 32) { var s = e.stateNode; try { ti(s, "") } catch (m) { Me(e, e.return, m) } } if (r & 4 && (s = e.stateNode, s != null)) { var o = e.memoizedProps, i = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && Mm(s, o), fc(a, i); var u = fc(a, o); for (i = 0; i < l.length; i += 2) { var c = l[i], p = l[i + 1]; c === "style" ? Vm(s, p) : c === "dangerouslySetInnerHTML" ? Dm(s, p) : c === "children" ? ti(s, p) : Cd(s, c, p, u) } switch (a) { case "input": ac(s, o); break; case "textarea": Im(s, o); break; case "select": var h = s._wrapperState.wasMultiple; s._wrapperState.wasMultiple = !!o.multiple; var w = o.value; w != null ? As(s, !!o.multiple, w, !1) : h !== !!o.multiple && (o.defaultValue != null ? As(s, !!o.multiple, o.defaultValue, !0) : As(s, !!o.multiple, o.multiple ? [] : "", !1)) }s[ci] = o } catch (m) { Me(e, e.return, m) } } break; case 6: if (Zt(t, e), cn(e), r & 4) { if (e.stateNode === null) throw Error(I(162)); s = e.stateNode, o = e.memoizedProps; try { s.nodeValue = o } catch (m) { Me(e, e.return, m) } } break; case 3: if (Zt(t, e), cn(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { oi(t.containerInfo) } catch (m) { Me(e, e.return, m) } break; case 4: Zt(t, e), cn(e); break; case 13: Zt(t, e), cn(e), s = e.child, s.flags & 8192 && (o = s.memoizedState !== null, s.stateNode.isHidden = o, !o || s.alternate !== null && s.alternate.memoizedState !== null || (nf = Ve())), r & 4 && Hp(e); break; case 22: if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (it = (u = it) || c, Zt(t, e), it = u) : Zt(t, e), cn(e), r & 8192) { if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (Z = e, c = e.child; c !== null;) { for (p = Z = c; Z !== null;) { switch (h = Z, w = h.child, h.tag) { case 0: case 11: case 14: case 15: Qo(4, h, h.return); break; case 1: Ns(h, h.return); var S = h.stateNode; if (typeof S.componentWillUnmount == "function") { r = h, n = h.return; try { t = r, S.props = t.memoizedProps, S.state = t.memoizedState, S.componentWillUnmount() } catch (m) { Me(r, n, m) } } break; case 5: Ns(h, h.return); break; case 22: if (h.memoizedState !== null) { Kp(p); continue } }w !== null ? (w.return = h, Z = w) : Kp(p) } c = c.sibling } e: for (c = null, p = e; ;) { if (p.tag === 5) { if (c === null) { c = p; try { s = p.stateNode, u ? (o = s.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = p.stateNode, l = p.memoizedProps.style, i = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Fm("display", i)) } catch (m) { Me(e, e.return, m) } } } else if (p.tag === 6) { if (c === null) try { p.stateNode.nodeValue = u ? "" : p.memoizedProps } catch (m) { Me(e, e.return, m) } } else if ((p.tag !== 22 && p.tag !== 23 || p.memoizedState === null || p === e) && p.child !== null) { p.child.return = p, p = p.child; continue } if (p === e) break e; for (; p.sibling === null;) { if (p.return === null || p.return === e) break e; c === p && (c = null), p = p.return } c === p && (c = null), p.sibling.return = p.return, p = p.sibling } } break; case 19: Zt(t, e), cn(e), r & 4 && Hp(e); break; case 21: break; default: Zt(t, e), cn(e) } } function cn(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (cg(n)) { var r = n; break e } n = n.return } throw Error(I(160)) } switch (r.tag) { case 5: var s = r.stateNode; r.flags & 32 && (ti(s, ""), r.flags &= -33); var o = Wp(e); Uc(e, o, s); break; case 3: case 4: var i = r.stateNode.containerInfo, a = Wp(e); $c(e, a, i); break; default: throw Error(I(161)) } } catch (l) { Me(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function nS(e, t, n) { Z = e, pg(e) } function pg(e, t, n) { for (var r = (e.mode & 1) !== 0; Z !== null;) { var s = Z, o = s.child; if (s.tag === 22 && r) { var i = s.memoizedState !== null || ua; if (!i) { var a = s.alternate, l = a !== null && a.memoizedState !== null || it; a = ua; var u = it; if (ua = i, (it = l) && !u) for (Z = s; Z !== null;)i = Z, l = i.child, i.tag === 22 && i.memoizedState !== null ? Qp(s) : l !== null ? (l.return = i, Z = l) : Qp(s); for (; o !== null;)Z = o, pg(o), o = o.sibling; Z = s, ua = a, it = u } Zp(e) } else s.subtreeFlags & 8772 && o !== null ? (o.return = s, Z = o) : Zp(e) } } function Zp(e) { for (; Z !== null;) { var t = Z; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: it || Ll(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !it) if (n === null) r.componentDidMount(); else { var s = t.elementType === t.type ? n.memoizedProps : Qt(t.type, n.memoizedProps); r.componentDidUpdate(s, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && Rp(t, o, r); break; case 3: var i = t.updateQueue; if (i !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }Rp(t, i, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var u = t.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var p = c.dehydrated; p !== null && oi(p) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(I(163)) }it || t.flags & 512 && zc(t) } catch (h) { Me(t, t.return, h) } } if (t === e) { Z = null; break } if (n = t.sibling, n !== null) { n.return = t.return, Z = n; break } Z = t.return } } function Kp(e) { for (; Z !== null;) { var t = Z; if (t === e) { Z = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, Z = n; break } Z = t.return } } function Qp(e) { for (; Z !== null;) { var t = Z; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Ll(4, t) } catch (l) { Me(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var s = t.return; try { r.componentDidMount() } catch (l) { Me(t, s, l) } } var o = t.return; try { zc(t) } catch (l) { Me(t, o, l) } break; case 5: var i = t.return; try { zc(t) } catch (l) { Me(t, i, l) } } } catch (l) { Me(t, t.return, l) } if (t === e) { Z = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, Z = a; break } Z = t.return } } var rS = Math.ceil, ol = Hn.ReactCurrentDispatcher, ef = Hn.ReactCurrentOwner, Bt = Hn.ReactCurrentBatchConfig, pe = 0, Ge = null, Be = null, et = 0, Nt = 0, Ps = Ar(0), Ze = 0, vi = null, Xr = 0, Dl = 0, tf = 0, Go = null, wt = null, nf = 0, no = 1 / 0, Rn = null, il = !1, Bc = null, yr = null, ca = !1, fr = null, al = 0, qo = 0, Wc = null, Ra = -1, Aa = 0; function mt() { return pe & 6 ? Ve() : Ra !== -1 ? Ra : Ra = Ve() } function xr(e) { return e.mode & 1 ? pe & 2 && et !== 0 ? et & -et : z1.transition !== null ? (Aa === 0 && (Aa = Ym()), Aa) : (e = we, e !== 0 || (e = window.event, e = e === void 0 ? 16 : sv(e.type)), e) : 1 } function rn(e, t, n, r) { if (50 < qo) throw qo = 0, Wc = null, Error(I(185)); Di(e, n, r), (!(pe & 2) || e !== Ge) && (e === Ge && (!(pe & 2) && (Dl |= n), Ze === 4 && nr(e, et)), kt(e, r), n === 1 && pe === 0 && !(t.mode & 1) && (no = Ve() + 500, Ol && jr())) } function kt(e, t) { var n = e.callbackNode; zw(e, t); var r = Wa(e, e === Ge ? et : 0); if (r === 0) n !== null && rp(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && rp(n), t === 1) e.tag === 0 ? V1(Gp.bind(null, e)) : Cv(Gp.bind(null, e)), I1(function () { !(pe & 6) && jr() }), n = null; else { switch (Xm(r)) { case 1: n = Nd; break; case 4: n = Gm; break; case 16: n = Ba; break; case 536870912: n = qm; break; default: n = Ba }n = Sg(n, hg.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function hg(e, t) { if (Ra = -1, Aa = 0, pe & 6) throw Error(I(327)); var n = e.callbackNode; if (Ls() && e.callbackNode !== n) return null; var r = Wa(e, e === Ge ? et : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = ll(e, r); else { t = r; var s = pe; pe |= 2; var o = vg(); (Ge !== e || et !== t) && (Rn = null, no = Ve() + 500, Zr(e, t)); do try { iS(); break } catch (a) { mg(e, a) } while (!0); $d(), ol.current = o, pe = s, Be !== null ? t = 0 : (Ge = null, et = 0, t = Ze) } if (t !== 0) { if (t === 2 && (s = gc(e), s !== 0 && (r = s, t = Hc(e, s))), t === 1) throw n = vi, Zr(e, 0), nr(e, r), kt(e, Ve()), n; if (t === 6) nr(e, r); else { if (s = e.current.alternate, !(r & 30) && !sS(s) && (t = ll(e, r), t === 2 && (o = gc(e), o !== 0 && (r = o, t = Hc(e, o))), t === 1)) throw n = vi, Zr(e, 0), nr(e, r), kt(e, Ve()), n; switch (e.finishedWork = s, e.finishedLanes = r, t) { case 0: case 1: throw Error(I(345)); case 2: Dr(e, wt, Rn); break; case 3: if (nr(e, r), (r & 130023424) === r && (t = nf + 500 - Ve(), 10 < t)) { if (Wa(e, 0) !== 0) break; if (s = e.suspendedLanes, (s & r) !== r) { mt(), e.pingedLanes |= e.suspendedLanes & s; break } e.timeoutHandle = bc(Dr.bind(null, e, wt, Rn), t); break } Dr(e, wt, Rn); break; case 4: if (nr(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, s = -1; 0 < r;) { var i = 31 - nn(r); o = 1 << i, i = t[i], i > s && (s = i), r &= ~o } if (r = s, r = Ve() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * rS(r / 1960)) - r, 10 < r) { e.timeoutHandle = bc(Dr.bind(null, e, wt, Rn), r); break } Dr(e, wt, Rn); break; case 5: Dr(e, wt, Rn); break; default: throw Error(I(329)) } } } return kt(e, Ve()), e.callbackNode === n ? hg.bind(null, e) : null } function Hc(e, t) { var n = Go; return e.current.memoizedState.isDehydrated && (Zr(e, t).flags |= 256), e = ll(e, t), e !== 2 && (t = wt, wt = n, t !== null && Zc(t)), e } function Zc(e) { wt === null ? wt = e : wt.push.apply(wt, e) } function sS(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var s = n[r], o = s.getSnapshot; s = s.value; try { if (!on(o(), s)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function nr(e, t) { for (t &= ~tf, t &= ~Dl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - nn(t), r = 1 << n; e[n] = -1, t &= ~r } } function Gp(e) { if (pe & 6) throw Error(I(327)); Ls(); var t = Wa(e, 0); if (!(t & 1)) return kt(e, Ve()), null; var n = ll(e, t); if (e.tag !== 0 && n === 2) { var r = gc(e); r !== 0 && (t = r, n = Hc(e, r)) } if (n === 1) throw n = vi, Zr(e, 0), nr(e, t), kt(e, Ve()), n; if (n === 6) throw Error(I(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Dr(e, wt, Rn), kt(e, Ve()), null } function rf(e, t) { var n = pe; pe |= 1; try { return e(t) } finally { pe = n, pe === 0 && (no = Ve() + 500, Ol && jr()) } } function Jr(e) { fr !== null && fr.tag === 0 && !(pe & 6) && Ls(); var t = pe; pe |= 1; var n = Bt.transition, r = we; try { if (Bt.transition = null, we = 1, e) return e() } finally { we = r, Bt.transition = n, pe = t, !(pe & 6) && jr() } } function sf() { Nt = Ps.current, Te(Ps) } function Zr(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, M1(n)), Be !== null) for (n = Be.return; n !== null;) { var r = n; switch (Fd(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Ga(); break; case 3: eo(), Te(_t), Te(at), Kd(); break; case 5: Zd(r); break; case 4: eo(); break; case 13: Te(Re); break; case 19: Te(Re); break; case 10: Ud(r.type._context); break; case 22: case 23: sf() }n = n.return } if (Ge = e, Be = e = wr(e.current, null), et = Nt = t, Ze = 0, vi = null, tf = Dl = Xr = 0, wt = Go = null, Vr !== null) { for (t = 0; t < Vr.length; t++)if (n = Vr[t], r = n.interleaved, r !== null) { n.interleaved = null; var s = r.next, o = n.pending; if (o !== null) { var i = o.next; o.next = s, r.next = i } n.pending = r } Vr = null } return e } function mg(e, t) { do { var n = Be; try { if ($d(), Ta.current = sl, rl) { for (var r = Ae.memoizedState; r !== null;) { var s = r.queue; s !== null && (s.pending = null), r = r.next } rl = !1 } if (Yr = 0, Qe = He = Ae = null, Ko = !1, pi = 0, ef.current = null, n === null || n.return === null) { Ze = 1, vi = t, Be = null; break } e: { var o = e, i = n.return, a = n, l = t; if (t = et, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, p = c.tag; if (!(c.mode & 1) && (p === 0 || p === 11 || p === 15)) { var h = c.alternate; h ? (c.updateQueue = h.updateQueue, c.memoizedState = h.memoizedState, c.lanes = h.lanes) : (c.updateQueue = null, c.memoizedState = null) } var w = Lp(i); if (w !== null) { w.flags &= -257, Dp(w, i, a, o, t), w.mode & 1 && Ip(o, u, t), t = w, l = u; var S = t.updateQueue; if (S === null) { var m = new Set; m.add(l), t.updateQueue = m } else S.add(l); break e } else { if (!(t & 1)) { Ip(o, u, t), of(); break e } l = Error(I(426)) } } else if (Ne && a.mode & 1) { var x = Lp(i); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), Dp(x, i, a, o, t), Vd(to(l, a)); break e } } o = l = to(l, a), Ze !== 4 && (Ze = 2), Go === null ? Go = [o] : Go.push(o), o = i; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var g = Xv(o, l, t); Pp(o, g); break e; case 1: a = l; var f = o.type, y = o.stateNode; if (!(o.flags & 128) && (typeof f.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (yr === null || !yr.has(y)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var _ = Jv(o, a, t); Pp(o, _); break e } }o = o.return } while (o !== null) } yg(n) } catch (k) { t = k, Be === n && n !== null && (Be = n = n.return); continue } break } while (!0) } function vg() { var e = ol.current; return ol.current = sl, e === null ? sl : e } function of() { (Ze === 0 || Ze === 3 || Ze === 2) && (Ze = 4), Ge === null || !(Xr & 268435455) && !(Dl & 268435455) || nr(Ge, et) } function ll(e, t) { var n = pe; pe |= 2; var r = vg(); (Ge !== e || et !== t) && (Rn = null, Zr(e, t)); do try { oS(); break } catch (s) { mg(e, s) } while (!0); if ($d(), pe = n, ol.current = r, Be !== null) throw Error(I(261)); return Ge = null, et = 0, Ze } function oS() { for (; Be !== null;)gg(Be) } function iS() { for (; Be !== null && !Aw();)gg(Be) } function gg(e) { var t = wg(e.alternate, e, Nt); e.memoizedProps = e.pendingProps, t === null ? yg(e) : Be = t, ef.current = null } function yg(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = J1(n, t), n !== null) { n.flags &= 32767, Be = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Ze = 6, Be = null; return } } else if (n = X1(n, t, Nt), n !== null) { Be = n; return } if (t = t.sibling, t !== null) { Be = t; return } Be = t = e } while (t !== null); Ze === 0 && (Ze = 5) } function Dr(e, t, n) { var r = we, s = Bt.transition; try { Bt.transition = null, we = 1, aS(e, t, n, r) } finally { Bt.transition = s, we = r } return null } function aS(e, t, n, r) { do Ls(); while (fr !== null); if (pe & 6) throw Error(I(327)); n = e.finishedWork; var s = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(I(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if ($w(e, o), e === Ge && (Be = Ge = null, et = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || ca || (ca = !0, Sg(Ba, function () { return Ls(), null })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) { o = Bt.transition, Bt.transition = null; var i = we; we = 1; var a = pe; pe |= 4, ef.current = null, tS(e, n), fg(n, e), T1(Cc), Ha = !!_c, Cc = _c = null, e.current = n, nS(n), jw(), pe = a, we = i, Bt.transition = o } else e.current = n; if (ca && (ca = !1, fr = e, al = s), o = e.pendingLanes, o === 0 && (yr = null), Iw(n.stateNode), kt(e, Ve()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)s = t[n], r(s.value, { componentStack: s.stack, digest: s.digest }); if (il) throw il = !1, e = Bc, Bc = null, e; return al & 1 && e.tag !== 0 && Ls(), o = e.pendingLanes, o & 1 ? e === Wc ? qo++ : (qo = 0, Wc = e) : qo = 0, jr(), null } function Ls() { if (fr !== null) { var e = Xm(al), t = Bt.transition, n = we; try { if (Bt.transition = null, we = 16 > e ? 16 : e, fr === null) var r = !1; else { if (e = fr, fr = null, al = 0, pe & 6) throw Error(I(331)); var s = pe; for (pe |= 4, Z = e.current; Z !== null;) { var o = Z, i = o.child; if (Z.flags & 16) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (Z = u; Z !== null;) { var c = Z; switch (c.tag) { case 0: case 11: case 15: Qo(8, c, o) }var p = c.child; if (p !== null) p.return = c, Z = p; else for (; Z !== null;) { c = Z; var h = c.sibling, w = c.return; if (ug(c), c === u) { Z = null; break } if (h !== null) { h.return = w, Z = h; break } Z = w } } } var S = o.alternate; if (S !== null) { var m = S.child; if (m !== null) { S.child = null; do { var x = m.sibling; m.sibling = null, m = x } while (m !== null) } } Z = o } } if (o.subtreeFlags & 2064 && i !== null) i.return = o, Z = i; else e: for (; Z !== null;) { if (o = Z, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: Qo(9, o, o.return) }var g = o.sibling; if (g !== null) { g.return = o.return, Z = g; break e } Z = o.return } } var f = e.current; for (Z = f; Z !== null;) { i = Z; var y = i.child; if (i.subtreeFlags & 2064 && y !== null) y.return = i, Z = y; else e: for (i = f; Z !== null;) { if (a = Z, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Ll(9, a) } } catch (k) { Me(a, a.return, k) } if (a === i) { Z = null; break e } var _ = a.sibling; if (_ !== null) { _.return = a.return, Z = _; break e } Z = a.return } } if (pe = s, jr(), yn && typeof yn.onPostCommitFiberRoot == "function") try { yn.onPostCommitFiberRoot(Nl, e) } catch { } r = !0 } return r } finally { we = n, Bt.transition = t } } return !1 } function qp(e, t, n) { t = to(n, t), t = Xv(e, t, 1), e = gr(e, t, 1), t = mt(), e !== null && (Di(e, 1, t), kt(e, t)) } function Me(e, t, n) { if (e.tag === 3) qp(e, e, n); else for (; t !== null;) { if (t.tag === 3) { qp(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (yr === null || !yr.has(r))) { e = to(n, e), e = Jv(t, e, 1), t = gr(t, e, 1), e = mt(), t !== null && (Di(t, 1, e), kt(t, e)); break } } t = t.return } } function lS(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = mt(), e.pingedLanes |= e.suspendedLanes & n, Ge === e && (et & n) === n && (Ze === 4 || Ze === 3 && (et & 130023424) === et && 500 > Ve() - nf ? Zr(e, 0) : tf |= n), kt(e, t) } function xg(e, t) { t === 0 && (e.mode & 1 ? (t = ea, ea <<= 1, !(ea & 130023424) && (ea = 4194304)) : t = 1); var n = mt(); e = zn(e, t), e !== null && (Di(e, t, n), kt(e, n)) } function uS(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), xg(e, n) } function cS(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, s = e.memoizedState; s !== null && (n = s.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(I(314)) }r !== null && r.delete(t), xg(e, n) } var wg; wg = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || _t.current) St = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return St = !1, Y1(e, t, n); St = !!(e.flags & 131072) } else St = !1, Ne && t.flags & 1048576 && kv(t, Xa, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Pa(e, t), e = t.pendingProps; var s = Ys(t, at.current); Is(t, n), s = Gd(null, t, r, e, s, n); var o = qd(); return t.flags |= 1, typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ct(r) ? (o = !0, qa(t)) : o = !1, t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, Wd(t), s.updater = Il, t.stateNode = s, s._reactInternals = t, jc(t, r, e, n), t = Ic(null, t, r, !0, o, n)) : (t.tag = 0, Ne && o && Dd(t), pt(null, t, s, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Pa(e, t), e = t.pendingProps, s = r._init, r = s(r._payload), t.type = r, s = t.tag = fS(r), e = Qt(r, e), s) { case 0: t = Mc(null, t, r, e, n); break e; case 1: t = zp(null, t, r, e, n); break e; case 11: t = Fp(null, t, r, e, n); break e; case 14: t = Vp(null, t, r, Qt(r.type, e), n); break e }throw Error(I(306, r, "")) } return t; case 0: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Qt(r, s), Mc(e, t, r, s, n); case 1: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Qt(r, s), zp(e, t, r, s, n); case 3: e: { if (rg(t), e === null) throw Error(I(387)); r = t.pendingProps, o = t.memoizedState, s = o.element, Rv(e, t), tl(t, r, null, n); var i = t.memoizedState; if (r = i.element, o.isDehydrated) if (o = { element: r, isDehydrated: !1, cache: i.cache, pendingSuspenseBoundaries: i.pendingSuspenseBoundaries, transitions: i.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) { s = to(Error(I(423)), t), t = $p(e, t, r, n, s); break e } else if (r !== s) { s = to(Error(I(424)), t), t = $p(e, t, r, n, s); break e } else for (At = vr(t.stateNode.containerInfo.firstChild), jt = t, Ne = !0, Xt = null, n = Nv(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Xs(), r === s) { t = $n(e, t, n); break e } pt(e, t, r, n) } t = t.child } return t; case 5: return Av(t), e === null && Pc(t), r = t.type, s = t.pendingProps, o = e !== null ? e.memoizedProps : null, i = s.children, kc(r, s) ? i = null : o !== null && kc(r, o) && (t.flags |= 32), ng(e, t), pt(e, t, i, n), t.child; case 6: return e === null && Pc(t), null; case 13: return sg(e, t, n); case 4: return Hd(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Js(t, null, r, n) : pt(e, t, r, n), t.child; case 11: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Qt(r, s), Fp(e, t, r, s, n); case 7: return pt(e, t, t.pendingProps, n), t.child; case 8: return pt(e, t, t.pendingProps.children, n), t.child; case 12: return pt(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, s = t.pendingProps, o = t.memoizedProps, i = s.value, ke(Ja, r._currentValue), r._currentValue = i, o !== null) if (on(o.value, i)) { if (o.children === s.children && !_t.current) { t = $n(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { i = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = Ln(-1, n & -n), l.tag = 2; var u = o.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), Rc(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) i = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (i = o.return, i === null) throw Error(I(341)); i.lanes |= n, a = i.alternate, a !== null && (a.lanes |= n), Rc(i, n, t), i = o.sibling } else i = o.child; if (i !== null) i.return = o; else for (i = o; i !== null;) { if (i === t) { i = null; break } if (o = i.sibling, o !== null) { o.return = i.return, i = o; break } i = i.return } o = i } pt(e, t, s.children, n), t = t.child } return t; case 9: return s = t.type, r = t.pendingProps.children, Is(t, n), s = Wt(s), r = r(s), t.flags |= 1, pt(e, t, r, n), t.child; case 14: return r = t.type, s = Qt(r, t.pendingProps), s = Qt(r.type, s), Vp(e, t, r, s, n); case 15: return eg(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : Qt(r, s), Pa(e, t), t.tag = 1, Ct(r) ? (e = !0, qa(t)) : e = !1, Is(t, n), Yv(t, r, s), jc(t, r, s, n), Ic(null, t, r, !0, e, n); case 19: return og(e, t, n); case 22: return tg(e, t, n) }throw Error(I(156, t.tag)) }; function Sg(e, t) { return Qm(e, t) } function dS(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ut(e, t, n, r) { return new dS(e, t, n, r) } function af(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function fS(e) { if (typeof e == "function") return af(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === bd) return 11; if (e === Ed) return 14 } return 2 } function wr(e, t) { var n = e.alternate; return n === null ? (n = Ut(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function ja(e, t, n, r, s, o) { var i = 2; if (r = e, typeof e == "function") af(e) && (i = 1); else if (typeof e == "string") i = 5; else e: switch (e) { case xs: return Kr(n.children, s, o, t); case kd: i = 8, s |= 8; break; case nc: return e = Ut(12, n, t, s | 2), e.elementType = nc, e.lanes = o, e; case rc: return e = Ut(13, n, t, s), e.elementType = rc, e.lanes = o, e; case sc: return e = Ut(19, n, t, s), e.elementType = sc, e.lanes = o, e; case Am: return Fl(n, s, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Pm: i = 10; break e; case Rm: i = 9; break e; case bd: i = 11; break e; case Ed: i = 14; break e; case Jn: i = 16, r = null; break e }throw Error(I(130, e == null ? e : typeof e, "")) }return t = Ut(i, n, t, s), t.elementType = e, t.type = r, t.lanes = o, t } function Kr(e, t, n, r) { return e = Ut(7, e, r, t), e.lanes = n, e } function Fl(e, t, n, r) { return e = Ut(22, e, r, t), e.elementType = Am, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Lu(e, t, n) { return e = Ut(6, e, null, t), e.lanes = n, e } function Du(e, t, n) { return t = Ut(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function pS(e, t, n, r, s) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gu(0), this.expirationTimes = gu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gu(0), this.identifierPrefix = r, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null } function lf(e, t, n, r, s, o, i, a, l) { return e = new pS(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = Ut(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Wd(o), e } function hS(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: ys, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function _g(e) { if (!e) return _r; e = e._reactInternals; e: { if (as(e) !== e || e.tag !== 1) throw Error(I(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ct(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(I(171)) } if (e.tag === 1) { var n = e.type; if (Ct(n)) return _v(e, n, t) } return t } function Cg(e, t, n, r, s, o, i, a, l) { return e = lf(n, r, !0, e, s, o, i, a, l), e.context = _g(null), n = e.current, r = mt(), s = xr(n), o = Ln(r, s), o.callback = t ?? null, gr(n, o, s), e.current.lanes = s, Di(e, s, r), kt(e, r), e } function Vl(e, t, n, r) { var s = t.current, o = mt(), i = xr(s); return n = _g(n), t.context === null ? t.context = n : t.pendingContext = n, t = Ln(o, i), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = gr(s, t, i), e !== null && (rn(e, s, i, o), Ea(e, s, i)), i } function ul(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Yp(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function uf(e, t) { Yp(e, t), (e = e.alternate) && Yp(e, t) } function mS() { return null } var kg = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function cf(e) { this._internalRoot = e } zl.prototype.render = cf.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(I(409)); Vl(e, t, null, null) }; zl.prototype.unmount = cf.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Jr(function () { Vl(null, e, null, null) }), t[Vn] = null } }; function zl(e) { this._internalRoot = e } zl.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = tv(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < tr.length && t !== 0 && t < tr[n].priority; n++); tr.splice(n, 0, e), n === 0 && rv(e) } }; function df(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function $l(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Xp() { } function vS(e, t, n, r, s) { if (s) { if (typeof r == "function") { var o = r; r = function () { var u = ul(i); o.call(u) } } var i = Cg(t, r, e, 0, null, !1, !1, "", Xp); return e._reactRootContainer = i, e[Vn] = i.current, li(e.nodeType === 8 ? e.parentNode : e), Jr(), i } for (; s = e.lastChild;)e.removeChild(s); if (typeof r == "function") { var a = r; r = function () { var u = ul(l); a.call(u) } } var l = lf(e, 0, !1, null, null, !1, !1, "", Xp); return e._reactRootContainer = l, e[Vn] = l.current, li(e.nodeType === 8 ? e.parentNode : e), Jr(function () { Vl(t, l, n, r) }), l } function Ul(e, t, n, r, s) { var o = n._reactRootContainer; if (o) { var i = o; if (typeof s == "function") { var a = s; s = function () { var l = ul(i); a.call(l) } } Vl(t, i, e, s) } else i = vS(n, t, e, s, r); return ul(i) } Jm = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Oo(t.pendingLanes); n !== 0 && (Pd(t, n | 1), kt(t, Ve()), !(pe & 6) && (no = Ve() + 500, jr())) } break; case 13: Jr(function () { var r = zn(e, 1); if (r !== null) { var s = mt(); rn(r, e, 1, s) } }), uf(e, 1) } }; Rd = function (e) { if (e.tag === 13) { var t = zn(e, 134217728); if (t !== null) { var n = mt(); rn(t, e, 134217728, n) } uf(e, 134217728) } }; ev = function (e) { if (e.tag === 13) { var t = xr(e), n = zn(e, t); if (n !== null) { var r = mt(); rn(n, e, t, r) } uf(e, t) } }; tv = function () { return we }; nv = function (e, t) { var n = we; try { return we = e, t() } finally { we = n } }; hc = function (e, t, n) { switch (t) { case "input": if (ac(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var s = jl(r); if (!s) throw Error(I(90)); Om(r), ac(r, s) } } } break; case "textarea": Im(e, n); break; case "select": t = n.value, t != null && As(e, !!n.multiple, t, !1) } }; Um = rf; Bm = Jr; var gS = { usingClientEntryPoint: !1, Events: [Vi, Cs, jl, zm, $m, rf] }, bo = { findFiberByHostInstance: Fr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, yS = { bundleType: bo.bundleType, version: bo.version, rendererPackageName: bo.rendererPackageName, rendererConfig: bo.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Hn.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Zm(e), e === null ? null : e.stateNode }, findFiberByHostInstance: bo.findFiberByHostInstance || mS, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var da = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!da.isDisabled && da.supportsFiber) try { Nl = da.inject(yS), yn = da } catch { } } Dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gS; Dt.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!df(t)) throw Error(I(200)); return hS(e, t, null, n) }; Dt.createRoot = function (e, t) { if (!df(e)) throw Error(I(299)); var n = !1, r = "", s = kg; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = lf(e, 1, !1, null, null, n, !1, r, s), e[Vn] = t.current, li(e.nodeType === 8 ? e.parentNode : e), new cf(t) }; Dt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(I(188)) : (e = Object.keys(e).join(","), Error(I(268, e))); return e = Zm(t), e = e === null ? null : e.stateNode, e }; Dt.flushSync = function (e) { return Jr(e) }; Dt.hydrate = function (e, t, n) { if (!$l(t)) throw Error(I(200)); return Ul(null, e, t, !0, n) }; Dt.hydrateRoot = function (e, t, n) { if (!df(e)) throw Error(I(405)); var r = n != null && n.hydratedSources || null, s = !1, o = "", i = kg; if (n != null && (n.unstable_strictMode === !0 && (s = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (i = n.onRecoverableError)), t = Cg(t, null, e, 1, n ?? null, s, !1, o, i), e[Vn] = t.current, li(e), r) for (e = 0; e < r.length; e++)n = r[e], s = n._getVersion, s = s(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, s] : t.mutableSourceEagerHydrationData.push(n, s); return new zl(t) }; Dt.render = function (e, t, n) { if (!$l(t)) throw Error(I(200)); return Ul(null, e, t, !1, n) }; Dt.unmountComponentAtNode = function (e) { if (!$l(e)) throw Error(I(40)); return e._reactRootContainer ? (Jr(function () { Ul(null, null, e, !1, function () { e._reactRootContainer = null, e[Vn] = null }) }), !0) : !1 }; Dt.unstable_batchedUpdates = rf; Dt.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!$l(n)) throw Error(I(200)); if (e == null || e._reactInternals === void 0) throw Error(I(38)); return Ul(e, t, n, !1, r) }; Dt.version = "18.3.1-next-f1338f8080-20240426"; function bg() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(bg) } catch (e) { console.error(e) } } bg(), bm.exports = Dt; var ls = bm.exports; const xS = fm(ls); var Eg, Jp = ls; Eg = Jp.createRoot, Jp.hydrateRoot; function wS(e, t) { if (e instanceof RegExp) return { keys: !1, pattern: e }; var n, r, s, o, i = [], a = "", l = e.split("/"); for (l[0] || l.shift(); s = l.shift();)n = s[0], n === "*" ? (i.push(n), a += s[1] === "?" ? "(?:/(.*))?" : "/(.*)") : n === ":" ? (r = s.indexOf("?", 1), o = s.indexOf(".", 1), i.push(s.substring(1, ~r ? r : ~o ? o : s.length)), a += ~r && !~o ? "(?:/([^/]+?))?" : "/([^/]+?)", ~o && (a += (~r ? "?" : "") + "\\" + s.substring(o))) : a += "/" + s; return { keys: i, pattern: new RegExp("^" + a + (t ? "(?=$|/)" : "/?$"), "i") } } var Tg = { exports: {} }, Ng = {};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ro = v; function SS(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var _S = typeof Object.is == "function" ? Object.is : SS, CS = ro.useState, kS = ro.useEffect, bS = ro.useLayoutEffect, ES = ro.useDebugValue; function TS(e, t) { var n = t(), r = CS({ inst: { value: n, getSnapshot: t } }), s = r[0].inst, o = r[1]; return bS(function () { s.value = n, s.getSnapshot = t, Fu(s) && o({ inst: s }) }, [e, n, t]), kS(function () { return Fu(s) && o({ inst: s }), e(function () { Fu(s) && o({ inst: s }) }) }, [e]), ES(n), n } function Fu(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !_S(e, n) } catch { return !0 } } function NS(e, t) { return t() } var PS = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? NS : TS; Ng.useSyncExternalStore = ro.useSyncExternalStore !== void 0 ? ro.useSyncExternalStore : PS; Tg.exports = Ng; var RS = Tg.exports; const AS = Cm.useInsertionEffect, jS = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", OS = jS ? v.useLayoutEffect : v.useEffect, MS = AS || OS, Pg = e => { const t = v.useRef([e, (...n) => t[0](...n)]).current; return MS(() => { t[0] = e }), t[1] }, IS = "popstate", ff = "pushState", pf = "replaceState", LS = "hashchange", eh = [IS, ff, pf, LS], DS = e => { for (const t of eh) addEventListener(t, e); return () => { for (const t of eh) removeEventListener(t, e) } }, Rg = (e, t) => RS.useSyncExternalStore(DS, e, t), FS = () => location.search, VS = ({ ssrSearch: e = "" } = {}) => Rg(FS, () => e), th = () => location.pathname, zS = ({ ssrPath: e } = {}) => Rg(th, e ? () => e : th), $S = (e, { replace: t = !1, state: n = null } = {}) => history[t ? pf : ff](n, "", e), US = (e = {}) => [zS(e), $S], nh = Symbol.for("wouter_v3"); if (typeof history < "u" && typeof window[nh] > "u") { for (const e of [ff, pf]) { const t = history[e]; history[e] = function () { const n = t.apply(this, arguments), r = new Event(e); return r.arguments = arguments, dispatchEvent(r), n } } Object.defineProperty(window, nh, { value: !0 }) } const BS = (e, t) => t.toLowerCase().indexOf(e.toLowerCase()) ? "~" + t : t.slice(e.length) || "/", Ag = (e = "") => e === "/" ? "" : e, WS = (e, t) => e[0] === "~" ? e.slice(1) : Ag(t) + e, HS = (e = "", t) => BS(rh(Ag(e)), rh(t)), rh = e => { try { return decodeURI(e) } catch { return e } }, jg = { hook: US, searchHook: VS, parser: wS, base: "", ssrPath: void 0, ssrSearch: void 0, hrefs: e => e }, Og = v.createContext(jg), Bl = () => v.useContext(Og), Mg = {}, Ig = v.createContext(Mg), ZS = () => v.useContext(Ig), hf = e => { const [t, n] = e.hook(e); return [HS(e.base, t), Pg((r, s) => n(WS(r, e.base), s))] }, Lg = (e, t, n, r) => { const { pattern: s, keys: o } = t instanceof RegExp ? { keys: !1, pattern: t } : e(t || "*", r), i = s.exec(n) || [], [a, ...l] = i; return a !== void 0 ? [!0, (() => { const u = o !== !1 ? Object.fromEntries(o.map((p, h) => [p, l[h]])) : i.groups; let c = { ...l }; return u && Object.assign(c, u), c })(), ...r ? [a] : []] : [!1, null] }, KS = ({ children: e, ...t }) => { var c, p; const n = Bl(), r = t.hook ? jg : n; let s = r; const [o, i] = ((c = t.ssrPath) == null ? void 0 : c.split("?")) ?? []; i && (t.ssrSearch = i, t.ssrPath = o), t.hrefs = t.hrefs ?? ((p = t.hook) == null ? void 0 : p.hrefs); let a = v.useRef({}), l = a.current, u = l; for (let h in r) { const w = h === "base" ? r[h] + (t[h] || "") : t[h] || r[h]; l === u && w !== u[h] && (a.current = u = { ...u }), u[h] = w, w !== r[h] && (s = u) } return v.createElement(Og.Provider, { value: s, children: e }) }, sh = ({ children: e, component: t }, n) => t ? v.createElement(t, { params: n }) : typeof e == "function" ? e(n) : e, QS = e => { let t = v.useRef(Mg), n = t.current; for (const r in e) e[r] !== n[r] && (n = e); return Object.keys(e).length === 0 && (n = e), t.current = n }, oh = ({ path: e, nest: t, match: n, ...r }) => { const s = Bl(), [o] = hf(s), [i, a, l] = n ?? Lg(s.parser, e, o, t), u = QS({ ...ZS(), ...a }); if (!i) return null; const c = l ? v.createElement(KS, { base: l }, sh(r, u)) : sh(r, u); return v.createElement(Ig.Provider, { value: u, children: c }) }; v.forwardRef((e, t) => { const n = Bl(), [r, s] = hf(n), { to: o = "", href: i = o, onClick: a, asChild: l, children: u, className: c, replace: p, state: h, ...w } = e, S = Pg(x => { x.ctrlKey || x.metaKey || x.altKey || x.shiftKey || x.button !== 0 || (a == null || a(x), x.defaultPrevented || (x.preventDefault(), s(i, e))) }), m = n.hrefs(i[0] === "~" ? i.slice(1) : n.base + i, n); return l && v.isValidElement(u) ? v.cloneElement(u, { onClick: S, href: m }) : v.createElement("a", { ...w, onClick: S, href: m, className: c != null && c.call ? c(r === i) : c, children: u, ref: t }) }); const Dg = e => Array.isArray(e) ? e.flatMap(t => Dg(t && t.type === v.Fragment ? t.props.children : t)) : [e], GS = ({ children: e, location: t }) => { const n = Bl(), [r] = hf(n); for (const s of Dg(e)) { let o = 0; if (v.isValidElement(s) && (o = Lg(n.parser, s.props.path, t || r, s.props.nest))[0]) return v.cloneElement(s, { match: o }) } return null }; var $i = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(e) { return this.listeners.add(e), this.onSubscribe(), () => { this.listeners.delete(e), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, Wl = typeof window > "u" || "Deno" in globalThis; function Gt() { } function qS(e, t) { return typeof e == "function" ? e(t) : e } function YS(e) { return typeof e == "number" && e >= 0 && e !== 1 / 0 } function XS(e, t) { return Math.max(e + (t || 0) - Date.now(), 0) } function ih(e, t) { return typeof e == "function" ? e(t) : e } function JS(e, t) { return typeof e == "function" ? e(t) : e } function ah(e, t) { const { type: n = "all", exact: r, fetchStatus: s, predicate: o, queryKey: i, stale: a } = e; if (i) { if (r) { if (t.queryHash !== mf(i, t.options)) return !1 } else if (!gi(t.queryKey, i)) return !1 } if (n !== "all") { const l = t.isActive(); if (n === "active" && !l || n === "inactive" && l) return !1 } return !(typeof a == "boolean" && t.isStale() !== a || s && s !== t.state.fetchStatus || o && !o(t)) } function lh(e, t) { const { exact: n, status: r, predicate: s, mutationKey: o } = e; if (o) { if (!t.options.mutationKey) return !1; if (n) { if (es(t.options.mutationKey) !== es(o)) return !1 } else if (!gi(t.options.mutationKey, o)) return !1 } return !(r && t.state.status !== r || s && !s(t)) } function mf(e, t) { return ((t == null ? void 0 : t.queryKeyHashFn) || es)(e) } function es(e) { return JSON.stringify(e, (t, n) => Kc(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n) } function gi(e, t) { return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(n => !gi(e[n], t[n])) : !1 } function Fg(e, t) { if (e === t) return e; const n = uh(e) && uh(t); if (n || Kc(e) && Kc(t)) { const r = n ? e : Object.keys(e), s = r.length, o = n ? t : Object.keys(t), i = o.length, a = n ? [] : {}; let l = 0; for (let u = 0; u < i; u++) { const c = n ? u : o[u]; (!n && r.includes(c) || n) && e[c] === void 0 && t[c] === void 0 ? (a[c] = void 0, l++) : (a[c] = Fg(e[c], t[c]), a[c] === e[c] && e[c] !== void 0 && l++) } return s === i && l === s ? e : a } return t } function e_(e, t) { if (!t || Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (e[n] !== t[n]) return !1; return !0 } function uh(e) { return Array.isArray(e) && e.length === Object.keys(e).length } function Kc(e) { if (!ch(e)) return !1; const t = e.constructor; if (t === void 0) return !0; const n = t.prototype; return !(!ch(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype) } function ch(e) { return Object.prototype.toString.call(e) === "[object Object]" } function t_(e) { return new Promise(t => { setTimeout(t, e) }) } function n_(e, t, n) { return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? Fg(e, t) : t } function r_(e, t, n = 0) { const r = [...e, t]; return n && r.length > n ? r.slice(1) : r } function s_(e, t, n = 0) { const r = [t, ...e]; return n && r.length > n ? r.slice(0, -1) : r } var vf = Symbol(); function Vg(e, t) { return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === vf ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn } var Ur, sr, $s, rm, o_ = (rm = class extends $i { constructor() { super(); de(this, Ur); de(this, sr); de(this, $s); se(this, $s, t => { if (!Wl && window.addEventListener) { const n = () => t(); return window.addEventListener("visibilitychange", n, !1), () => { window.removeEventListener("visibilitychange", n) } } }) } onSubscribe() { N(this, sr) || this.setEventListener(N(this, $s)) } onUnsubscribe() { var t; this.hasListeners() || ((t = N(this, sr)) == null || t.call(this), se(this, sr, void 0)) } setEventListener(t) { var n; se(this, $s, t), (n = N(this, sr)) == null || n.call(this), se(this, sr, t(r => { typeof r == "boolean" ? this.setFocused(r) : this.onFocus() })) } setFocused(t) { N(this, Ur) !== t && (se(this, Ur, t), this.onFocus()) } onFocus() { const t = this.isFocused(); this.listeners.forEach(n => { n(t) }) } isFocused() { var t; return typeof N(this, Ur) == "boolean" ? N(this, Ur) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden" } }, Ur = new WeakMap, sr = new WeakMap, $s = new WeakMap, rm), zg = new o_, Us, or, Bs, sm, i_ = (sm = class extends $i { constructor() { super(); de(this, Us, !0); de(this, or); de(this, Bs); se(this, Bs, t => { if (!Wl && window.addEventListener) { const n = () => t(!0), r = () => t(!1); return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => { window.removeEventListener("online", n), window.removeEventListener("offline", r) } } }) } onSubscribe() { N(this, or) || this.setEventListener(N(this, Bs)) } onUnsubscribe() { var t; this.hasListeners() || ((t = N(this, or)) == null || t.call(this), se(this, or, void 0)) } setEventListener(t) { var n; se(this, Bs, t), (n = N(this, or)) == null || n.call(this), se(this, or, t(this.setOnline.bind(this))) } setOnline(t) { N(this, Us) !== t && (se(this, Us, t), this.listeners.forEach(r => { r(t) })) } isOnline() { return N(this, Us) } }, Us = new WeakMap, or = new WeakMap, Bs = new WeakMap, sm), cl = new i_; function a_() { let e, t; const n = new Promise((s, o) => { e = s, t = o }); n.status = "pending", n.catch(() => { }); function r(s) { Object.assign(n, s), delete n.resolve, delete n.reject } return n.resolve = s => { r({ status: "fulfilled", value: s }), e(s) }, n.reject = s => { r({ status: "rejected", reason: s }), t(s) }, n } function l_(e) { return Math.min(1e3 * 2 ** e, 3e4) } function $g(e) { return (e ?? "online") === "online" ? cl.isOnline() : !0 } var Ug = class extends Error { constructor(e) { super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent } }; function Vu(e) { return e instanceof Ug } function Bg(e) { let t = !1, n = 0, r = !1, s; const o = a_(), i = m => { var x; r || (h(new Ug(m)), (x = e.abort) == null || x.call(e)) }, a = () => { t = !0 }, l = () => { t = !1 }, u = () => zg.isFocused() && (e.networkMode === "always" || cl.isOnline()) && e.canRun(), c = () => $g(e.networkMode) && e.canRun(), p = m => { var x; r || (r = !0, (x = e.onSuccess) == null || x.call(e, m), s == null || s(), o.resolve(m)) }, h = m => { var x; r || (r = !0, (x = e.onError) == null || x.call(e, m), s == null || s(), o.reject(m)) }, w = () => new Promise(m => { var x; s = g => { (r || u()) && m(g) }, (x = e.onPause) == null || x.call(e) }).then(() => { var m; s = void 0, r || (m = e.onContinue) == null || m.call(e) }), S = () => { if (r) return; let m; const x = n === 0 ? e.initialPromise : void 0; try { m = x ?? e.fn() } catch (g) { m = Promise.reject(g) } Promise.resolve(m).then(p).catch(g => { var T; if (r) return; const f = e.retry ?? (Wl ? 0 : 3), y = e.retryDelay ?? l_, _ = typeof y == "function" ? y(n, g) : y, k = f === !0 || typeof f == "number" && n < f || typeof f == "function" && f(n, g); if (t || !k) { h(g); return } n++, (T = e.onFail) == null || T.call(e, n, g), t_(_).then(() => u() ? void 0 : w()).then(() => { t ? h(g) : S() }) }) }; return { promise: o, cancel: i, continue: () => (s == null || s(), o), cancelRetry: a, continueRetry: l, canStart: c, start: () => (c() ? S() : w().then(S), o) } } function u_() { let e = [], t = 0, n = a => { a() }, r = a => { a() }, s = a => setTimeout(a, 0); const o = a => { t ? e.push(a) : s(() => { n(a) }) }, i = () => { const a = e; e = [], a.length && s(() => { r(() => { a.forEach(l => { n(l) }) }) }) }; return { batch: a => { let l; t++; try { l = a() } finally { t--, t || i() } return l }, batchCalls: a => (...l) => { o(() => { a(...l) }) }, schedule: o, setNotifyFunction: a => { n = a }, setBatchNotifyFunction: a => { r = a }, setScheduler: a => { s = a } } } var Je = u_(), Br, om, Wg = (om = class { constructor() { de(this, Br) } destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), YS(this.gcTime) && se(this, Br, setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(e) { this.gcTime = Math.max(this.gcTime || 0, e ?? (Wl ? 1 / 0 : 5 * 60 * 1e3)) } clearGcTimeout() { N(this, Br) && (clearTimeout(N(this, Br)), se(this, Br, void 0)) } }, Br = new WeakMap, om), Ws, Hs, Vt, ot, Mi, Wr, qt, Nn, im, c_ = (im = class extends Wg { constructor(t) { super(); de(this, qt); de(this, Ws); de(this, Hs); de(this, Vt); de(this, ot); de(this, Mi); de(this, Wr); se(this, Wr, !1), se(this, Mi, t.defaultOptions), this.setOptions(t.options), this.observers = [], se(this, Vt, t.cache), this.queryKey = t.queryKey, this.queryHash = t.queryHash, se(this, Ws, f_(this.options)), this.state = t.state ?? N(this, Ws), this.scheduleGc() } get meta() { return this.options.meta } get promise() { var t; return (t = N(this, ot)) == null ? void 0 : t.promise } setOptions(t) { this.options = { ...N(this, Mi), ...t }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && N(this, Vt).remove(this) } setData(t, n) { const r = n_(this.state.data, t, this.options); return De(this, qt, Nn).call(this, { data: r, type: "success", dataUpdatedAt: n == null ? void 0 : n.updatedAt, manual: n == null ? void 0 : n.manual }), r } setState(t, n) { De(this, qt, Nn).call(this, { type: "setState", state: t, setStateOptions: n }) } cancel(t) { var r, s; const n = (r = N(this, ot)) == null ? void 0 : r.promise; return (s = N(this, ot)) == null || s.cancel(t), n ? n.then(Gt).catch(Gt) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(N(this, Ws)) } isActive() { return this.observers.some(t => JS(t.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === vf || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStale() { return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 } isStaleByTime(t = 0) { return this.state.isInvalidated || this.state.data === void 0 || !XS(this.state.dataUpdatedAt, t) } onFocus() { var n; const t = this.observers.find(r => r.shouldFetchOnWindowFocus()); t == null || t.refetch({ cancelRefetch: !1 }), (n = N(this, ot)) == null || n.continue() } onOnline() { var n; const t = this.observers.find(r => r.shouldFetchOnReconnect()); t == null || t.refetch({ cancelRefetch: !1 }), (n = N(this, ot)) == null || n.continue() } addObserver(t) { this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), N(this, Vt).notify({ type: "observerAdded", query: this, observer: t })) } removeObserver(t) { this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (N(this, ot) && (N(this, Wr) ? N(this, ot).cancel({ revert: !0 }) : N(this, ot).cancelRetry()), this.scheduleGc()), N(this, Vt).notify({ type: "observerRemoved", query: this, observer: t })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || De(this, qt, Nn).call(this, { type: "invalidate" }) } fetch(t, n) { var l, u, c; if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({ silent: !0 }); else if (N(this, ot)) return N(this, ot).continueRetry(), N(this, ot).promise } if (t && this.setOptions(t), !this.options.queryFn) { const p = this.observers.find(h => h.options.queryFn); p && this.setOptions(p.options) } const r = new AbortController, s = p => { Object.defineProperty(p, "signal", { enumerable: !0, get: () => (se(this, Wr, !0), r.signal) }) }, o = () => { const p = Vg(this.options, n), h = { queryKey: this.queryKey, meta: this.meta }; return s(h), se(this, Wr, !1), this.options.persister ? this.options.persister(p, h, this) : p(h) }, i = { fetchOptions: n, options: this.options, queryKey: this.queryKey, state: this.state, fetchFn: o }; s(i), (l = this.options.behavior) == null || l.onFetch(i, this), se(this, Hs, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = i.fetchOptions) == null ? void 0 : u.meta)) && De(this, qt, Nn).call(this, { type: "fetch", meta: (c = i.fetchOptions) == null ? void 0 : c.meta }); const a = p => { var h, w, S, m; Vu(p) && p.silent || De(this, qt, Nn).call(this, { type: "error", error: p }), Vu(p) || ((w = (h = N(this, Vt).config).onError) == null || w.call(h, p, this), (m = (S = N(this, Vt).config).onSettled) == null || m.call(S, this.state.data, p, this)), this.scheduleGc() }; return se(this, ot, Bg({ initialPromise: n == null ? void 0 : n.initialPromise, fn: i.fetchFn, abort: r.abort.bind(r), onSuccess: p => { var h, w, S, m; if (p === void 0) { a(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(p) } catch (x) { a(x); return } (w = (h = N(this, Vt).config).onSuccess) == null || w.call(h, p, this), (m = (S = N(this, Vt).config).onSettled) == null || m.call(S, p, this.state.error, this), this.scheduleGc() }, onError: a, onFail: (p, h) => { De(this, qt, Nn).call(this, { type: "failed", failureCount: p, error: h }) }, onPause: () => { De(this, qt, Nn).call(this, { type: "pause" }) }, onContinue: () => { De(this, qt, Nn).call(this, { type: "continue" }) }, retry: i.options.retry, retryDelay: i.options.retryDelay, networkMode: i.options.networkMode, canRun: () => !0 })), N(this, ot).start() } }, Ws = new WeakMap, Hs = new WeakMap, Vt = new WeakMap, ot = new WeakMap, Mi = new WeakMap, Wr = new WeakMap, qt = new WeakSet, Nn = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }; case "pause": return { ...r, fetchStatus: "paused" }; case "continue": return { ...r, fetchStatus: "fetching" }; case "fetch": return { ...r, ...d_(r.data, this.options), fetchMeta: t.meta ?? null }; case "success": return { ...r, data: t.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const s = t.error; return Vu(s) && s.revert && N(this, Hs) ? { ...N(this, Hs), fetchStatus: "idle" } : { ...r, error: s, errorUpdateCount: r.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: r.fetchFailureCount + 1, fetchFailureReason: s, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...r, isInvalidated: !0 }; case "setState": return { ...r, ...t.state } } }; this.state = n(this.state), Je.batch(() => { this.observers.forEach(r => { r.onQueryUpdate() }), N(this, Vt).notify({ query: this, type: "updated", action: t }) }) }, im); function d_(e, t) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: $g(t.networkMode) ? "fetching" : "paused", ...e === void 0 && { error: null, status: "pending" } } } function f_(e) { const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0; return { data: t, dataUpdateCount: 0, dataUpdatedAt: n ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: n ? "success" : "pending", fetchStatus: "idle" } } var fn, am, p_ = (am = class extends $i { constructor(t = {}) { super(); de(this, fn); this.config = t, se(this, fn, new Map) } build(t, n, r) { const s = n.queryKey, o = n.queryHash ?? mf(s, n); let i = this.get(o); return i || (i = new c_({ cache: this, queryKey: s, queryHash: o, options: t.defaultQueryOptions(n), state: r, defaultOptions: t.getQueryDefaults(s) }), this.add(i)), i } add(t) { N(this, fn).has(t.queryHash) || (N(this, fn).set(t.queryHash, t), this.notify({ type: "added", query: t })) } remove(t) { const n = N(this, fn).get(t.queryHash); n && (t.destroy(), n === t && N(this, fn).delete(t.queryHash), this.notify({ type: "removed", query: t })) } clear() { Je.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } get(t) { return N(this, fn).get(t) } getAll() { return [...N(this, fn).values()] } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => ah(n, r)) } findAll(t = {}) { const n = this.getAll(); return Object.keys(t).length > 0 ? n.filter(r => ah(t, r)) : n } notify(t) { Je.batch(() => { this.listeners.forEach(n => { n(t) }) }) } onFocus() { Je.batch(() => { this.getAll().forEach(t => { t.onFocus() }) }) } onOnline() { Je.batch(() => { this.getAll().forEach(t => { t.onOnline() }) }) } }, fn = new WeakMap, am), pn, dt, Hr, hn, Yn, lm, h_ = (lm = class extends Wg { constructor(t) { super(); de(this, hn); de(this, pn); de(this, dt); de(this, Hr); this.mutationId = t.mutationId, se(this, dt, t.mutationCache), se(this, pn, []), this.state = t.state || Hg(), this.setOptions(t.options), this.scheduleGc() } setOptions(t) { this.options = t, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(t) { N(this, pn).includes(t) || (N(this, pn).push(t), this.clearGcTimeout(), N(this, dt).notify({ type: "observerAdded", mutation: this, observer: t })) } removeObserver(t) { se(this, pn, N(this, pn).filter(n => n !== t)), this.scheduleGc(), N(this, dt).notify({ type: "observerRemoved", mutation: this, observer: t }) } optionalRemove() { N(this, pn).length || (this.state.status === "pending" ? this.scheduleGc() : N(this, dt).remove(this)) } continue() { var t; return ((t = N(this, Hr)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables) } async execute(t) { var s, o, i, a, l, u, c, p, h, w, S, m, x, g, f, y, _, k, T, b; se(this, Hr, Bg({ fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), onFail: (R, F) => { De(this, hn, Yn).call(this, { type: "failed", failureCount: R, error: F }) }, onPause: () => { De(this, hn, Yn).call(this, { type: "pause" }) }, onContinue: () => { De(this, hn, Yn).call(this, { type: "continue" }) }, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => N(this, dt).canRun(this) })); const n = this.state.status === "pending", r = !N(this, Hr).canStart(); try { if (!n) { De(this, hn, Yn).call(this, { type: "pending", variables: t, isPaused: r }), await ((o = (s = N(this, dt).config).onMutate) == null ? void 0 : o.call(s, t, this)); const F = await ((a = (i = this.options).onMutate) == null ? void 0 : a.call(i, t)); F !== this.state.context && De(this, hn, Yn).call(this, { type: "pending", context: F, variables: t, isPaused: r }) } const R = await N(this, Hr).start(); return await ((u = (l = N(this, dt).config).onSuccess) == null ? void 0 : u.call(l, R, t, this.state.context, this)), await ((p = (c = this.options).onSuccess) == null ? void 0 : p.call(c, R, t, this.state.context)), await ((w = (h = N(this, dt).config).onSettled) == null ? void 0 : w.call(h, R, null, this.state.variables, this.state.context, this)), await ((m = (S = this.options).onSettled) == null ? void 0 : m.call(S, R, null, t, this.state.context)), De(this, hn, Yn).call(this, { type: "success", data: R }), R } catch (R) { try { throw await ((g = (x = N(this, dt).config).onError) == null ? void 0 : g.call(x, R, t, this.state.context, this)), await ((y = (f = this.options).onError) == null ? void 0 : y.call(f, R, t, this.state.context)), await ((k = (_ = N(this, dt).config).onSettled) == null ? void 0 : k.call(_, void 0, R, this.state.variables, this.state.context, this)), await ((b = (T = this.options).onSettled) == null ? void 0 : b.call(T, void 0, R, t, this.state.context)), R } finally { De(this, hn, Yn).call(this, { type: "error", error: R }) } } finally { N(this, dt).runNext(this) } } }, pn = new WeakMap, dt = new WeakMap, Hr = new WeakMap, hn = new WeakSet, Yn = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, failureCount: t.failureCount, failureReason: t.error }; case "pause": return { ...r, isPaused: !0 }; case "continue": return { ...r, isPaused: !1 }; case "pending": return { ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now() }; case "success": return { ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error" } } }; this.state = n(this.state), Je.batch(() => { N(this, pn).forEach(r => { r.onMutationUpdate(t) }), N(this, dt).notify({ mutation: this, type: "updated", action: t }) }) }, lm); function Hg() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var Tt, Ii, um, m_ = (um = class extends $i { constructor(t = {}) { super(); de(this, Tt); de(this, Ii); this.config = t, se(this, Tt, new Map), se(this, Ii, Date.now()) } build(t, n, r) { const s = new h_({ mutationCache: this, mutationId: ++Qi(this, Ii)._, options: t.defaultMutationOptions(n), state: r }); return this.add(s), s } add(t) { const n = fa(t), r = N(this, Tt).get(n) ?? []; r.push(t), N(this, Tt).set(n, r), this.notify({ type: "added", mutation: t }) } remove(t) { var r; const n = fa(t); if (N(this, Tt).has(n)) { const s = (r = N(this, Tt).get(n)) == null ? void 0 : r.filter(o => o !== t); s && (s.length === 0 ? N(this, Tt).delete(n) : N(this, Tt).set(n, s)) } this.notify({ type: "removed", mutation: t }) } canRun(t) { var r; const n = (r = N(this, Tt).get(fa(t))) == null ? void 0 : r.find(s => s.state.status === "pending"); return !n || n === t } runNext(t) { var r; const n = (r = N(this, Tt).get(fa(t))) == null ? void 0 : r.find(s => s !== t && s.state.isPaused); return (n == null ? void 0 : n.continue()) ?? Promise.resolve() } clear() { Je.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } getAll() { return [...N(this, Tt).values()].flat() } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => lh(n, r)) } findAll(t = {}) { return this.getAll().filter(n => lh(t, n)) } notify(t) { Je.batch(() => { this.listeners.forEach(n => { n(t) }) }) } resumePausedMutations() { const t = this.getAll().filter(n => n.state.isPaused); return Je.batch(() => Promise.all(t.map(n => n.continue().catch(Gt)))) } }, Tt = new WeakMap, Ii = new WeakMap, um); function fa(e) { var t; return ((t = e.options.scope) == null ? void 0 : t.id) ?? String(e.mutationId) } function dh(e) { return { onFetch: (t, n) => { var c, p, h, w, S; const r = t.options, s = (h = (p = (c = t.fetchOptions) == null ? void 0 : c.meta) == null ? void 0 : p.fetchMore) == null ? void 0 : h.direction, o = ((w = t.state.data) == null ? void 0 : w.pages) || [], i = ((S = t.state.data) == null ? void 0 : S.pageParams) || []; let a = { pages: [], pageParams: [] }, l = 0; const u = async () => { let m = !1; const x = y => { Object.defineProperty(y, "signal", { enumerable: !0, get: () => (t.signal.aborted ? m = !0 : t.signal.addEventListener("abort", () => { m = !0 }), t.signal) }) }, g = Vg(t.options, t.fetchOptions), f = async (y, _, k) => { if (m) return Promise.reject(); if (_ == null && y.pages.length) return Promise.resolve(y); const T = { queryKey: t.queryKey, pageParam: _, direction: k ? "backward" : "forward", meta: t.options.meta }; x(T); const b = await g(T), { maxPages: R } = t.options, F = k ? s_ : r_; return { pages: F(y.pages, b, R), pageParams: F(y.pageParams, _, R) } }; if (s && o.length) { const y = s === "backward", _ = y ? v_ : fh, k = { pages: o, pageParams: i }, T = _(r, k); a = await f(k, T, y) } else { const y = e ?? o.length; do { const _ = l === 0 ? i[0] ?? r.initialPageParam : fh(r, a); if (l > 0 && _ == null) break; a = await f(a, _), l++ } while (l < y) } return a }; t.options.persister ? t.fetchFn = () => { var m, x; return (x = (m = t.options).persister) == null ? void 0 : x.call(m, u, { queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, n) } : t.fetchFn = u } } } function fh(e, { pages: t, pageParams: n }) { const r = t.length - 1; return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0 } function v_(e, { pages: t, pageParams: n }) { var r; return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0 } var Oe, ir, ar, Zs, Ks, lr, Qs, Gs, cm, g_ = (cm = class { constructor(e = {}) { de(this, Oe); de(this, ir); de(this, ar); de(this, Zs); de(this, Ks); de(this, lr); de(this, Qs); de(this, Gs); se(this, Oe, e.queryCache || new p_), se(this, ir, e.mutationCache || new m_), se(this, ar, e.defaultOptions || {}), se(this, Zs, new Map), se(this, Ks, new Map), se(this, lr, 0) } mount() { Qi(this, lr)._++, N(this, lr) === 1 && (se(this, Qs, zg.subscribe(async e => { e && (await this.resumePausedMutations(), N(this, Oe).onFocus()) })), se(this, Gs, cl.subscribe(async e => { e && (await this.resumePausedMutations(), N(this, Oe).onOnline()) }))) } unmount() { var e, t; Qi(this, lr)._--, N(this, lr) === 0 && ((e = N(this, Qs)) == null || e.call(this), se(this, Qs, void 0), (t = N(this, Gs)) == null || t.call(this), se(this, Gs, void 0)) } isFetching(e) { return N(this, Oe).findAll({ ...e, fetchStatus: "fetching" }).length } isMutating(e) { return N(this, ir).findAll({ ...e, status: "pending" }).length } getQueryData(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = N(this, Oe).get(t.queryHash)) == null ? void 0 : n.state.data } ensureQueryData(e) { const t = this.getQueryData(e.queryKey); if (t === void 0) return this.fetchQuery(e); { const n = this.defaultQueryOptions(e), r = N(this, Oe).build(this, n); return e.revalidateIfStale && r.isStaleByTime(ih(n.staleTime, r)) && this.prefetchQuery(n), Promise.resolve(t) } } getQueriesData(e) { return N(this, Oe).findAll(e).map(({ queryKey: t, state: n }) => { const r = n.data; return [t, r] }) } setQueryData(e, t, n) { const r = this.defaultQueryOptions({ queryKey: e }), s = N(this, Oe).get(r.queryHash), o = s == null ? void 0 : s.state.data, i = qS(t, o); if (i !== void 0) return N(this, Oe).build(this, r).setData(i, { ...n, manual: !0 }) } setQueriesData(e, t, n) { return Je.batch(() => N(this, Oe).findAll(e).map(({ queryKey: r }) => [r, this.setQueryData(r, t, n)])) } getQueryState(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = N(this, Oe).get(t.queryHash)) == null ? void 0 : n.state } removeQueries(e) { const t = N(this, Oe); Je.batch(() => { t.findAll(e).forEach(n => { t.remove(n) }) }) } resetQueries(e, t) { const n = N(this, Oe), r = { type: "active", ...e }; return Je.batch(() => (n.findAll(e).forEach(s => { s.reset() }), this.refetchQueries(r, t))) } cancelQueries(e = {}, t = {}) { const n = { revert: !0, ...t }, r = Je.batch(() => N(this, Oe).findAll(e).map(s => s.cancel(n))); return Promise.all(r).then(Gt).catch(Gt) } invalidateQueries(e = {}, t = {}) { return Je.batch(() => { if (N(this, Oe).findAll(e).forEach(r => { r.invalidate() }), e.refetchType === "none") return Promise.resolve(); const n = { ...e, type: e.refetchType ?? e.type ?? "active" }; return this.refetchQueries(n, t) }) } refetchQueries(e = {}, t) { const n = { ...t, cancelRefetch: (t == null ? void 0 : t.cancelRefetch) ?? !0 }, r = Je.batch(() => N(this, Oe).findAll(e).filter(s => !s.isDisabled()).map(s => { let o = s.fetch(void 0, n); return n.throwOnError || (o = o.catch(Gt)), s.state.fetchStatus === "paused" ? Promise.resolve() : o })); return Promise.all(r).then(Gt) } fetchQuery(e) { const t = this.defaultQueryOptions(e); t.retry === void 0 && (t.retry = !1); const n = N(this, Oe).build(this, t); return n.isStaleByTime(ih(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data) } prefetchQuery(e) { return this.fetchQuery(e).then(Gt).catch(Gt) } fetchInfiniteQuery(e) { return e.behavior = dh(e.pages), this.fetchQuery(e) } prefetchInfiniteQuery(e) { return this.fetchInfiniteQuery(e).then(Gt).catch(Gt) } ensureInfiniteQueryData(e) { return e.behavior = dh(e.pages), this.ensureQueryData(e) } resumePausedMutations() { return cl.isOnline() ? N(this, ir).resumePausedMutations() : Promise.resolve() } getQueryCache() { return N(this, Oe) } getMutationCache() { return N(this, ir) } getDefaultOptions() { return N(this, ar) } setDefaultOptions(e) { se(this, ar, e) } setQueryDefaults(e, t) { N(this, Zs).set(es(e), { queryKey: e, defaultOptions: t }) } getQueryDefaults(e) { const t = [...N(this, Zs).values()]; let n = {}; return t.forEach(r => { gi(e, r.queryKey) && (n = { ...n, ...r.defaultOptions }) }), n } setMutationDefaults(e, t) { N(this, Ks).set(es(e), { mutationKey: e, defaultOptions: t }) } getMutationDefaults(e) { const t = [...N(this, Ks).values()]; let n = {}; return t.forEach(r => { gi(e, r.mutationKey) && (n = { ...n, ...r.defaultOptions }) }), n } defaultQueryOptions(e) { if (e._defaulted) return e; const t = { ...N(this, ar).queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }; return t.queryHash || (t.queryHash = mf(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.enabled !== !0 && t.queryFn === vf && (t.enabled = !1), t } defaultMutationOptions(e) { return e != null && e._defaulted ? e : { ...N(this, ar).mutations, ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey), ...e, _defaulted: !0 } } clear() { N(this, Oe).clear(), N(this, ir).clear() } }, Oe = new WeakMap, ir = new WeakMap, ar = new WeakMap, Zs = new WeakMap, Ks = new WeakMap, lr = new WeakMap, Qs = new WeakMap, Gs = new WeakMap, cm), ur, cr, xt, On, Dn, Oa, Qc, dm, y_ = (dm = class extends $i { constructor(n, r) { super(); de(this, Dn); de(this, ur); de(this, cr); de(this, xt); de(this, On); se(this, ur, n), this.setOptions(r), this.bindMethods(), De(this, Dn, Oa).call(this) } bindMethods() { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this) } setOptions(n) { var s; const r = this.options; this.options = N(this, ur).defaultMutationOptions(n), e_(this.options, r) || N(this, ur).getMutationCache().notify({ type: "observerOptionsUpdated", mutation: N(this, xt), observer: this }), r != null && r.mutationKey && this.options.mutationKey && es(r.mutationKey) !== es(this.options.mutationKey) ? this.reset() : ((s = N(this, xt)) == null ? void 0 : s.state.status) === "pending" && N(this, xt).setOptions(this.options) } onUnsubscribe() { var n; this.hasListeners() || (n = N(this, xt)) == null || n.removeObserver(this) } onMutationUpdate(n) { De(this, Dn, Oa).call(this), De(this, Dn, Qc).call(this, n) } getCurrentResult() { return N(this, cr) } reset() { var n; (n = N(this, xt)) == null || n.removeObserver(this), se(this, xt, void 0), De(this, Dn, Oa).call(this), De(this, Dn, Qc).call(this) } mutate(n, r) { var s; return se(this, On, r), (s = N(this, xt)) == null || s.removeObserver(this), se(this, xt, N(this, ur).getMutationCache().build(N(this, ur), this.options)), N(this, xt).addObserver(this), N(this, xt).execute(n) } }, ur = new WeakMap, cr = new WeakMap, xt = new WeakMap, On = new WeakMap, Dn = new WeakSet, Oa = function () { var r; const n = ((r = N(this, xt)) == null ? void 0 : r.state) ?? Hg(); se(this, cr, { ...n, isPending: n.status === "pending", isSuccess: n.status === "success", isError: n.status === "error", isIdle: n.status === "idle", mutate: this.mutate, reset: this.reset }) }, Qc = function (n) { Je.batch(() => { var r, s, o, i, a, l, u, c; if (N(this, On) && this.hasListeners()) { const p = N(this, cr).variables, h = N(this, cr).context; (n == null ? void 0 : n.type) === "success" ? ((s = (r = N(this, On)).onSuccess) == null || s.call(r, n.data, p, h), (i = (o = N(this, On)).onSettled) == null || i.call(o, n.data, null, p, h)) : (n == null ? void 0 : n.type) === "error" && ((l = (a = N(this, On)).onError) == null || l.call(a, n.error, p, h), (c = (u = N(this, On)).onSettled) == null || c.call(u, void 0, n.error, p, h)) } this.listeners.forEach(p => { p(N(this, cr)) }) }) }, dm), Zg = v.createContext(void 0), x_ = e => { const t = v.useContext(Zg); if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one"); return t }, w_ = ({ client: e, children: t }) => (v.useEffect(() => (e.mount(), () => { e.unmount() }), [e]), d.jsx(Zg.Provider, { value: e, children: t })); function S_(e, t) { return typeof e == "function" ? e(...t) : !!e } function __() { } function C_(e, t) { const n = x_(), [r] = v.useState(() => new y_(n, e)); v.useEffect(() => { r.setOptions(e) }, [r, e]); const s = v.useSyncExternalStore(v.useCallback(i => r.subscribe(Je.batchCalls(i)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult()), o = v.useCallback((i, a) => { r.mutate(i, a).catch(__) }, [r]); if (s.error && S_(r.options.throwOnError, [s.error])) throw s.error; return { ...s, mutate: o, mutateAsync: s.mutate } } async function Kg(e) { if (!e.ok) { const t = await e.text() || e.statusText; throw new Error(`${e.status}: ${t}`) } } async function k_(e, t, n) { const r = await fetch(t, { method: e, headers: n ? { "Content-Type": "application/json" } : {}, body: n ? JSON.stringify(n) : void 0, credentials: "include" }); return await Kg(r), r } const b_ = ({ on401: e }) => async ({ queryKey: t }) => { const n = await fetch(t[0], { credentials: "include" }); return e === "returnNull" && n.status === 401 ? null : (await Kg(n), await n.json()) }, E_ = new g_({ defaultOptions: { queries: { queryFn: b_({ on401: "throw" }), refetchInterval: !1, refetchOnWindowFocus: !1, staleTime: 1 / 0, retry: !1 }, mutations: { retry: !1 } } }), T_ = 1, N_ = 1e6; let zu = 0; function P_() { return zu = (zu + 1) % Number.MAX_SAFE_INTEGER, zu.toString() } const $u = new Map, ph = e => { if ($u.has(e)) return; const t = setTimeout(() => { $u.delete(e), Yo({ type: "REMOVE_TOAST", toastId: e }) }, N_); $u.set(e, t) }, R_ = (e, t) => { switch (t.type) { case "ADD_TOAST": return { ...e, toasts: [t.toast, ...e.toasts].slice(0, T_) }; case "UPDATE_TOAST": return { ...e, toasts: e.toasts.map(n => n.id === t.toast.id ? { ...n, ...t.toast } : n) }; case "DISMISS_TOAST": { const { toastId: n } = t; return n ? ph(n) : e.toasts.forEach(r => { ph(r.id) }), { ...e, toasts: e.toasts.map(r => r.id === n || n === void 0 ? { ...r, open: !1 } : r) } } case "REMOVE_TOAST": return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter(n => n.id !== t.toastId) } } }, Ma = []; let Ia = { toasts: [] }; function Yo(e) { Ia = R_(Ia, e), Ma.forEach(t => { t(Ia) }) } function A_({ ...e }) { const t = P_(), n = s => Yo({ type: "UPDATE_TOAST", toast: { ...s, id: t } }), r = () => Yo({ type: "DISMISS_TOAST", toastId: t }); return Yo({ type: "ADD_TOAST", toast: { ...e, id: t, open: !0, onOpenChange: s => { s || r() } } }), { id: t, dismiss: r, update: n } } function Qg() { const [e, t] = v.useState(Ia); return v.useEffect(() => (Ma.push(t), () => { const n = Ma.indexOf(t); n > -1 && Ma.splice(n, 1) }), [e]), { ...e, toast: A_, dismiss: n => Yo({ type: "DISMISS_TOAST", toastId: n }) } } function ce(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (s) { if (e == null || e(s), n === !1 || !s.defaultPrevented) return t == null ? void 0 : t(s) } } function hh(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Gg(...e) { return t => { let n = !1; const r = e.map(s => { const o = hh(s, t); return !n && typeof o == "function" && (n = !0), o }); if (n) return () => { for (let s = 0; s < r.length; s++) { const o = r[s]; typeof o == "function" ? o() : hh(e[s], null) } } } } function Ie(...e) { return v.useCallback(Gg(...e), e) } function Ui(e, t = []) { let n = []; function r(o, i) { const a = v.createContext(i), l = n.length; n = [...n, i]; const u = p => { var g; const { scope: h, children: w, ...S } = p, m = ((g = h == null ? void 0 : h[e]) == null ? void 0 : g[l]) || a, x = v.useMemo(() => S, Object.values(S)); return d.jsx(m.Provider, { value: x, children: w }) }; u.displayName = o + "Provider"; function c(p, h) { var m; const w = ((m = h == null ? void 0 : h[e]) == null ? void 0 : m[l]) || a, S = v.useContext(w); if (S) return S; if (i !== void 0) return i; throw new Error(`\`${p}\` must be used within \`${o}\``) } return [u, c] } const s = () => { const o = n.map(i => v.createContext(i)); return function (a) { const l = (a == null ? void 0 : a[e]) || o; return v.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l]) } }; return s.scopeName = e, [r, j_(s, ...t)] } function j_(...e) { const t = e[0]; if (e.length === 1) return t; const n = () => { const r = e.map(s => ({ useScope: s(), scopeName: s.scopeName })); return function (o) { const i = r.reduce((a, { useScope: l, scopeName: u }) => { const p = l(o)[`__scope${u}`]; return { ...a, ...p } }, {}); return v.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]) } }; return n.scopeName = t.scopeName, n } function yi(e) { const t = O_(e), n = v.forwardRef((r, s) => { const { children: o, ...i } = r, a = v.Children.toArray(o), l = a.find(I_); if (l) { const u = l.props.children, c = a.map(p => p === l ? v.Children.count(u) > 1 ? v.Children.only(null) : v.isValidElement(u) ? u.props.children : null : p); return d.jsx(t, { ...i, ref: s, children: v.isValidElement(u) ? v.cloneElement(u, void 0, c) : null }) } return d.jsx(t, { ...i, ref: s, children: o }) }); return n.displayName = `${e}.Slot`, n } var qg = yi("Slot"); function O_(e) { const t = v.forwardRef((n, r) => { const { children: s, ...o } = n; if (v.isValidElement(s)) { const i = D_(s), a = L_(o, s.props); return s.type !== v.Fragment && (a.ref = r ? Gg(r, i) : i), v.cloneElement(s, a) } return v.Children.count(s) > 1 ? v.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var Yg = Symbol("radix.slottable"); function M_(e) { const t = ({ children: n }) => d.jsx(d.Fragment, { children: n }); return t.displayName = `${e}.Slottable`, t.__radixId = Yg, t } function I_(e) { return v.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Yg } function L_(e, t) { const n = { ...t }; for (const r in t) { const s = e[r], o = t[r]; /^on[A-Z]/.test(r) ? s && o ? n[r] = (...a) => { o(...a), s(...a) } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...o } : r === "className" && (n[r] = [s, o].filter(Boolean).join(" ")) } return { ...e, ...n } } function D_(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function Xg(e) { const t = e + "CollectionProvider", [n, r] = Ui(t), [s, o] = n(t, { collectionRef: { current: null }, itemMap: new Map }), i = m => { const { scope: x, children: g } = m, f = oe.useRef(null), y = oe.useRef(new Map).current; return d.jsx(s, { scope: x, itemMap: y, collectionRef: f, children: g }) }; i.displayName = t; const a = e + "CollectionSlot", l = yi(a), u = oe.forwardRef((m, x) => { const { scope: g, children: f } = m, y = o(a, g), _ = Ie(x, y.collectionRef); return d.jsx(l, { ref: _, children: f }) }); u.displayName = a; const c = e + "CollectionItemSlot", p = "data-radix-collection-item", h = yi(c), w = oe.forwardRef((m, x) => { const { scope: g, children: f, ...y } = m, _ = oe.useRef(null), k = Ie(x, _), T = o(c, g); return oe.useEffect(() => (T.itemMap.set(_, { ref: _, ...y }), () => void T.itemMap.delete(_))), d.jsx(h, { [p]: "", ref: k, children: f }) }); w.displayName = c; function S(m) { const x = o(e + "CollectionConsumer", m); return oe.useCallback(() => { const f = x.collectionRef.current; if (!f) return []; const y = Array.from(f.querySelectorAll(`[${p}]`)); return Array.from(x.itemMap.values()).sort((T, b) => y.indexOf(T.ref.current) - y.indexOf(b.ref.current)) }, [x.collectionRef, x.itemMap]) } return [{ Provider: i, Slot: u, ItemSlot: w }, S, r] } var F_ = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], _e = F_.reduce((e, t) => { const n = yi(`Primitive.${t}`), r = v.forwardRef((s, o) => { const { asChild: i, ...a } = s, l = i ? n : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), d.jsx(l, { ...a, ref: o }) }); return r.displayName = `Primitive.${t}`, { ...e, [t]: r } }, {}); function Jg(e, t) { e && ls.flushSync(() => e.dispatchEvent(t)) } function Lt(e) { const t = v.useRef(e); return v.useEffect(() => { t.current = e }), v.useMemo(() => (...n) => { var r; return (r = t.current) == null ? void 0 : r.call(t, ...n) }, []) } function V_(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Lt(e); v.useEffect(() => { const r = s => { s.key === "Escape" && n(s) }; return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 }) }, [n, t]) } var z_ = "DismissableLayer", Gc = "dismissableLayer.update", $_ = "dismissableLayer.pointerDownOutside", U_ = "dismissableLayer.focusOutside", mh, ey = v.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), Hl = v.forwardRef((e, t) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: s, onFocusOutside: o, onInteractOutside: i, onDismiss: a, ...l } = e, u = v.useContext(ey), [c, p] = v.useState(null), h = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, w] = v.useState({}), S = Ie(t, b => p(b)), m = Array.from(u.layers), [x] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), g = m.indexOf(x), f = c ? m.indexOf(c) : -1, y = u.layersWithOutsidePointerEventsDisabled.size > 0, _ = f >= g, k = W_(b => { const R = b.target, F = [...u.branches].some(V => V.contains(R)); !_ || F || (s == null || s(b), i == null || i(b), b.defaultPrevented || a == null || a()) }, h), T = H_(b => { const R = b.target;[...u.branches].some(V => V.contains(R)) || (o == null || o(b), i == null || i(b), b.defaultPrevented || a == null || a()) }, h); return V_(b => { f === u.layers.size - 1 && (r == null || r(b), !b.defaultPrevented && a && (b.preventDefault(), a())) }, h), v.useEffect(() => { if (c) return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (mh = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), vh(), () => { n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = mh) } }, [c, h, n, u]), v.useEffect(() => () => { c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), vh()) }, [c, u]), v.useEffect(() => { const b = () => w({}); return document.addEventListener(Gc, b), () => document.removeEventListener(Gc, b) }, []), d.jsx(_e.div, { ...l, ref: S, style: { pointerEvents: y ? _ ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: ce(e.onFocusCapture, T.onFocusCapture), onBlurCapture: ce(e.onBlurCapture, T.onBlurCapture), onPointerDownCapture: ce(e.onPointerDownCapture, k.onPointerDownCapture) }) }); Hl.displayName = z_; var B_ = "DismissableLayerBranch", ty = v.forwardRef((e, t) => { const n = v.useContext(ey), r = v.useRef(null), s = Ie(t, r); return v.useEffect(() => { const o = r.current; if (o) return n.branches.add(o), () => { n.branches.delete(o) } }, [n.branches]), d.jsx(_e.div, { ...e, ref: s }) }); ty.displayName = B_; function W_(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Lt(e), r = v.useRef(!1), s = v.useRef(() => { }); return v.useEffect(() => { const o = a => { if (a.target && !r.current) { let l = function () { ny($_, n, u, { discrete: !0 }) }; const u = { originalEvent: a }; a.pointerType === "touch" ? (t.removeEventListener("click", s.current), s.current = l, t.addEventListener("click", s.current, { once: !0 })) : l() } else t.removeEventListener("click", s.current); r.current = !1 }, i = window.setTimeout(() => { t.addEventListener("pointerdown", o) }, 0); return () => { window.clearTimeout(i), t.removeEventListener("pointerdown", o), t.removeEventListener("click", s.current) } }, [t, n]), { onPointerDownCapture: () => r.current = !0 } } function H_(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Lt(e), r = v.useRef(!1); return v.useEffect(() => { const s = o => { o.target && !r.current && ny(U_, n, { originalEvent: o }, { discrete: !1 }) }; return t.addEventListener("focusin", s), () => t.removeEventListener("focusin", s) }, [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function vh() { const e = new CustomEvent(Gc); document.dispatchEvent(e) } function ny(e, t, n, { discrete: r }) { const s = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? Jg(s, o) : s.dispatchEvent(o) } var Z_ = Hl, K_ = ty, lt = globalThis != null && globalThis.document ? v.useLayoutEffect : () => { }, Q_ = "Portal", gf = v.forwardRef((e, t) => { var a; const { container: n, ...r } = e, [s, o] = v.useState(!1); lt(() => o(!0), []); const i = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body); return i ? xS.createPortal(d.jsx(_e.div, { ...r, ref: t }), i) : null }); gf.displayName = Q_; function G_(e, t) { return v.useReducer((n, r) => t[n][r] ?? n, e) } var yf = e => { const { present: t, children: n } = e, r = q_(t), s = typeof n == "function" ? n({ present: r.isPresent }) : v.Children.only(n), o = Ie(r.ref, Y_(s)); return typeof n == "function" || r.isPresent ? v.cloneElement(s, { ref: o }) : null }; yf.displayName = "Presence"; function q_(e) { const [t, n] = v.useState(), r = v.useRef({}), s = v.useRef(e), o = v.useRef("none"), i = e ? "mounted" : "unmounted", [a, l] = G_(i, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return v.useEffect(() => { const u = pa(r.current); o.current = a === "mounted" ? u : "none" }, [a]), lt(() => { const u = r.current, c = s.current; if (c !== e) { const h = o.current, w = pa(u); e ? l("MOUNT") : w === "none" || (u == null ? void 0 : u.display) === "none" ? l("UNMOUNT") : l(c && h !== w ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e } }, [e, l]), lt(() => { if (t) { let u; const c = t.ownerDocument.defaultView ?? window, p = w => { const m = pa(r.current).includes(w.animationName); if (w.target === t && m && (l("ANIMATION_END"), !s.current)) { const x = t.style.animationFillMode; t.style.animationFillMode = "forwards", u = c.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = x) }) } }, h = w => { w.target === t && (o.current = pa(r.current)) }; return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => { c.clearTimeout(u), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p) } } else l("ANIMATION_END") }, [t, l]), { isPresent: ["mounted", "unmountSuspended"].includes(a), ref: v.useCallback(u => { u && (r.current = getComputedStyle(u)), n(u) }, []) } } function pa(e) { return (e == null ? void 0 : e.animationName) || "none" } function Y_(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function qc({ prop: e, defaultProp: t, onChange: n = () => { } }) { const [r, s] = X_({ defaultProp: t, onChange: n }), o = e !== void 0, i = o ? e : r, a = Lt(n), l = v.useCallback(u => { if (o) { const p = typeof u == "function" ? u(e) : u; p !== e && a(p) } else s(u) }, [o, e, s, a]); return [i, l] } function X_({ defaultProp: e, onChange: t }) { const n = v.useState(e), [r] = n, s = v.useRef(r), o = Lt(t); return v.useEffect(() => { s.current !== r && (o(r), s.current = r) }, [r, s, o]), n } var J_ = "VisuallyHidden", Bi = v.forwardRef((e, t) => d.jsx(_e.span, { ...e, ref: t, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...e.style } })); Bi.displayName = J_; var eC = Bi, xf = "ToastProvider", [wf, tC, nC] = Xg("Toast"), [ry, vP] = Ui("Toast", [nC]), [rC, Zl] = ry(xf), sy = e => { const { __scopeToast: t, label: n = "Notification", duration: r = 5e3, swipeDirection: s = "right", swipeThreshold: o = 50, children: i } = e, [a, l] = v.useState(null), [u, c] = v.useState(0), p = v.useRef(!1), h = v.useRef(!1); return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${xf}\`. Expected non-empty \`string\`.`), d.jsx(wf.Provider, { scope: t, children: d.jsx(rC, { scope: t, label: n, duration: r, swipeDirection: s, swipeThreshold: o, toastCount: u, viewport: a, onViewportChange: l, onToastAdd: v.useCallback(() => c(w => w + 1), []), onToastRemove: v.useCallback(() => c(w => w - 1), []), isFocusedToastEscapeKeyDownRef: p, isClosePausedRef: h, children: i }) }) }; sy.displayName = xf; var oy = "ToastViewport", sC = ["F8"], Yc = "toast.viewportPause", Xc = "toast.viewportResume", iy = v.forwardRef((e, t) => { const { __scopeToast: n, hotkey: r = sC, label: s = "Notifications ({hotkey})", ...o } = e, i = Zl(oy, n), a = tC(n), l = v.useRef(null), u = v.useRef(null), c = v.useRef(null), p = v.useRef(null), h = Ie(t, p, i.onViewportChange), w = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), S = i.toastCount > 0; v.useEffect(() => { const x = g => { var y; r.length !== 0 && r.every(_ => g[_] || g.code === _) && ((y = p.current) == null || y.focus()) }; return document.addEventListener("keydown", x), () => document.removeEventListener("keydown", x) }, [r]), v.useEffect(() => { const x = l.current, g = p.current; if (S && x && g) { const f = () => { if (!i.isClosePausedRef.current) { const T = new CustomEvent(Yc); g.dispatchEvent(T), i.isClosePausedRef.current = !0 } }, y = () => { if (i.isClosePausedRef.current) { const T = new CustomEvent(Xc); g.dispatchEvent(T), i.isClosePausedRef.current = !1 } }, _ = T => { !x.contains(T.relatedTarget) && y() }, k = () => { x.contains(document.activeElement) || y() }; return x.addEventListener("focusin", f), x.addEventListener("focusout", _), x.addEventListener("pointermove", f), x.addEventListener("pointerleave", k), window.addEventListener("blur", f), window.addEventListener("focus", y), () => { x.removeEventListener("focusin", f), x.removeEventListener("focusout", _), x.removeEventListener("pointermove", f), x.removeEventListener("pointerleave", k), window.removeEventListener("blur", f), window.removeEventListener("focus", y) } } }, [S, i.isClosePausedRef]); const m = v.useCallback(({ tabbingDirection: x }) => { const f = a().map(y => { const _ = y.ref.current, k = [_, ...gC(_)]; return x === "forwards" ? k : k.reverse() }); return (x === "forwards" ? f.reverse() : f).flat() }, [a]); return v.useEffect(() => { const x = p.current; if (x) { const g = f => { var k, T, b; const y = f.altKey || f.ctrlKey || f.metaKey; if (f.key === "Tab" && !y) { const R = document.activeElement, F = f.shiftKey; if (f.target === x && F) { (k = u.current) == null || k.focus(); return } const O = m({ tabbingDirection: F ? "backwards" : "forwards" }), z = O.findIndex(j => j === R); Uu(O.slice(z + 1)) ? f.preventDefault() : F ? (T = u.current) == null || T.focus() : (b = c.current) == null || b.focus() } }; return x.addEventListener("keydown", g), () => x.removeEventListener("keydown", g) } }, [a, m]), d.jsxs(K_, { ref: l, role: "region", "aria-label": s.replace("{hotkey}", w), tabIndex: -1, style: { pointerEvents: S ? void 0 : "none" }, children: [S && d.jsx(Jc, { ref: u, onFocusFromOutsideViewport: () => { const x = m({ tabbingDirection: "forwards" }); Uu(x) } }), d.jsx(wf.Slot, { scope: n, children: d.jsx(_e.ol, { tabIndex: -1, ...o, ref: h }) }), S && d.jsx(Jc, { ref: c, onFocusFromOutsideViewport: () => { const x = m({ tabbingDirection: "backwards" }); Uu(x) } })] }) }); iy.displayName = oy; var ay = "ToastFocusProxy", Jc = v.forwardRef((e, t) => { const { __scopeToast: n, onFocusFromOutsideViewport: r, ...s } = e, o = Zl(ay, n); return d.jsx(Bi, { "aria-hidden": !0, tabIndex: 0, ...s, ref: t, style: { position: "fixed" }, onFocus: i => { var u; const a = i.relatedTarget; !((u = o.viewport) != null && u.contains(a)) && r() } }) }); Jc.displayName = ay; var Kl = "Toast", oC = "toast.swipeStart", iC = "toast.swipeMove", aC = "toast.swipeCancel", lC = "toast.swipeEnd", ly = v.forwardRef((e, t) => { const { forceMount: n, open: r, defaultOpen: s, onOpenChange: o, ...i } = e, [a = !0, l] = qc({ prop: r, defaultProp: s, onChange: o }); return d.jsx(yf, { present: n || a, children: d.jsx(dC, { open: a, ...i, ref: t, onClose: () => l(!1), onPause: Lt(e.onPause), onResume: Lt(e.onResume), onSwipeStart: ce(e.onSwipeStart, u => { u.currentTarget.setAttribute("data-swipe", "start") }), onSwipeMove: ce(e.onSwipeMove, u => { const { x: c, y: p } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${p}px`) }), onSwipeCancel: ce(e.onSwipeCancel, u => { u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y") }), onSwipeEnd: ce(e.onSwipeEnd, u => { const { x: c, y: p } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), l(!1) }) }) }) }); ly.displayName = Kl; var [uC, cC] = ry(Kl, { onClose() { } }), dC = v.forwardRef((e, t) => { const { __scopeToast: n, type: r = "foreground", duration: s, open: o, onClose: i, onEscapeKeyDown: a, onPause: l, onResume: u, onSwipeStart: c, onSwipeMove: p, onSwipeCancel: h, onSwipeEnd: w, ...S } = e, m = Zl(Kl, n), [x, g] = v.useState(null), f = Ie(t, j => g(j)), y = v.useRef(null), _ = v.useRef(null), k = s || m.duration, T = v.useRef(0), b = v.useRef(k), R = v.useRef(0), { onToastAdd: F, onToastRemove: V } = m, Y = Lt(() => { var X; (x == null ? void 0 : x.contains(document.activeElement)) && ((X = m.viewport) == null || X.focus()), i() }), O = v.useCallback(j => { !j || j === 1 / 0 || (window.clearTimeout(R.current), T.current = new Date().getTime(), R.current = window.setTimeout(Y, j)) }, [Y]); v.useEffect(() => { const j = m.viewport; if (j) { const X = () => { O(b.current), u == null || u() }, K = () => { const J = new Date().getTime() - T.current; b.current = b.current - J, window.clearTimeout(R.current), l == null || l() }; return j.addEventListener(Yc, K), j.addEventListener(Xc, X), () => { j.removeEventListener(Yc, K), j.removeEventListener(Xc, X) } } }, [m.viewport, k, l, u, O]), v.useEffect(() => { o && !m.isClosePausedRef.current && O(k) }, [o, k, m.isClosePausedRef, O]), v.useEffect(() => (F(), () => V()), [F, V]); const z = v.useMemo(() => x ? my(x) : null, [x]); return m.viewport ? d.jsxs(d.Fragment, { children: [z && d.jsx(fC, { __scopeToast: n, role: "status", "aria-live": r === "foreground" ? "assertive" : "polite", "aria-atomic": !0, children: z }), d.jsx(uC, { scope: n, onClose: Y, children: ls.createPortal(d.jsx(wf.ItemSlot, { scope: n, children: d.jsx(Z_, { asChild: !0, onEscapeKeyDown: ce(a, () => { m.isFocusedToastEscapeKeyDownRef.current || Y(), m.isFocusedToastEscapeKeyDownRef.current = !1 }), children: d.jsx(_e.li, { role: "status", "aria-live": "off", "aria-atomic": !0, tabIndex: 0, "data-state": o ? "open" : "closed", "data-swipe-direction": m.swipeDirection, ...S, ref: f, style: { userSelect: "none", touchAction: "none", ...e.style }, onKeyDown: ce(e.onKeyDown, j => { j.key === "Escape" && (a == null || a(j.nativeEvent), j.nativeEvent.defaultPrevented || (m.isFocusedToastEscapeKeyDownRef.current = !0, Y())) }), onPointerDown: ce(e.onPointerDown, j => { j.button === 0 && (y.current = { x: j.clientX, y: j.clientY }) }), onPointerMove: ce(e.onPointerMove, j => { if (!y.current) return; const X = j.clientX - y.current.x, K = j.clientY - y.current.y, J = !!_.current, P = ["left", "right"].includes(m.swipeDirection), D = ["left", "up"].includes(m.swipeDirection) ? Math.min : Math.max, Q = P ? D(0, X) : 0, re = P ? 0 : D(0, K), ve = j.pointerType === "touch" ? 10 : 2, Ke = { x: Q, y: re }, Le = { originalEvent: j, delta: Ke }; J ? (_.current = Ke, ha(iC, p, Le, { discrete: !1 })) : gh(Ke, m.swipeDirection, ve) ? (_.current = Ke, ha(oC, c, Le, { discrete: !1 }), j.target.setPointerCapture(j.pointerId)) : (Math.abs(X) > ve || Math.abs(K) > ve) && (y.current = null) }), onPointerUp: ce(e.onPointerUp, j => { const X = _.current, K = j.target; if (K.hasPointerCapture(j.pointerId) && K.releasePointerCapture(j.pointerId), _.current = null, y.current = null, X) { const J = j.currentTarget, P = { originalEvent: j, delta: X }; gh(X, m.swipeDirection, m.swipeThreshold) ? ha(lC, w, P, { discrete: !0 }) : ha(aC, h, P, { discrete: !0 }), J.addEventListener("click", D => D.preventDefault(), { once: !0 }) } }) }) }) }), m.viewport) })] }) : null }), fC = e => { const { __scopeToast: t, children: n, ...r } = e, s = Zl(Kl, t), [o, i] = v.useState(!1), [a, l] = v.useState(!1); return mC(() => i(!0)), v.useEffect(() => { const u = window.setTimeout(() => l(!0), 1e3); return () => window.clearTimeout(u) }, []), a ? null : d.jsx(gf, { asChild: !0, children: d.jsx(Bi, { ...r, children: o && d.jsxs(d.Fragment, { children: [s.label, " ", n] }) }) }) }, pC = "ToastTitle", uy = v.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return d.jsx(_e.div, { ...r, ref: t }) }); uy.displayName = pC; var hC = "ToastDescription", cy = v.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return d.jsx(_e.div, { ...r, ref: t }) }); cy.displayName = hC; var dy = "ToastAction", fy = v.forwardRef((e, t) => { const { altText: n, ...r } = e; return n.trim() ? d.jsx(hy, { altText: n, asChild: !0, children: d.jsx(Sf, { ...r, ref: t }) }) : (console.error(`Invalid prop \`altText\` supplied to \`${dy}\`. Expected non-empty \`string\`.`), null) }); fy.displayName = dy; var py = "ToastClose", Sf = v.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e, s = cC(py, n); return d.jsx(hy, { asChild: !0, children: d.jsx(_e.button, { type: "button", ...r, ref: t, onClick: ce(e.onClick, s.onClose) }) }) }); Sf.displayName = py; var hy = v.forwardRef((e, t) => { const { __scopeToast: n, altText: r, ...s } = e; return d.jsx(_e.div, { "data-radix-toast-announce-exclude": "", "data-radix-toast-announce-alt": r || void 0, ...s, ref: t }) }); function my(e) { const t = []; return Array.from(e.childNodes).forEach(r => { if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), vC(r)) { const s = r.ariaHidden || r.hidden || r.style.display === "none", o = r.dataset.radixToastAnnounceExclude === ""; if (!s) if (o) { const i = r.dataset.radixToastAnnounceAlt; i && t.push(i) } else t.push(...my(r)) } }), t } function ha(e, t, n, { discrete: r }) { const s = n.originalEvent.currentTarget, o = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? Jg(s, o) : s.dispatchEvent(o) } var gh = (e, t, n = 0) => { const r = Math.abs(e.x), s = Math.abs(e.y), o = r > s; return t === "left" || t === "right" ? o && r > n : !o && s > n }; function mC(e = () => { }) { const t = Lt(e); lt(() => { let n = 0, r = 0; return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => { window.cancelAnimationFrame(n), window.cancelAnimationFrame(r) } }, [t]) } function vC(e) { return e.nodeType === e.ELEMENT_NODE } function gC(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const s = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function Uu(e) { const t = document.activeElement; return e.some(n => n === t ? !0 : (n.focus(), document.activeElement !== t)) } var yC = sy, vy = iy, gy = ly, yy = uy, xy = cy, wy = fy, Sy = Sf; function _y(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var s = e.length; for (t = 0; t < s; t++)e[t] && (n = _y(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function Cy() { for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)(e = arguments[n]) && (t = _y(e)) && (r && (r += " "), r += t); return r } const yh = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, xh = Cy, _f = (e, t) => n => { var r; if ((t == null ? void 0 : t.variants) == null) return xh(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className); const { variants: s, defaultVariants: o } = t, i = Object.keys(s).map(u => { const c = n == null ? void 0 : n[u], p = o == null ? void 0 : o[u]; if (c === null) return null; const h = yh(c) || yh(p); return s[u][h] }), a = n && Object.entries(n).reduce((u, c) => { let [p, h] = c; return h === void 0 || (u[p] = h), u }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, c) => { let { class: p, className: h, ...w } = c; return Object.entries(w).every(S => { let [m, x] = S; return Array.isArray(x) ? x.includes({ ...o, ...a }[m]) : { ...o, ...a }[m] === x }) ? [...u, p, h] : u }, []); return xh(e, i, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className) };/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xC = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), ky = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(" ");/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var wC = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const SC = v.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: s = "", children: o, iconNode: i, ...a }, l) => v.createElement("svg", { ref: l, ...wC, width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: ky("lucide", s), ...a }, [...i.map(([u, c]) => v.createElement(u, c)), ...Array.isArray(o) ? o : [o]]));/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const us = (e, t) => { const n = v.forwardRef(({ className: r, ...s }, o) => v.createElement(SC, { ref: o, iconNode: t, className: ky(`lucide-${xC(e)}`, r), ...s })); return n.displayName = `${e}`, n };/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const by = us("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ey = us("ChevronDown", [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _C = us("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const CC = us("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kC = us("Menu", [["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }], ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }], ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bC = us("Star", [["polygon", { points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2", key: "8f66p6" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ty = us("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), Cf = "-", EC = e => { const t = NC(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: i => { const a = i.split(Cf); return a[0] === "" && a.length !== 1 && a.shift(), Ny(a, t) || TC(i) }, getConflictingClassGroupIds: (i, a) => { const l = n[i] || []; return a && r[i] ? [...l, ...r[i]] : l } } }, Ny = (e, t) => { var i; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), s = r ? Ny(e.slice(1), r) : void 0; if (s) return s; if (t.validators.length === 0) return; const o = e.join(Cf); return (i = t.validators.find(({ validator: a }) => a(o))) == null ? void 0 : i.classGroupId }, wh = /^\[(.+)\]$/, TC = e => { if (wh.test(e)) { const t = wh.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, NC = e => { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }; return RC(Object.entries(e.classGroups), n).forEach(([o, i]) => { ed(i, r, o, t) }), r }, ed = (e, t, n, r) => { e.forEach(s => { if (typeof s == "string") { const o = s === "" ? t : Sh(t, s); o.classGroupId = n; return } if (typeof s == "function") { if (PC(s)) { ed(s(r), t, n, r); return } t.validators.push({ validator: s, classGroupId: n }); return } Object.entries(s).forEach(([o, i]) => { ed(i, Sh(t, o), n, r) }) }) }, Sh = (e, t) => { let n = e; return t.split(Cf).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, PC = e => e.isThemeGetter, RC = (e, t) => t ? e.map(([n, r]) => { const s = r.map(o => typeof o == "string" ? t + o : typeof o == "object" ? Object.fromEntries(Object.entries(o).map(([i, a]) => [t + i, a])) : o); return [n, s] }) : e, AC = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const s = (o, i) => { n.set(o, i), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(o) { let i = n.get(o); if (i !== void 0) return i; if ((i = r.get(o)) !== void 0) return s(o, i), i }, set(o, i) { n.has(o) ? n.set(o, i) : s(o, i) } } }, Py = "!", jC = e => { const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, s = t[0], o = t.length, i = a => { const l = []; let u = 0, c = 0, p; for (let x = 0; x < a.length; x++) { let g = a[x]; if (u === 0) { if (g === s && (r || a.slice(x, x + o) === t)) { l.push(a.slice(c, x)), c = x + o; continue } if (g === "/") { p = x; continue } } g === "[" ? u++ : g === "]" && u-- } const h = l.length === 0 ? a : a.substring(c), w = h.startsWith(Py), S = w ? h.substring(1) : h, m = p && p > c ? p - c : void 0; return { modifiers: l, hasImportantModifier: w, baseClassName: S, maybePostfixModifierPosition: m } }; return n ? a => n({ className: a, parseClassName: i }) : i }, OC = e => { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach(r => { r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r) }), t.push(...n.sort()), t }, MC = e => ({ cache: AC(e.cacheSize), parseClassName: jC(e), ...EC(e) }), IC = /\s+/, LC = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: s } = t, o = [], i = e.trim().split(IC); let a = ""; for (let l = i.length - 1; l >= 0; l -= 1) { const u = i[l], { modifiers: c, hasImportantModifier: p, baseClassName: h, maybePostfixModifierPosition: w } = n(u); let S = !!w, m = r(S ? h.substring(0, w) : h); if (!m) { if (!S) { a = u + (a.length > 0 ? " " + a : a); continue } if (m = r(h), !m) { a = u + (a.length > 0 ? " " + a : a); continue } S = !1 } const x = OC(c).join(":"), g = p ? x + Py : x, f = g + m; if (o.includes(f)) continue; o.push(f); const y = s(m, S); for (let _ = 0; _ < y.length; ++_) { const k = y[_]; o.push(g + k) } a = u + (a.length > 0 ? " " + a : a) } return a }; function DC() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = Ry(t)) && (r && (r += " "), r += n); return r } const Ry = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = Ry(e[r])) && (n && (n += " "), n += t); return n }; function FC(e, ...t) { let n, r, s, o = i; function i(l) { const u = t.reduce((c, p) => p(c), e()); return n = MC(u), r = n.cache.get, s = n.cache.set, o = a, a(l) } function a(l) { const u = r(l); if (u) return u; const c = LC(l, n); return s(l, c), c } return function () { return o(DC.apply(null, arguments)) } } const be = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, Ay = /^\[(?:([a-z-]+):)?(.+)\]$/i, VC = /^\d+\/\d+$/, zC = new Set(["px", "full", "screen"]), $C = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, UC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, BC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, WC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, HC = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, En = e => Ds(e) || zC.has(e) || VC.test(e), Gn = e => ho(e, "length", JC), Ds = e => !!e && !Number.isNaN(Number(e)), Bu = e => ho(e, "number", Ds), Eo = e => !!e && Number.isInteger(Number(e)), ZC = e => e.endsWith("%") && Ds(e.slice(0, -1)), ae = e => Ay.test(e), qn = e => $C.test(e), KC = new Set(["length", "size", "percentage"]), QC = e => ho(e, KC, jy), GC = e => ho(e, "position", jy), qC = new Set(["image", "url"]), YC = e => ho(e, qC, tk), XC = e => ho(e, "", ek), To = () => !0, ho = (e, t, n) => { const r = Ay.exec(e); return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1 }, JC = e => UC.test(e) && !BC.test(e), jy = () => !1, ek = e => WC.test(e), tk = e => HC.test(e), nk = () => { const e = be("colors"), t = be("spacing"), n = be("blur"), r = be("brightness"), s = be("borderColor"), o = be("borderRadius"), i = be("borderSpacing"), a = be("borderWidth"), l = be("contrast"), u = be("grayscale"), c = be("hueRotate"), p = be("invert"), h = be("gap"), w = be("gradientColorStops"), S = be("gradientColorStopPositions"), m = be("inset"), x = be("margin"), g = be("opacity"), f = be("padding"), y = be("saturate"), _ = be("scale"), k = be("sepia"), T = be("skew"), b = be("space"), R = be("translate"), F = () => ["auto", "contain", "none"], V = () => ["auto", "hidden", "clip", "visible", "scroll"], Y = () => ["auto", ae, t], O = () => [ae, t], z = () => ["", En, Gn], j = () => ["auto", Ds, ae], X = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], K = () => ["solid", "dashed", "dotted", "double", "none"], J = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], P = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], D = () => ["", "0", ae], Q = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], re = () => [Ds, ae]; return { cacheSize: 500, separator: ":", theme: { colors: [To], spacing: [En, Gn], blur: ["none", "", qn, ae], brightness: re(), borderColor: [e], borderRadius: ["none", "", "full", qn, ae], borderSpacing: O(), borderWidth: z(), contrast: re(), grayscale: D(), hueRotate: re(), invert: D(), gap: O(), gradientColorStops: [e], gradientColorStopPositions: [ZC, Gn], inset: Y(), margin: Y(), opacity: re(), padding: O(), saturate: re(), scale: re(), sepia: D(), skew: re(), space: O(), translate: O() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", ae] }], container: ["container"], columns: [{ columns: [qn] }], "break-after": [{ "break-after": Q() }], "break-before": [{ "break-before": Q() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...X(), ae] }], overflow: [{ overflow: V() }], "overflow-x": [{ "overflow-x": V() }], "overflow-y": [{ "overflow-y": V() }], overscroll: [{ overscroll: F() }], "overscroll-x": [{ "overscroll-x": F() }], "overscroll-y": [{ "overscroll-y": F() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [m] }], "inset-x": [{ "inset-x": [m] }], "inset-y": [{ "inset-y": [m] }], start: [{ start: [m] }], end: [{ end: [m] }], top: [{ top: [m] }], right: [{ right: [m] }], bottom: [{ bottom: [m] }], left: [{ left: [m] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Eo, ae] }], basis: [{ basis: Y() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", ae] }], grow: [{ grow: D() }], shrink: [{ shrink: D() }], order: [{ order: ["first", "last", "none", Eo, ae] }], "grid-cols": [{ "grid-cols": [To] }], "col-start-end": [{ col: ["auto", { span: ["full", Eo, ae] }, ae] }], "col-start": [{ "col-start": j() }], "col-end": [{ "col-end": j() }], "grid-rows": [{ "grid-rows": [To] }], "row-start-end": [{ row: ["auto", { span: [Eo, ae] }, ae] }], "row-start": [{ "row-start": j() }], "row-end": [{ "row-end": j() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", ae] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", ae] }], gap: [{ gap: [h] }], "gap-x": [{ "gap-x": [h] }], "gap-y": [{ "gap-y": [h] }], "justify-content": [{ justify: ["normal", ...P()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...P(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...P(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [f] }], px: [{ px: [f] }], py: [{ py: [f] }], ps: [{ ps: [f] }], pe: [{ pe: [f] }], pt: [{ pt: [f] }], pr: [{ pr: [f] }], pb: [{ pb: [f] }], pl: [{ pl: [f] }], m: [{ m: [x] }], mx: [{ mx: [x] }], my: [{ my: [x] }], ms: [{ ms: [x] }], me: [{ me: [x] }], mt: [{ mt: [x] }], mr: [{ mr: [x] }], mb: [{ mb: [x] }], ml: [{ ml: [x] }], "space-x": [{ "space-x": [b] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [b] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ae, t] }], "min-w": [{ "min-w": [ae, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [ae, t, "none", "full", "min", "max", "fit", "prose", { screen: [qn] }, qn] }], h: [{ h: [ae, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [ae, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [ae, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [ae, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", qn, Gn] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Bu] }], "font-family": [{ font: [To] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ae] }], "line-clamp": [{ "line-clamp": ["none", Ds, Bu] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", En, ae] }], "list-image": [{ "list-image": ["none", ae] }], "list-style-type": [{ list: ["none", "disc", "decimal", ae] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [g] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [g] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...K(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", En, Gn] }], "underline-offset": [{ "underline-offset": ["auto", En, ae] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: O() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ae] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", ae] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [g] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...X(), GC] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", QC] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, YC] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [S] }], "gradient-via-pos": [{ via: [S] }], "gradient-to-pos": [{ to: [S] }], "gradient-from": [{ from: [w] }], "gradient-via": [{ via: [w] }], "gradient-to": [{ to: [w] }], rounded: [{ rounded: [o] }], "rounded-s": [{ "rounded-s": [o] }], "rounded-e": [{ "rounded-e": [o] }], "rounded-t": [{ "rounded-t": [o] }], "rounded-r": [{ "rounded-r": [o] }], "rounded-b": [{ "rounded-b": [o] }], "rounded-l": [{ "rounded-l": [o] }], "rounded-ss": [{ "rounded-ss": [o] }], "rounded-se": [{ "rounded-se": [o] }], "rounded-ee": [{ "rounded-ee": [o] }], "rounded-es": [{ "rounded-es": [o] }], "rounded-tl": [{ "rounded-tl": [o] }], "rounded-tr": [{ "rounded-tr": [o] }], "rounded-br": [{ "rounded-br": [o] }], "rounded-bl": [{ "rounded-bl": [o] }], "border-w": [{ border: [a] }], "border-w-x": [{ "border-x": [a] }], "border-w-y": [{ "border-y": [a] }], "border-w-s": [{ "border-s": [a] }], "border-w-e": [{ "border-e": [a] }], "border-w-t": [{ "border-t": [a] }], "border-w-r": [{ "border-r": [a] }], "border-w-b": [{ "border-b": [a] }], "border-w-l": [{ "border-l": [a] }], "border-opacity": [{ "border-opacity": [g] }], "border-style": [{ border: [...K(), "hidden"] }], "divide-x": [{ "divide-x": [a] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [a] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [g] }], "divide-style": [{ divide: K() }], "border-color": [{ border: [s] }], "border-color-x": [{ "border-x": [s] }], "border-color-y": [{ "border-y": [s] }], "border-color-s": [{ "border-s": [s] }], "border-color-e": [{ "border-e": [s] }], "border-color-t": [{ "border-t": [s] }], "border-color-r": [{ "border-r": [s] }], "border-color-b": [{ "border-b": [s] }], "border-color-l": [{ "border-l": [s] }], "divide-color": [{ divide: [s] }], "outline-style": [{ outline: ["", ...K()] }], "outline-offset": [{ "outline-offset": [En, ae] }], "outline-w": [{ outline: [En, Gn] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: z() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [g] }], "ring-offset-w": [{ "ring-offset": [En, Gn] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", qn, XC] }], "shadow-color": [{ shadow: [To] }], opacity: [{ opacity: [g] }], "mix-blend": [{ "mix-blend": [...J(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": J() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", qn, ae] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [c] }], invert: [{ invert: [p] }], saturate: [{ saturate: [y] }], sepia: [{ sepia: [k] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [c] }], "backdrop-invert": [{ "backdrop-invert": [p] }], "backdrop-opacity": [{ "backdrop-opacity": [g] }], "backdrop-saturate": [{ "backdrop-saturate": [y] }], "backdrop-sepia": [{ "backdrop-sepia": [k] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [i] }], "border-spacing-x": [{ "border-spacing-x": [i] }], "border-spacing-y": [{ "border-spacing-y": [i] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ae] }], duration: [{ duration: re() }], ease: [{ ease: ["linear", "in", "out", "in-out", ae] }], delay: [{ delay: re() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", ae] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [_] }], "scale-x": [{ "scale-x": [_] }], "scale-y": [{ "scale-y": [_] }], rotate: [{ rotate: [Eo, ae] }], "translate-x": [{ "translate-x": [R] }], "translate-y": [{ "translate-y": [R] }], "skew-x": [{ "skew-x": [T] }], "skew-y": [{ "skew-y": [T] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ae] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ae] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": O() }], "scroll-mx": [{ "scroll-mx": O() }], "scroll-my": [{ "scroll-my": O() }], "scroll-ms": [{ "scroll-ms": O() }], "scroll-me": [{ "scroll-me": O() }], "scroll-mt": [{ "scroll-mt": O() }], "scroll-mr": [{ "scroll-mr": O() }], "scroll-mb": [{ "scroll-mb": O() }], "scroll-ml": [{ "scroll-ml": O() }], "scroll-p": [{ "scroll-p": O() }], "scroll-px": [{ "scroll-px": O() }], "scroll-py": [{ "scroll-py": O() }], "scroll-ps": [{ "scroll-ps": O() }], "scroll-pe": [{ "scroll-pe": O() }], "scroll-pt": [{ "scroll-pt": O() }], "scroll-pr": [{ "scroll-pr": O() }], "scroll-pb": [{ "scroll-pb": O() }], "scroll-pl": [{ "scroll-pl": O() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", ae] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [En, Gn, Bu] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, rk = FC(nk); function Se(...e) { return rk(Cy(e)) } const sk = yC, Oy = v.forwardRef(({ className: e, ...t }, n) => d.jsx(vy, { ref: n, className: Se("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e), ...t })); Oy.displayName = vy.displayName; const ok = _f("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground" } }, defaultVariants: { variant: "default" } }), My = v.forwardRef(({ className: e, variant: t, ...n }, r) => d.jsx(gy, { ref: r, className: Se(ok({ variant: t }), e), ...n })); My.displayName = gy.displayName; const ik = v.forwardRef(({ className: e, ...t }, n) => d.jsx(wy, { ref: n, className: Se("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", e), ...t })); ik.displayName = wy.displayName; const Iy = v.forwardRef(({ className: e, ...t }, n) => d.jsx(Sy, { ref: n, className: Se("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e), "toast-close": "", ...t, children: d.jsx(Ty, { className: "h-4 w-4" }) })); Iy.displayName = Sy.displayName; const Ly = v.forwardRef(({ className: e, ...t }, n) => d.jsx(yy, { ref: n, className: Se("text-sm font-semibold", e), ...t })); Ly.displayName = yy.displayName; const Dy = v.forwardRef(({ className: e, ...t }, n) => d.jsx(xy, { ref: n, className: Se("text-sm opacity-90", e), ...t })); Dy.displayName = xy.displayName; function ak() { const { toasts: e } = Qg(); return d.jsxs(sk, { children: [e.map(function ({ id: t, title: n, description: r, action: s, ...o }) { return d.jsxs(My, { ...o, children: [d.jsxs("div", { className: "grid gap-1", children: [n && d.jsx(Ly, { children: n }), r && d.jsx(Dy, { children: r })] }), s, d.jsx(Iy, {})] }, t) }), d.jsx(Oy, {})] }) } var lk = Cm[" useId ".trim().toString()] || (() => { }), uk = 0; function kf(e) { const [t, n] = v.useState(lk()); return lt(() => { n(r => r ?? String(uk++)) }, [e]), t ? `radix-${t}` : "" } const ck = ["top", "right", "bottom", "left"], Cr = Math.min, Rt = Math.max, dl = Math.round, ma = Math.floor, wn = e => ({ x: e, y: e }), dk = { left: "right", right: "left", bottom: "top", top: "bottom" }, fk = { start: "end", end: "start" }; function td(e, t, n) { return Rt(e, Cr(t, n)) } function Un(e, t) { return typeof e == "function" ? e(t) : e } function Bn(e) { return e.split("-")[0] } function mo(e) { return e.split("-")[1] } function bf(e) { return e === "x" ? "y" : "x" } function Ef(e) { return e === "y" ? "height" : "width" } function kr(e) { return ["top", "bottom"].includes(Bn(e)) ? "y" : "x" } function Tf(e) { return bf(kr(e)) } function pk(e, t, n) { n === void 0 && (n = !1); const r = mo(e), s = Tf(e), o = Ef(s); let i = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return t.reference[o] > t.floating[o] && (i = fl(i)), [i, fl(i)] } function hk(e) { const t = fl(e); return [nd(e), t, nd(t)] } function nd(e) { return e.replace(/start|end/g, t => fk[t]) } function mk(e, t, n) { const r = ["left", "right"], s = ["right", "left"], o = ["top", "bottom"], i = ["bottom", "top"]; switch (e) { case "top": case "bottom": return n ? t ? s : r : t ? r : s; case "left": case "right": return t ? o : i; default: return [] } } function vk(e, t, n, r) { const s = mo(e); let o = mk(Bn(e), n === "start", r); return s && (o = o.map(i => i + "-" + s), t && (o = o.concat(o.map(nd)))), o } function fl(e) { return e.replace(/left|right|bottom|top/g, t => dk[t]) } function gk(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function Fy(e) { return typeof e != "number" ? gk(e) : { top: e, right: e, bottom: e, left: e } } function pl(e) { const { x: t, y: n, width: r, height: s } = e; return { width: r, height: s, top: n, left: t, right: t + r, bottom: n + s, x: t, y: n } } function _h(e, t, n) { let { reference: r, floating: s } = e; const o = kr(t), i = Tf(t), a = Ef(i), l = Bn(t), u = o === "y", c = r.x + r.width / 2 - s.width / 2, p = r.y + r.height / 2 - s.height / 2, h = r[a] / 2 - s[a] / 2; let w; switch (l) { case "top": w = { x: c, y: r.y - s.height }; break; case "bottom": w = { x: c, y: r.y + r.height }; break; case "right": w = { x: r.x + r.width, y: p }; break; case "left": w = { x: r.x - s.width, y: p }; break; default: w = { x: r.x, y: r.y } }switch (mo(t)) { case "start": w[i] -= h * (n && u ? -1 : 1); break; case "end": w[i] += h * (n && u ? -1 : 1); break }return w } const yk = async (e, t, n) => { const { placement: r = "bottom", strategy: s = "absolute", middleware: o = [], platform: i } = n, a = o.filter(Boolean), l = await (i.isRTL == null ? void 0 : i.isRTL(t)); let u = await i.getElementRects({ reference: e, floating: t, strategy: s }), { x: c, y: p } = _h(u, r, l), h = r, w = {}, S = 0; for (let m = 0; m < a.length; m++) { const { name: x, fn: g } = a[m], { x: f, y, data: _, reset: k } = await g({ x: c, y: p, initialPlacement: r, placement: h, strategy: s, middlewareData: w, rects: u, platform: i, elements: { reference: e, floating: t } }); c = f ?? c, p = y ?? p, w = { ...w, [x]: { ...w[x], ..._ } }, k && S <= 50 && (S++, typeof k == "object" && (k.placement && (h = k.placement), k.rects && (u = k.rects === !0 ? await i.getElementRects({ reference: e, floating: t, strategy: s }) : k.rects), { x: c, y: p } = _h(u, h, l)), m = -1) } return { x: c, y: p, placement: h, strategy: s, middlewareData: w } }; async function xi(e, t) { var n; t === void 0 && (t = {}); const { x: r, y: s, platform: o, rects: i, elements: a, strategy: l } = e, { boundary: u = "clippingAncestors", rootBoundary: c = "viewport", elementContext: p = "floating", altBoundary: h = !1, padding: w = 0 } = Un(t, e), S = Fy(w), x = a[h ? p === "floating" ? "reference" : "floating" : p], g = pl(await o.getClippingRect({ element: (n = await (o.isElement == null ? void 0 : o.isElement(x))) == null || n ? x : x.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)), boundary: u, rootBoundary: c, strategy: l })), f = p === "floating" ? { x: r, y: s, width: i.floating.width, height: i.floating.height } : i.reference, y = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), _ = await (o.isElement == null ? void 0 : o.isElement(y)) ? await (o.getScale == null ? void 0 : o.getScale(y)) || { x: 1, y: 1 } : { x: 1, y: 1 }, k = pl(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: a, rect: f, offsetParent: y, strategy: l }) : f); return { top: (g.top - k.top + S.top) / _.y, bottom: (k.bottom - g.bottom + S.bottom) / _.y, left: (g.left - k.left + S.left) / _.x, right: (k.right - g.right + S.right) / _.x } } const xk = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: r, placement: s, rects: o, platform: i, elements: a, middlewareData: l } = t, { element: u, padding: c = 0 } = Un(e, t) || {}; if (u == null) return {}; const p = Fy(c), h = { x: n, y: r }, w = Tf(s), S = Ef(w), m = await i.getDimensions(u), x = w === "y", g = x ? "top" : "left", f = x ? "bottom" : "right", y = x ? "clientHeight" : "clientWidth", _ = o.reference[S] + o.reference[w] - h[w] - o.floating[S], k = h[w] - o.reference[w], T = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u)); let b = T ? T[y] : 0; (!b || !await (i.isElement == null ? void 0 : i.isElement(T))) && (b = a.floating[y] || o.floating[S]); const R = _ / 2 - k / 2, F = b / 2 - m[S] / 2 - 1, V = Cr(p[g], F), Y = Cr(p[f], F), O = V, z = b - m[S] - Y, j = b / 2 - m[S] / 2 + R, X = td(O, j, z), K = !l.arrow && mo(s) != null && j !== X && o.reference[S] / 2 - (j < O ? V : Y) - m[S] / 2 < 0, J = K ? j < O ? j - O : j - z : 0; return { [w]: h[w] + J, data: { [w]: X, centerOffset: j - X - J, ...K && { alignmentOffset: J } }, reset: K } } }), wk = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) { var n, r; const { placement: s, middlewareData: o, rects: i, initialPlacement: a, platform: l, elements: u } = t, { mainAxis: c = !0, crossAxis: p = !0, fallbackPlacements: h, fallbackStrategy: w = "bestFit", fallbackAxisSideDirection: S = "none", flipAlignment: m = !0, ...x } = Un(e, t); if ((n = o.arrow) != null && n.alignmentOffset) return {}; const g = Bn(s), f = kr(a), y = Bn(a) === a, _ = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), k = h || (y || !m ? [fl(a)] : hk(a)), T = S !== "none"; !h && T && k.push(...vk(a, m, S, _)); const b = [a, ...k], R = await xi(t, x), F = []; let V = ((r = o.flip) == null ? void 0 : r.overflows) || []; if (c && F.push(R[g]), p) { const j = pk(s, i, _); F.push(R[j[0]], R[j[1]]) } if (V = [...V, { placement: s, overflows: F }], !F.every(j => j <= 0)) { var Y, O; const j = (((Y = o.flip) == null ? void 0 : Y.index) || 0) + 1, X = b[j]; if (X) return { data: { index: j, overflows: V }, reset: { placement: X } }; let K = (O = V.filter(J => J.overflows[0] <= 0).sort((J, P) => J.overflows[1] - P.overflows[1])[0]) == null ? void 0 : O.placement; if (!K) switch (w) { case "bestFit": { var z; const J = (z = V.filter(P => { if (T) { const D = kr(P.placement); return D === f || D === "y" } return !0 }).map(P => [P.placement, P.overflows.filter(D => D > 0).reduce((D, Q) => D + Q, 0)]).sort((P, D) => P[1] - D[1])[0]) == null ? void 0 : z[0]; J && (K = J); break } case "initialPlacement": K = a; break }if (s !== K) return { reset: { placement: K } } } return {} } } }; function Ch(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function kh(e) { return ck.some(t => e[t] >= 0) } const Sk = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: n } = t, { strategy: r = "referenceHidden", ...s } = Un(e, t); switch (r) { case "referenceHidden": { const o = await xi(t, { ...s, elementContext: "reference" }), i = Ch(o, n.reference); return { data: { referenceHiddenOffsets: i, referenceHidden: kh(i) } } } case "escaped": { const o = await xi(t, { ...s, altBoundary: !0 }), i = Ch(o, n.floating); return { data: { escapedOffsets: i, escaped: kh(i) } } } default: return {} } } } }; async function _k(e, t) { const { placement: n, platform: r, elements: s } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), i = Bn(n), a = mo(n), l = kr(n) === "y", u = ["left", "top"].includes(i) ? -1 : 1, c = o && l ? -1 : 1, p = Un(t, e); let { mainAxis: h, crossAxis: w, alignmentAxis: S } = typeof p == "number" ? { mainAxis: p, crossAxis: 0, alignmentAxis: null } : { mainAxis: p.mainAxis || 0, crossAxis: p.crossAxis || 0, alignmentAxis: p.alignmentAxis }; return a && typeof S == "number" && (w = a === "end" ? S * -1 : S), l ? { x: w * c, y: h * u } : { x: h * u, y: w * c } } const Ck = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { var n, r; const { x: s, y: o, placement: i, middlewareData: a } = t, l = await _k(t, e); return i === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : { x: s + l.x, y: o + l.y, data: { ...l, placement: i } } } } }, kk = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: s } = t, { mainAxis: o = !0, crossAxis: i = !1, limiter: a = { fn: x => { let { x: g, y: f } = x; return { x: g, y: f } } }, ...l } = Un(e, t), u = { x: n, y: r }, c = await xi(t, l), p = kr(Bn(s)), h = bf(p); let w = u[h], S = u[p]; if (o) { const x = h === "y" ? "top" : "left", g = h === "y" ? "bottom" : "right", f = w + c[x], y = w - c[g]; w = td(f, w, y) } if (i) { const x = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", f = S + c[x], y = S - c[g]; S = td(f, S, y) } const m = a.fn({ ...t, [h]: w, [p]: S }); return { ...m, data: { x: m.x - n, y: m.y - r, enabled: { [h]: o, [p]: i } } } } } }, bk = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: s, rects: o, middlewareData: i } = t, { offset: a = 0, mainAxis: l = !0, crossAxis: u = !0 } = Un(e, t), c = { x: n, y: r }, p = kr(s), h = bf(p); let w = c[h], S = c[p]; const m = Un(a, t), x = typeof m == "number" ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m }; if (l) { const y = h === "y" ? "height" : "width", _ = o.reference[h] - o.floating[y] + x.mainAxis, k = o.reference[h] + o.reference[y] - x.mainAxis; w < _ ? w = _ : w > k && (w = k) } if (u) { var g, f; const y = h === "y" ? "width" : "height", _ = ["top", "left"].includes(Bn(s)), k = o.reference[p] - o.floating[y] + (_ && ((g = i.offset) == null ? void 0 : g[p]) || 0) + (_ ? 0 : x.crossAxis), T = o.reference[p] + o.reference[y] + (_ ? 0 : ((f = i.offset) == null ? void 0 : f[p]) || 0) - (_ ? x.crossAxis : 0); S < k ? S = k : S > T && (S = T) } return { [h]: w, [p]: S } } } }, Ek = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) { var n, r; const { placement: s, rects: o, platform: i, elements: a } = t, { apply: l = () => { }, ...u } = Un(e, t), c = await xi(t, u), p = Bn(s), h = mo(s), w = kr(s) === "y", { width: S, height: m } = o.floating; let x, g; p === "top" || p === "bottom" ? (x = p, g = h === (await (i.isRTL == null ? void 0 : i.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (g = p, x = h === "end" ? "top" : "bottom"); const f = m - c.top - c.bottom, y = S - c.left - c.right, _ = Cr(m - c[x], f), k = Cr(S - c[g], y), T = !t.middlewareData.shift; let b = _, R = k; if ((n = t.middlewareData.shift) != null && n.enabled.x && (R = y), (r = t.middlewareData.shift) != null && r.enabled.y && (b = f), T && !h) { const V = Rt(c.left, 0), Y = Rt(c.right, 0), O = Rt(c.top, 0), z = Rt(c.bottom, 0); w ? R = S - 2 * (V !== 0 || Y !== 0 ? V + Y : Rt(c.left, c.right)) : b = m - 2 * (O !== 0 || z !== 0 ? O + z : Rt(c.top, c.bottom)) } await l({ ...t, availableWidth: R, availableHeight: b }); const F = await i.getDimensions(a.floating); return S !== F.width || m !== F.height ? { reset: { rects: !0 } } : {} } } }; function Ql() { return typeof window < "u" } function vo(e) { return Vy(e) ? (e.nodeName || "").toLowerCase() : "#document" } function Ot(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function bn(e) { var t; return (t = (Vy(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function Vy(e) { return Ql() ? e instanceof Node || e instanceof Ot(e).Node : !1 } function an(e) { return Ql() ? e instanceof Element || e instanceof Ot(e).Element : !1 } function _n(e) { return Ql() ? e instanceof HTMLElement || e instanceof Ot(e).HTMLElement : !1 } function bh(e) { return !Ql() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ot(e).ShadowRoot } function Wi(e) { const { overflow: t, overflowX: n, overflowY: r, display: s } = ln(e); return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(s) } function Tk(e) { return ["table", "td", "th"].includes(vo(e)) } function Gl(e) { return [":popover-open", ":modal"].some(t => { try { return e.matches(t) } catch { return !1 } }) } function Nf(e) { const t = Pf(), n = an(e) ? ln(e) : e; return ["transform", "translate", "scale", "rotate", "perspective"].some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r)) } function Nk(e) { let t = br(e); for (; _n(t) && !so(t);) { if (Nf(t)) return t; if (Gl(t)) return null; t = br(t) } return null } function Pf() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function so(e) { return ["html", "body", "#document"].includes(vo(e)) } function ln(e) { return Ot(e).getComputedStyle(e) } function ql(e) { return an(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function br(e) { if (vo(e) === "html") return e; const t = e.assignedSlot || e.parentNode || bh(e) && e.host || bn(e); return bh(t) ? t.host : t } function zy(e) { const t = br(e); return so(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : _n(t) && Wi(t) ? t : zy(t) } function wi(e, t, n) { var r; t === void 0 && (t = []), n === void 0 && (n = !0); const s = zy(e), o = s === ((r = e.ownerDocument) == null ? void 0 : r.body), i = Ot(s); if (o) { const a = rd(i); return t.concat(i, i.visualViewport || [], Wi(s) ? s : [], a && n ? wi(a) : []) } return t.concat(s, wi(s, [], n)) } function rd(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function $y(e) { const t = ln(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const s = _n(e), o = s ? e.offsetWidth : n, i = s ? e.offsetHeight : r, a = dl(n) !== o || dl(r) !== i; return a && (n = o, r = i), { width: n, height: r, $: a } } function Rf(e) { return an(e) ? e : e.contextElement } function Fs(e) { const t = Rf(e); if (!_n(t)) return wn(1); const n = t.getBoundingClientRect(), { width: r, height: s, $: o } = $y(t); let i = (o ? dl(n.width) : n.width) / r, a = (o ? dl(n.height) : n.height) / s; return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: i, y: a } } const Pk = wn(0); function Uy(e) { const t = Ot(e); return !Pf() || !t.visualViewport ? Pk : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function Rk(e, t, n) { return t === void 0 && (t = !1), !n || t && n !== Ot(e) ? !1 : t } function ts(e, t, n, r) { t === void 0 && (t = !1), n === void 0 && (n = !1); const s = e.getBoundingClientRect(), o = Rf(e); let i = wn(1); t && (r ? an(r) && (i = Fs(r)) : i = Fs(e)); const a = Rk(o, n, r) ? Uy(o) : wn(0); let l = (s.left + a.x) / i.x, u = (s.top + a.y) / i.y, c = s.width / i.x, p = s.height / i.y; if (o) { const h = Ot(o), w = r && an(r) ? Ot(r) : r; let S = h, m = rd(S); for (; m && r && w !== S;) { const x = Fs(m), g = m.getBoundingClientRect(), f = ln(m), y = g.left + (m.clientLeft + parseFloat(f.paddingLeft)) * x.x, _ = g.top + (m.clientTop + parseFloat(f.paddingTop)) * x.y; l *= x.x, u *= x.y, c *= x.x, p *= x.y, l += y, u += _, S = Ot(m), m = rd(S) } } return pl({ width: c, height: p, x: l, y: u }) } function Af(e, t) { const n = ql(e).scrollLeft; return t ? t.left + n : ts(bn(e)).left + n } function By(e, t, n) { n === void 0 && (n = !1); const r = e.getBoundingClientRect(), s = r.left + t.scrollLeft - (n ? 0 : Af(e, r)), o = r.top + t.scrollTop; return { x: s, y: o } } function Ak(e) { let { elements: t, rect: n, offsetParent: r, strategy: s } = e; const o = s === "fixed", i = bn(r), a = t ? Gl(t.floating) : !1; if (r === i || a && o) return n; let l = { scrollLeft: 0, scrollTop: 0 }, u = wn(1); const c = wn(0), p = _n(r); if ((p || !p && !o) && ((vo(r) !== "body" || Wi(i)) && (l = ql(r)), _n(r))) { const w = ts(r); u = Fs(r), c.x = w.x + r.clientLeft, c.y = w.y + r.clientTop } const h = i && !p && !o ? By(i, l, !0) : wn(0); return { width: n.width * u.x, height: n.height * u.y, x: n.x * u.x - l.scrollLeft * u.x + c.x + h.x, y: n.y * u.y - l.scrollTop * u.y + c.y + h.y } } function jk(e) { return Array.from(e.getClientRects()) } function Ok(e) { const t = bn(e), n = ql(e), r = e.ownerDocument.body, s = Rt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = Rt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let i = -n.scrollLeft + Af(e); const a = -n.scrollTop; return ln(r).direction === "rtl" && (i += Rt(t.clientWidth, r.clientWidth) - s), { width: s, height: o, x: i, y: a } } function Mk(e, t) { const n = Ot(e), r = bn(e), s = n.visualViewport; let o = r.clientWidth, i = r.clientHeight, a = 0, l = 0; if (s) { o = s.width, i = s.height; const u = Pf(); (!u || u && t === "fixed") && (a = s.offsetLeft, l = s.offsetTop) } return { width: o, height: i, x: a, y: l } } function Ik(e, t) { const n = ts(e, !0, t === "fixed"), r = n.top + e.clientTop, s = n.left + e.clientLeft, o = _n(e) ? Fs(e) : wn(1), i = e.clientWidth * o.x, a = e.clientHeight * o.y, l = s * o.x, u = r * o.y; return { width: i, height: a, x: l, y: u } } function Eh(e, t, n) { let r; if (t === "viewport") r = Mk(e, n); else if (t === "document") r = Ok(bn(e)); else if (an(t)) r = Ik(t, n); else { const s = Uy(e); r = { x: t.x - s.x, y: t.y - s.y, width: t.width, height: t.height } } return pl(r) } function Wy(e, t) { const n = br(e); return n === t || !an(n) || so(n) ? !1 : ln(n).position === "fixed" || Wy(n, t) } function Lk(e, t) { const n = t.get(e); if (n) return n; let r = wi(e, [], !1).filter(a => an(a) && vo(a) !== "body"), s = null; const o = ln(e).position === "fixed"; let i = o ? br(e) : e; for (; an(i) && !so(i);) { const a = ln(i), l = Nf(i); !l && a.position === "fixed" && (s = null), (o ? !l && !s : !l && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || Wi(i) && !l && Wy(e, i)) ? r = r.filter(c => c !== i) : s = a, i = br(i) } return t.set(e, r), r } function Dk(e) { let { element: t, boundary: n, rootBoundary: r, strategy: s } = e; const i = [...n === "clippingAncestors" ? Gl(t) ? [] : Lk(t, this._c) : [].concat(n), r], a = i[0], l = i.reduce((u, c) => { const p = Eh(t, c, s); return u.top = Rt(p.top, u.top), u.right = Cr(p.right, u.right), u.bottom = Cr(p.bottom, u.bottom), u.left = Rt(p.left, u.left), u }, Eh(t, a, s)); return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top } } function Fk(e) { const { width: t, height: n } = $y(e); return { width: t, height: n } } function Vk(e, t, n) { const r = _n(t), s = bn(t), o = n === "fixed", i = ts(e, !0, o, t); let a = { scrollLeft: 0, scrollTop: 0 }; const l = wn(0); if (r || !r && !o) if ((vo(t) !== "body" || Wi(s)) && (a = ql(t)), r) { const h = ts(t, !0, o, t); l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop } else s && (l.x = Af(s)); const u = s && !r && !o ? By(s, a) : wn(0), c = i.left + a.scrollLeft - l.x - u.x, p = i.top + a.scrollTop - l.y - u.y; return { x: c, y: p, width: i.width, height: i.height } } function Wu(e) { return ln(e).position === "static" } function Th(e, t) { if (!_n(e) || ln(e).position === "fixed") return null; if (t) return t(e); let n = e.offsetParent; return bn(e) === n && (n = n.ownerDocument.body), n } function Hy(e, t) { const n = Ot(e); if (Gl(e)) return n; if (!_n(e)) { let s = br(e); for (; s && !so(s);) { if (an(s) && !Wu(s)) return s; s = br(s) } return n } let r = Th(e, t); for (; r && Tk(r) && Wu(r);)r = Th(r, t); return r && so(r) && Wu(r) && !Nf(r) ? n : r || Nk(e) || n } const zk = async function (e) { const t = this.getOffsetParent || Hy, n = this.getDimensions, r = await n(e.floating); return { reference: Vk(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }; function $k(e) { return ln(e).direction === "rtl" } const Uk = { convertOffsetParentRelativeRectToViewportRelativeRect: Ak, getDocumentElement: bn, getClippingRect: Dk, getOffsetParent: Hy, getElementRects: zk, getClientRects: jk, getDimensions: Fk, getScale: Fs, isElement: an, isRTL: $k }; function Zy(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function Bk(e, t) { let n = null, r; const s = bn(e); function o() { var a; clearTimeout(r), (a = n) == null || a.disconnect(), n = null } function i(a, l) { a === void 0 && (a = !1), l === void 0 && (l = 1), o(); const u = e.getBoundingClientRect(), { left: c, top: p, width: h, height: w } = u; if (a || t(), !h || !w) return; const S = ma(p), m = ma(s.clientWidth - (c + h)), x = ma(s.clientHeight - (p + w)), g = ma(c), y = { rootMargin: -S + "px " + -m + "px " + -x + "px " + -g + "px", threshold: Rt(0, Cr(1, l)) || 1 }; let _ = !0; function k(T) { const b = T[0].intersectionRatio; if (b !== l) { if (!_) return i(); b ? i(!1, b) : r = setTimeout(() => { i(!1, 1e-7) }, 1e3) } b === 1 && !Zy(u, e.getBoundingClientRect()) && i(), _ = !1 } try { n = new IntersectionObserver(k, { ...y, root: s.ownerDocument }) } catch { n = new IntersectionObserver(k, y) } n.observe(e) } return i(!0), o } function Wk(e, t, n, r) { r === void 0 && (r = {}); const { ancestorScroll: s = !0, ancestorResize: o = !0, elementResize: i = typeof ResizeObserver == "function", layoutShift: a = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r, u = Rf(e), c = s || o ? [...u ? wi(u) : [], ...wi(t)] : []; c.forEach(g => { s && g.addEventListener("scroll", n, { passive: !0 }), o && g.addEventListener("resize", n) }); const p = u && a ? Bk(u, n) : null; let h = -1, w = null; i && (w = new ResizeObserver(g => { let [f] = g; f && f.target === u && w && (w.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => { var y; (y = w) == null || y.observe(t) })), n() }), u && !l && w.observe(u), w.observe(t)); let S, m = l ? ts(e) : null; l && x(); function x() { const g = ts(e); m && !Zy(m, g) && n(), m = g, S = requestAnimationFrame(x) } return n(), () => { var g; c.forEach(f => { s && f.removeEventListener("scroll", n), o && f.removeEventListener("resize", n) }), p == null || p(), (g = w) == null || g.disconnect(), w = null, l && cancelAnimationFrame(S) } } const Hk = Ck, Zk = kk, Kk = wk, Qk = Ek, Gk = Sk, Nh = xk, qk = bk, Yk = (e, t, n) => { const r = new Map, s = { platform: Uk, ...n }, o = { ...s.platform, _c: r }; return yk(e, t, { ...s, platform: o }) }; var La = typeof document < "u" ? v.useLayoutEffect : v.useEffect; function hl(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if (typeof e == "function" && e.toString() === t.toString()) return !0; let n, r, s; if (e && t && typeof e == "object") { if (Array.isArray(e)) { if (n = e.length, n !== t.length) return !1; for (r = n; r-- !== 0;)if (!hl(e[r], t[r])) return !1; return !0 } if (s = Object.keys(e), n = s.length, n !== Object.keys(t).length) return !1; for (r = n; r-- !== 0;)if (!{}.hasOwnProperty.call(t, s[r])) return !1; for (r = n; r-- !== 0;) { const o = s[r]; if (!(o === "_owner" && e.$$typeof) && !hl(e[o], t[o])) return !1 } return !0 } return e !== e && t !== t } function Ky(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function Ph(e, t) { const n = Ky(e); return Math.round(t * n) / n } function Hu(e) { const t = v.useRef(e); return La(() => { t.current = e }), t } function Xk(e) { e === void 0 && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: s, elements: { reference: o, floating: i } = {}, transform: a = !0, whileElementsMounted: l, open: u } = e, [c, p] = v.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [h, w] = v.useState(r); hl(h, r) || w(r); const [S, m] = v.useState(null), [x, g] = v.useState(null), f = v.useCallback(P => { P !== T.current && (T.current = P, m(P)) }, []), y = v.useCallback(P => { P !== b.current && (b.current = P, g(P)) }, []), _ = o || S, k = i || x, T = v.useRef(null), b = v.useRef(null), R = v.useRef(c), F = l != null, V = Hu(l), Y = Hu(s), O = Hu(u), z = v.useCallback(() => { if (!T.current || !b.current) return; const P = { placement: t, strategy: n, middleware: h }; Y.current && (P.platform = Y.current), Yk(T.current, b.current, P).then(D => { const Q = { ...D, isPositioned: O.current !== !1 }; j.current && !hl(R.current, Q) && (R.current = Q, ls.flushSync(() => { p(Q) })) }) }, [h, t, n, Y, O]); La(() => { u === !1 && R.current.isPositioned && (R.current.isPositioned = !1, p(P => ({ ...P, isPositioned: !1 }))) }, [u]); const j = v.useRef(!1); La(() => (j.current = !0, () => { j.current = !1 }), []), La(() => { if (_ && (T.current = _), k && (b.current = k), _ && k) { if (V.current) return V.current(_, k, z); z() } }, [_, k, z, V, F]); const X = v.useMemo(() => ({ reference: T, floating: b, setReference: f, setFloating: y }), [f, y]), K = v.useMemo(() => ({ reference: _, floating: k }), [_, k]), J = v.useMemo(() => { const P = { position: n, left: 0, top: 0 }; if (!K.floating) return P; const D = Ph(K.floating, c.x), Q = Ph(K.floating, c.y); return a ? { ...P, transform: "translate(" + D + "px, " + Q + "px)", ...Ky(K.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: D, top: Q } }, [n, a, K.floating, c.x, c.y]); return v.useMemo(() => ({ ...c, update: z, refs: X, elements: K, floatingStyles: J }), [c, z, X, K, J]) } const Jk = e => { function t(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: e, fn(n) { const { element: r, padding: s } = typeof e == "function" ? e(n) : e; return r && t(r) ? r.current != null ? Nh({ element: r.current, padding: s }).fn(n) : {} : r ? Nh({ element: r, padding: s }).fn(n) : {} } } }, eb = (e, t) => ({ ...Hk(e), options: [e, t] }), tb = (e, t) => ({ ...Zk(e), options: [e, t] }), nb = (e, t) => ({ ...qk(e), options: [e, t] }), rb = (e, t) => ({ ...Kk(e), options: [e, t] }), sb = (e, t) => ({ ...Qk(e), options: [e, t] }), ob = (e, t) => ({ ...Gk(e), options: [e, t] }), ib = (e, t) => ({ ...Jk(e), options: [e, t] }); var ab = "Arrow", Qy = v.forwardRef((e, t) => { const { children: n, width: r = 10, height: s = 5, ...o } = e; return d.jsx(_e.svg, { ...o, ref: t, width: r, height: s, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? n : d.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); Qy.displayName = ab; var lb = Qy; function ub(e) { const [t, n] = v.useState(void 0); return lt(() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const r = new ResizeObserver(s => { if (!Array.isArray(s) || !s.length) return; const o = s[0]; let i, a; if ("borderBoxSize" in o) { const l = o.borderBoxSize, u = Array.isArray(l) ? l[0] : l; i = u.inlineSize, a = u.blockSize } else i = e.offsetWidth, a = e.offsetHeight; n({ width: i, height: a }) }); return r.observe(e, { box: "border-box" }), () => r.unobserve(e) } else n(void 0) }, [e]), t } var jf = "Popper", [Gy, Yl] = Ui(jf), [cb, qy] = Gy(jf), Yy = e => { const { __scopePopper: t, children: n } = e, [r, s] = v.useState(null); return d.jsx(cb, { scope: t, anchor: r, onAnchorChange: s, children: n }) }; Yy.displayName = jf; var Xy = "PopperAnchor", Jy = v.forwardRef((e, t) => { const { __scopePopper: n, virtualRef: r, ...s } = e, o = qy(Xy, n), i = v.useRef(null), a = Ie(t, i); return v.useEffect(() => { o.onAnchorChange((r == null ? void 0 : r.current) || i.current) }), r ? null : d.jsx(_e.div, { ...s, ref: a }) }); Jy.displayName = Xy; var Of = "PopperContent", [db, fb] = Gy(Of), ex = v.forwardRef((e, t) => { var ee, Ce, $e, xe, he, ge; const { __scopePopper: n, side: r = "bottom", sideOffset: s = 0, align: o = "center", alignOffset: i = 0, arrowPadding: a = 0, avoidCollisions: l = !0, collisionBoundary: u = [], collisionPadding: c = 0, sticky: p = "partial", hideWhenDetached: h = !1, updatePositionStrategy: w = "optimized", onPlaced: S, ...m } = e, x = qy(Of, n), [g, f] = v.useState(null), y = Ie(t, ct => f(ct)), [_, k] = v.useState(null), T = ub(_), b = (T == null ? void 0 : T.width) ?? 0, R = (T == null ? void 0 : T.height) ?? 0, F = r + (o !== "center" ? "-" + o : ""), V = typeof c == "number" ? c : { top: 0, right: 0, bottom: 0, left: 0, ...c }, Y = Array.isArray(u) ? u : [u], O = Y.length > 0, z = { padding: V, boundary: Y.filter(hb), altBoundary: O }, { refs: j, floatingStyles: X, placement: K, isPositioned: J, middlewareData: P } = Xk({ strategy: "fixed", placement: F, whileElementsMounted: (...ct) => Wk(...ct, { animationFrame: w === "always" }), elements: { reference: x.anchor }, middleware: [eb({ mainAxis: s + R, alignmentAxis: i }), l && tb({ mainAxis: !0, crossAxis: !1, limiter: p === "partial" ? nb() : void 0, ...z }), l && rb({ ...z }), sb({ ...z, apply: ({ elements: ct, rects: Et, availableWidth: Ir, availableHeight: Zn }) => { const { width: Kn, height: lu } = Et.reference, cs = ct.floating.style; cs.setProperty("--radix-popper-available-width", `${Ir}px`), cs.setProperty("--radix-popper-available-height", `${Zn}px`), cs.setProperty("--radix-popper-anchor-width", `${Kn}px`), cs.setProperty("--radix-popper-anchor-height", `${lu}px`) } }), _ && ib({ element: _, padding: a }), mb({ arrowWidth: b, arrowHeight: R }), h && ob({ strategy: "referenceHidden", ...z })] }), [D, Q] = rx(K), re = Lt(S); lt(() => { J && (re == null || re()) }, [J, re]); const ve = (ee = P.arrow) == null ? void 0 : ee.x, Ke = (Ce = P.arrow) == null ? void 0 : Ce.y, Le = (($e = P.arrow) == null ? void 0 : $e.centerOffset) !== 0, [bt, qe] = v.useState(); return lt(() => { g && qe(window.getComputedStyle(g).zIndex) }, [g]), d.jsx("div", { ref: j.setFloating, "data-radix-popper-content-wrapper": "", style: { ...X, transform: J ? X.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: bt, "--radix-popper-transform-origin": [(xe = P.transformOrigin) == null ? void 0 : xe.x, (he = P.transformOrigin) == null ? void 0 : he.y].join(" "), ...((ge = P.hide) == null ? void 0 : ge.referenceHidden) && { visibility: "hidden", pointerEvents: "none" } }, dir: e.dir, children: d.jsx(db, { scope: n, placedSide: D, onArrowChange: k, arrowX: ve, arrowY: Ke, shouldHideArrow: Le, children: d.jsx(_e.div, { "data-side": D, "data-align": Q, ...m, ref: y, style: { ...m.style, animation: J ? void 0 : "none" } }) }) }) }); ex.displayName = Of; var tx = "PopperArrow", pb = { top: "bottom", right: "left", bottom: "top", left: "right" }, nx = v.forwardRef(function (t, n) { const { __scopePopper: r, ...s } = t, o = fb(tx, r), i = pb[o.placedSide]; return d.jsx("span", { ref: o.onArrowChange, style: { position: "absolute", left: o.arrowX, top: o.arrowY, [i]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[o.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[o.placedSide], visibility: o.shouldHideArrow ? "hidden" : void 0 }, children: d.jsx(lb, { ...s, ref: n, style: { ...s.style, display: "block" } }) }) }); nx.displayName = tx; function hb(e) { return e !== null } var mb = e => ({ name: "transformOrigin", options: e, fn(t) { var x, g, f; const { placement: n, rects: r, middlewareData: s } = t, i = ((x = s.arrow) == null ? void 0 : x.centerOffset) !== 0, a = i ? 0 : e.arrowWidth, l = i ? 0 : e.arrowHeight, [u, c] = rx(n), p = { start: "0%", center: "50%", end: "100%" }[c], h = (((g = s.arrow) == null ? void 0 : g.x) ?? 0) + a / 2, w = (((f = s.arrow) == null ? void 0 : f.y) ?? 0) + l / 2; let S = "", m = ""; return u === "bottom" ? (S = i ? p : `${h}px`, m = `${-l}px`) : u === "top" ? (S = i ? p : `${h}px`, m = `${r.floating.height + l}px`) : u === "right" ? (S = `${-l}px`, m = i ? p : `${w}px`) : u === "left" && (S = `${r.floating.width + l}px`, m = i ? p : `${w}px`), { data: { x: S, y: m } } } }); function rx(e) { const [t, n = "center"] = e.split("-"); return [t, n] } var vb = Yy, sx = Jy, ox = ex, ix = nx, [Xl, gP] = Ui("Tooltip", [Yl]), Mf = Yl(), ax = "TooltipProvider", gb = 700, Rh = "tooltip.open", [yb, lx] = Xl(ax), ux = e => { const { __scopeTooltip: t, delayDuration: n = gb, skipDelayDuration: r = 300, disableHoverableContent: s = !1, children: o } = e, i = v.useRef(!0), a = v.useRef(!1), l = v.useRef(0); return v.useEffect(() => { const u = l.current; return () => window.clearTimeout(u) }, []), d.jsx(yb, { scope: t, isOpenDelayedRef: i, delayDuration: n, onOpen: v.useCallback(() => { window.clearTimeout(l.current), i.current = !1 }, []), onClose: v.useCallback(() => { window.clearTimeout(l.current), l.current = window.setTimeout(() => i.current = !0, r) }, [r]), isPointerInTransitRef: a, onPointerInTransitChange: v.useCallback(u => { a.current = u }, []), disableHoverableContent: s, children: o }) }; ux.displayName = ax; var cx = "Tooltip", [yP, Jl] = Xl(cx), sd = "TooltipTrigger", xb = v.forwardRef((e, t) => { const { __scopeTooltip: n, ...r } = e, s = Jl(sd, n), o = lx(sd, n), i = Mf(n), a = v.useRef(null), l = Ie(t, a, s.onTriggerChange), u = v.useRef(!1), c = v.useRef(!1), p = v.useCallback(() => u.current = !1, []); return v.useEffect(() => () => document.removeEventListener("pointerup", p), [p]), d.jsx(sx, { asChild: !0, ...i, children: d.jsx(_e.button, { "aria-describedby": s.open ? s.contentId : void 0, "data-state": s.stateAttribute, ...r, ref: l, onPointerMove: ce(e.onPointerMove, h => { h.pointerType !== "touch" && !c.current && !o.isPointerInTransitRef.current && (s.onTriggerEnter(), c.current = !0) }), onPointerLeave: ce(e.onPointerLeave, () => { s.onTriggerLeave(), c.current = !1 }), onPointerDown: ce(e.onPointerDown, () => { s.open && s.onClose(), u.current = !0, document.addEventListener("pointerup", p, { once: !0 }) }), onFocus: ce(e.onFocus, () => { u.current || s.onOpen() }), onBlur: ce(e.onBlur, s.onClose), onClick: ce(e.onClick, s.onClose) }) }) }); xb.displayName = sd; var wb = "TooltipPortal", [xP, Sb] = Xl(wb, { forceMount: void 0 }), oo = "TooltipContent", dx = v.forwardRef((e, t) => { const n = Sb(oo, e.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...o } = e, i = Jl(oo, e.__scopeTooltip); return d.jsx(yf, { present: r || i.open, children: i.disableHoverableContent ? d.jsx(fx, { side: s, ...o, ref: t }) : d.jsx(_b, { side: s, ...o, ref: t }) }) }), _b = v.forwardRef((e, t) => { const n = Jl(oo, e.__scopeTooltip), r = lx(oo, e.__scopeTooltip), s = v.useRef(null), o = Ie(t, s), [i, a] = v.useState(null), { trigger: l, onClose: u } = n, c = s.current, { onPointerInTransitChange: p } = r, h = v.useCallback(() => { a(null), p(!1) }, [p]), w = v.useCallback((S, m) => { const x = S.currentTarget, g = { x: S.clientX, y: S.clientY }, f = Tb(g, x.getBoundingClientRect()), y = Nb(g, f), _ = Pb(m.getBoundingClientRect()), k = Ab([...y, ..._]); a(k), p(!0) }, [p]); return v.useEffect(() => () => h(), [h]), v.useEffect(() => { if (l && c) { const S = x => w(x, c), m = x => w(x, l); return l.addEventListener("pointerleave", S), c.addEventListener("pointerleave", m), () => { l.removeEventListener("pointerleave", S), c.removeEventListener("pointerleave", m) } } }, [l, c, w, h]), v.useEffect(() => { if (i) { const S = m => { const x = m.target, g = { x: m.clientX, y: m.clientY }, f = (l == null ? void 0 : l.contains(x)) || (c == null ? void 0 : c.contains(x)), y = !Rb(g, i); f ? h() : y && (h(), u()) }; return document.addEventListener("pointermove", S), () => document.removeEventListener("pointermove", S) } }, [l, c, i, u, h]), d.jsx(fx, { ...e, ref: o }) }), [Cb, kb] = Xl(cx, { isInside: !1 }), bb = M_("TooltipContent"), fx = v.forwardRef((e, t) => { const { __scopeTooltip: n, children: r, "aria-label": s, onEscapeKeyDown: o, onPointerDownOutside: i, ...a } = e, l = Jl(oo, n), u = Mf(n), { onClose: c } = l; return v.useEffect(() => (document.addEventListener(Rh, c), () => document.removeEventListener(Rh, c)), [c]), v.useEffect(() => { if (l.trigger) { const p = h => { const w = h.target; w != null && w.contains(l.trigger) && c() }; return window.addEventListener("scroll", p, { capture: !0 }), () => window.removeEventListener("scroll", p, { capture: !0 }) } }, [l.trigger, c]), d.jsx(Hl, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: o, onPointerDownOutside: i, onFocusOutside: p => p.preventDefault(), onDismiss: c, children: d.jsxs(ox, { "data-state": l.stateAttribute, ...u, ...a, ref: t, style: { ...a.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [d.jsx(bb, { children: r }), d.jsx(Cb, { scope: n, isInside: !0, children: d.jsx(eC, { id: l.contentId, role: "tooltip", children: s || r }) })] }) }) }); dx.displayName = oo; var px = "TooltipArrow", Eb = v.forwardRef((e, t) => { const { __scopeTooltip: n, ...r } = e, s = Mf(n); return kb(px, n).isInside ? null : d.jsx(ix, { ...s, ...r, ref: t }) }); Eb.displayName = px; function Tb(e, t) { const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), s = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x); switch (Math.min(n, r, s, o)) { case o: return "left"; case s: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function Nb(e, t, n = 5) { const r = []; switch (t) { case "top": r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n }); break; case "bottom": r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n }); break; case "left": r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n }); break; case "right": r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n }); break }return r } function Pb(e) { const { top: t, right: n, bottom: r, left: s } = e; return [{ x: s, y: t }, { x: n, y: t }, { x: n, y: r }, { x: s, y: r }] } function Rb(e, t) { const { x: n, y: r } = e; let s = !1; for (let o = 0, i = t.length - 1; o < t.length; i = o++) { const a = t[o].x, l = t[o].y, u = t[i].x, c = t[i].y; l > r != c > r && n < (u - a) * (r - l) / (c - l) + a && (s = !s) } return s } function Ab(e) { const t = e.slice(); return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), jb(t) } function jb(e) { if (e.length <= 1) return e.slice(); const t = []; for (let r = 0; r < e.length; r++) { const s = e[r]; for (; t.length >= 2;) { const o = t[t.length - 1], i = t[t.length - 2]; if ((o.x - i.x) * (s.y - i.y) >= (o.y - i.y) * (s.x - i.x)) t.pop(); else break } t.push(s) } t.pop(); const n = []; for (let r = e.length - 1; r >= 0; r--) { const s = e[r]; for (; n.length >= 2;) { const o = n[n.length - 1], i = n[n.length - 2]; if ((o.x - i.x) * (s.y - i.y) >= (o.y - i.y) * (s.x - i.x)) n.pop(); else break } n.push(s) } return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n) } var Ob = ux, hx = dx; const Mb = Ob, Ib = v.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) => d.jsx(hx, { ref: r, sideOffset: t, className: Se("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]", e), ...n })); Ib.displayName = hx.displayName; const Lb = _f("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10" } }, defaultVariants: { variant: "default", size: "default" } }), io = v.forwardRef(({ className: e, variant: t, size: n, asChild: r = !1, ...s }, o) => { const i = r ? qg : "button"; return d.jsx(i, { className: Se(Lb({ variant: t, size: n, className: e })), ref: o, ...s }) }); io.displayName = "Button"; function Db() { const [e, t] = v.useState(!1), n = r => { const s = document.getElementById(r); s && (s.scrollIntoView({ behavior: "smooth" }), t(!1)) }; return d.jsx("nav", { className: "bg-white shadow-sm sticky top-0 z-40", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "flex justify-between items-center py-4", children: [d.jsx("div", { className: "text-2xl font-bold text-primary", children: "Ashwani Upadhyay" }), d.jsxs("div", { className: "hidden md:flex space-x-6", children: [d.jsx("button", { onClick: () => n("home"), className: "text-gray-700 hover:text-primary transition-colors", children: "Home" }), d.jsx("button", { onClick: () => n("about"), className: "text-gray-700 hover:text-primary transition-colors", children: "About" }), d.jsx("button", { onClick: () => n("services"), className: "text-gray-700 hover:text-primary transition-colors", children: "Services" }), d.jsx("button", { onClick: () => n("pricing"), className: "text-gray-700 hover:text-primary transition-colors", children: "Pricing" }), d.jsx("button", { onClick: () => n("testimonials"), className: "text-gray-700 hover:text-primary transition-colors", children: "Testimonials" }), d.jsx("button", { onClick: () => n("contact"), className: "text-gray-700 hover:text-primary transition-colors", children: "Contact" })] }), d.jsx(io, { variant: "ghost", size: "icon", className: "md:hidden", onClick: () => t(!e), children: e ? d.jsx(Ty, { size: 24 }) : d.jsx(kC, { size: 24 }) })] }), e && d.jsx("div", { className: "md:hidden pb-4", children: d.jsxs("div", { className: "flex flex-col space-y-2", children: [d.jsx("button", { onClick: () => n("home"), className: "text-left py-2 text-gray-700 hover:text-primary transition-colors", children: "Home" }), d.jsx("button", { onClick: () => n("about"), className: "text-left py-2 text-gray-700 hover:text-primary transition-colors", children: "About" }), d.jsx("button", { onClick: () => n("services"), className: "text-left py-2 text-gray-700 hover:text-primary transition-colors", children: "Services" }), d.jsx("button", { onClick: () => n("pricing"), className: "text-left py-2 text-gray-700 hover:text-primary transition-colors", children: "Pricing" }), d.jsx("button", { onClick: () => n("testimonials"), className: "text-left py-2 text-gray-700 hover:text-primary transition-colors", children: "Testimonials" }), d.jsx("button", { onClick: () => n("contact"), className: "text-left py-2 text-gray-700 hover:text-primary transition-colors", children: "Contact" })] }) })] }) }) } function Fb() { const e = () => { const t = document.getElementById("contact"); t && t.scrollIntoView({ behavior: "smooth" }) }; return d.jsx("section", { id: "home", className: "bg-gradient-to-r from-primary to-secondary text-white section-padding", children: d.jsx("div", { className: "container-padding", children: d.jsxs("div", { className: "grid md:grid-cols-2 gap-12 items-center", children: [d.jsxs("div", { children: [d.jsxs("h1", { className: "text-4xl md:text-6xl font-bold mb-6 leading-tight", children: ["Build Your Best Self with", " ", d.jsx("span", { className: "text-accent", children: "Ashwani Upadhyay" })] }), d.jsx("p", { className: "text-xl md:text-2xl mb-8 opacity-90", children: "10+ years of expert training backed by science, discipline, and mental clarity" }), d.jsxs("div", { className: "flex flex-col sm:flex-row gap-4", children: [d.jsx(io, { onClick: e, className: "bg-accent text-white px-8 py-6 text-lg font-semibold hover:bg-accent/90 transition-colors", children: "Book Free 3-Day Trial" }), d.jsx(io, { asChild: !0, variant: "outline", className: "bg-whatsapp border-whatsapp text-white px-8 py-6 text-lg font-semibold hover:bg-whatsapp/90 transition-colors", children: d.jsxs("a", { href: "https://wa.me/918400408888", target: "_blank", rel: "noopener noreferrer", className: "inline-flex items-center justify-center", children: [d.jsx("i", { className: "fab fa-whatsapp mr-2" }), "WhatsApp Consultation"] }) })] })] }), d.jsx("div", { className: "text-center", children: d.jsx("img", { src: "https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&h=600", alt: "Professional fitness trainer working with client", className: "rounded-xl shadow-2xl w-full max-w-md mx-auto" }) })] }) }) }) } function Vb() { return d.jsx("section", { id: "about", className: "section-padding bg-white", children: d.jsx("div", { className: "container-padding", children: d.jsxs("div", { className: "grid md:grid-cols-2 gap-12 items-center", children: [d.jsx("div", { children: d.jsx("img", { src: "https://images.unsplash.com/photo-1594737625785-a6cbdabd333c?ixlib=rb-4.0.3&auto=format&fit=crop&w=800&h=600", alt: "Ashwani Upadhyay in gym setting", className: "rounded-xl shadow-lg w-full" }) }), d.jsxs("div", { children: [d.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-primary mb-6", children: "About Ashwani" }), d.jsx("div", { className: "text-lg text-primary mb-6 p-4 bg-light-gray rounded-lg border-l-4 border-accent", children: d.jsx("p", { className: "italic font-medium", children: '"It takes time and science to build the body you dream of."' }) }), d.jsx("p", { className: "text-gray-700 mb-6", children: "Strong believer in evidence-based fitness approaches, I focus on helping clients achieve sustainable transformations through scientific principles and personalized guidance." }), d.jsxs("div", { className: "grid sm:grid-cols-2 gap-4", children: [d.jsxs("div", { className: "flex items-center space-x-3", children: [d.jsx("i", { className: "fas fa-microscope text-accent text-xl" }), d.jsx("span", { className: "text-gray-700", children: "Scientific muscle building" })] }), d.jsxs("div", { className: "flex items-center space-x-3", children: [d.jsx("i", { className: "fas fa-utensils text-accent text-xl" }), d.jsx("span", { className: "text-gray-700", children: "Personalized nutrition plans" })] }), d.jsxs("div", { className: "flex items-center space-x-3", children: [d.jsx("i", { className: "fas fa-brain text-accent text-xl" }), d.jsx("span", { className: "text-gray-700", children: "Mind-muscle connection" })] }), d.jsxs("div", { className: "flex items-center space-x-3", children: [d.jsx("i", { className: "fas fa-calendar-check text-accent text-xl" }), d.jsx("span", { className: "text-gray-700", children: "Long-term fitness habits" })] })] })] })] }) }) }) } function zb() { const e = [{ image: "https://images.unsplash.com/photo-1554224155-6726b3ff858f?ixlib=rb-4.0.3&auto=format&fit=crop&w=400&h=300", title: "ISSA Certified Trainer", description: "International Sports Sciences Association" }, { image: "https://images.unsplash.com/photo-1494390248081-4e521a5940db?ixlib=rb-4.0.3&auto=format&fit=crop&w=400&h=300", title: "Nutrition Specialist", description: "Diet Planning & Nutrition Guidance" }, { image: "https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?ixlib=rb-4.0.3&auto=format&fit=crop&w=400&h=300", title: "Functional Training", description: "Movement & Mobility Specialist" }, { image: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&auto=format&fit=crop&w=400&h=300", title: "Mindfulness Coach", description: "Meditation & Mental Wellness" }]; return d.jsx("section", { id: "certifications", className: "section-padding bg-white", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "text-center mb-12", children: [d.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-primary mb-4", children: "Certified & Trusted" }), d.jsx("p", { className: "text-secondary text-lg", children: "Professional certifications ensuring the highest standards of training" })] }), d.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-4 gap-6", children: e.map((t, n) => d.jsxs("div", { className: "bg-light-gray p-6 rounded-xl text-center hover:shadow-lg transition-shadow", children: [d.jsx("img", { src: t.image, alt: t.title, className: "w-full h-32 object-cover rounded-lg mb-4" }), d.jsx("h3", { className: "font-semibold text-primary mb-2", children: t.title }), d.jsx("p", { className: "text-secondary text-sm", children: t.description })] }, n)) })] }) }) } function $b() { const e = [{ icon: "fas fa-dumbbell", title: "Personal Training", description: "One-on-one coaching sessions both offline and online via Zoom/Google Meet", features: ["Customized workout plans", "Form correction and technique", "Progress tracking and adjustments"] }, { icon: "fas fa-chart-line", title: "Body Transformation", description: "Customized body transformation plans based on scientific principles", features: ["Goal-specific training programs", "Before/after photo tracking", "Measurement and progress reports"] }, { icon: "fas fa-apple-alt", title: "Nutrition Guidance", description: "Scientific nutrition guidance tailored to your fitness goals", features: ["Personalized meal plans", "Macro and calorie calculations", "Supplement recommendations"] }, { icon: "fas fa-brain", title: "Mind-Muscle Connection", description: "Mental coaching for better workout performance and focus", features: ["Meditation techniques", "Mindfulness training", "Mental clarity coaching"] }, { icon: "fas fa-video", title: "Online Coaching", description: "Virtual training sessions and consultations worldwide", features: ["Video call sessions", "Exercise demonstration videos", "24/7 WhatsApp support"] }, { icon: "fas fa-clipboard-check", title: "Progress Tracking", description: "Comprehensive monitoring and adjustment of your fitness journey", features: ["Weekly check-ins", "Customized progress charts", "Goal reassessment"] }]; return d.jsx("section", { id: "services", className: "section-padding bg-gray-50", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "text-center mb-12", children: [d.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-primary mb-4", children: "Services Offered" }), d.jsx("p", { className: "text-gray-700 text-lg", children: "Comprehensive fitness solutions tailored to your goals" })] }), d.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-8", children: e.map((t, n) => d.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow", children: [d.jsx("div", { className: "text-accent text-3xl mb-4", children: d.jsx("i", { className: t.icon }) }), d.jsx("h3", { className: "text-xl font-semibold text-primary mb-3", children: t.title }), d.jsx("p", { className: "text-gray-700 mb-4", children: t.description }), d.jsx("ul", { className: "text-gray-600 text-sm space-y-1", children: t.features.map((r, s) => d.jsxs("li", { children: [" ", r] }, s)) })] }, n)) }), d.jsx("div", { className: "text-center mt-12", children: d.jsx("div", { className: "bg-accent text-white p-6 rounded-xl inline-block", children: d.jsx("p", { className: "text-lg font-semibold", children: "All training includes weekly follow-ups, customized charts, and progress tracking." }) }) })] }) }) } function Ub() { const e = () => { const n = document.getElementById("contact"); n && n.scrollIntoView({ behavior: "smooth" }) }, t = [{ name: "Monthly Plan", price: "5,999", period: "/month", features: ["Personalized Diet & Workout", "Weekly Check-ins", "Direct WhatsApp Support", "3-Day Free Trial"], highlighted: !1 }, { name: "Quarterly Plan", price: "15,999", period: "/3 months", features: ["Personalized Diet & Workout", "Weekly Check-ins", "Direct WhatsApp Support", "3-Day Free Trial", "Monthly Progress Reports"], highlighted: !0, badge: "Most Popular" }, { name: "Yearly Plan", price: "49,999", period: "/year", features: ["Personalized Diet & Workout", "Weekly Check-ins", "Direct WhatsApp Support", "3-Day Free Trial", "Quarterly Reassessments"], highlighted: !1 }]; return d.jsx("section", { id: "pricing", className: "section-padding bg-white", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "text-center mb-12", children: [d.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-primary mb-4", children: "Training Plans" }), d.jsx("p", { className: "text-gray-700 text-lg", children: "Choose the plan that fits your commitment level" })] }), d.jsx("div", { className: "grid md:grid-cols-3 gap-8", children: t.map((n, r) => d.jsxs("div", { className: `p-8 rounded-xl transition-all duration-300 ${n.highlighted ? "bg-accent text-white shadow-lg transform scale-105 relative" : "bg-gray-50 hover:shadow-lg"}`, children: [n.badge && d.jsx("div", { className: "absolute -top-3 left-1/2 transform -translate-x-1/2 bg-primary text-white px-4 py-1 rounded-full text-sm font-semibold", children: n.badge }), d.jsx("h3", { className: `text-2xl font-bold mb-4 ${n.highlighted ? "text-white" : "text-primary"}`, children: n.name }), d.jsxs("div", { className: `text-4xl font-bold mb-6 ${n.highlighted ? "text-white" : "text-accent"}`, children: [n.price, d.jsx("span", { className: `text-lg font-normal ${n.highlighted ? "opacity-75" : "text-gray-600"}`, children: n.period })] }), d.jsx("ul", { className: "space-y-3 mb-8", children: n.features.map((s, o) => d.jsxs("li", { className: "flex items-center space-x-3", children: [d.jsx(by, { className: `w-5 h-5 ${n.highlighted ? "text-white" : "text-whatsapp"}` }), d.jsx("span", { className: n.highlighted ? "text-white" : "text-gray-700", children: s })] }, o)) }), d.jsx(io, { onClick: e, className: `w-full py-3 font-semibold transition-colors ${n.highlighted ? "bg-white text-accent hover:bg-gray-100" : "bg-primary text-white hover:bg-primary/90"}`, children: "Get Started" })] }, r)) }), d.jsx("div", { className: "text-center mt-12", children: d.jsx("div", { className: "bg-primary text-white p-6 rounded-xl inline-block", children: d.jsx("p", { className: "text-lg font-semibold", children: "No Satisfaction = Full Refund Guarantee (within first week)" }) }) })] }) }) } function Bb() { const e = [{ name: "Rajesh Kumar", title: "Software Engineer", rating: 5, text: "Ashwani's scientific approach to fitness transformed my body and mindset. Lost 15kg in 4 months while building lean muscle!", initial: "R" }, { name: "Priya Sharma", title: "Marketing Manager", rating: 5, text: "The personalized nutrition plan was a game-changer. I gained 8kg of muscle mass and improved my overall health significantly.", initial: "P" }, { name: "Arjun Patel", title: "Business Owner", rating: 5, text: "Best investment I made for my health. Ashwani's mind-muscle connection coaching helped me achieve results I never thought possible.", initial: "A" }], t = n => Array.from({ length: 5 }, (r, s) => d.jsx(bC, { className: `w-4 h-4 ${s < n ? "text-accent fill-current" : "text-gray-300"}` }, s)); return d.jsx("section", { id: "testimonials", className: "section-padding bg-gray-50", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "text-center mb-12", children: [d.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-primary mb-4", children: "Client Testimonials" }), d.jsx("p", { className: "text-gray-700 text-lg", children: "Success stories from satisfied clients" })] }), d.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-8", children: e.map((n, r) => d.jsxs("div", { className: "bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow", children: [d.jsxs("div", { className: "flex items-center mb-4", children: [d.jsx("div", { className: "flex space-x-1", children: t(n.rating) }), d.jsxs("span", { className: "ml-2 text-gray-600", children: ["(", n.rating, ".0)"] })] }), d.jsxs("p", { className: "text-gray-700 mb-4 italic", children: ['"', n.text, '"'] }), d.jsxs("div", { className: "flex items-center", children: [d.jsx("div", { className: "w-10 h-10 bg-accent rounded-full flex items-center justify-center text-white font-bold", children: n.initial }), d.jsxs("div", { className: "ml-3", children: [d.jsx("p", { className: "font-semibold text-primary", children: n.name }), d.jsx("p", { className: "text-gray-600 text-sm", children: n.title })] })] })] }, r)) })] }) }) } var Hi = e => e.type === "checkbox", $r = e => e instanceof Date, ht = e => e == null; const mx = e => typeof e == "object"; var ze = e => !ht(e) && !Array.isArray(e) && mx(e) && !$r(e), vx = e => ze(e) && e.target ? Hi(e.target) ? e.target.checked : e.target.value : e, Wb = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, gx = (e, t) => e.has(Wb(t)), Hb = e => { const t = e.constructor && e.constructor.prototype; return ze(t) && t.hasOwnProperty("isPrototypeOf") }, If = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u"; function Ye(e) { let t; const n = Array.isArray(e), r = typeof FileList < "u" ? e instanceof FileList : !1; if (e instanceof Date) t = new Date(e); else if (e instanceof Set) t = new Set(e); else if (!(If && (e instanceof Blob || r)) && (n || ze(e))) if (t = n ? [] : {}, !n && !Hb(e)) t = e; else for (const s in e) e.hasOwnProperty(s) && (t[s] = Ye(e[s])); else return e; return t } var eu = e => Array.isArray(e) ? e.filter(Boolean) : [], Fe = e => e === void 0, U = (e, t, n) => { if (!t || !ze(e)) return n; const r = eu(t.split(/[,[\].]+?/)).reduce((s, o) => ht(s) ? s : s[o], e); return Fe(r) || r === e ? Fe(e[t]) ? n : e[t] : r }, Pt = e => typeof e == "boolean", Lf = e => /^\w*$/.test(e), yx = e => eu(e.replace(/["|']|\]/g, "").split(/\.|\[/)), ye = (e, t, n) => { let r = -1; const s = Lf(t) ? [t] : yx(t), o = s.length, i = o - 1; for (; ++r < o;) { const a = s[r]; let l = n; if (r !== i) { const u = e[a]; l = ze(u) || Array.isArray(u) ? u : isNaN(+s[r + 1]) ? {} : [] } if (a === "__proto__" || a === "constructor" || a === "prototype") return; e[a] = l, e = e[a] } }; const ml = { BLUR: "blur", FOCUS_OUT: "focusout", CHANGE: "change" }, Jt = { onBlur: "onBlur", onChange: "onChange", onSubmit: "onSubmit", onTouched: "onTouched", all: "all" }, Tn = { max: "max", min: "min", maxLength: "maxLength", minLength: "minLength", pattern: "pattern", required: "required", validate: "validate" }, xx = oe.createContext(null), tu = () => oe.useContext(xx), Zb = e => { const { children: t, ...n } = e; return oe.createElement(xx.Provider, { value: n }, t) }; var wx = (e, t, n, r = !0) => { const s = { defaultValues: t._defaultValues }; for (const o in e) Object.defineProperty(s, o, { get: () => { const i = o; return t._proxyFormState[i] !== Jt.all && (t._proxyFormState[i] = !r || Jt.all), n && (n[i] = !0), e[i] } }); return s }; function Kb(e) { const t = tu(), { control: n = t.control, disabled: r, name: s, exact: o } = e || {}, [i, a] = oe.useState(n._formState), l = oe.useRef({ isDirty: !1, isLoading: !1, dirtyFields: !1, touchedFields: !1, validatingFields: !1, isValidating: !1, isValid: !1, errors: !1 }), u = oe.useRef(s); return u.current = s, oe.useEffect(() => n._subscribe({ name: u.current, formState: l.current, exact: o, callback: c => { !r && a({ ...n._formState, ...c }) } }), [n, r, o]), oe.useEffect(() => { l.current.isValid && n._setValid(!0) }, [n]), oe.useMemo(() => wx(i, n, l.current, !1), [i, n]) } var gn = e => typeof e == "string", Sx = (e, t, n, r, s) => gn(e) ? (r && t.watch.add(e), U(n, e, s)) : Array.isArray(e) ? e.map(o => (r && t.watch.add(o), U(n, o))) : (r && (t.watchAll = !0), n); function Qb(e) { const t = tu(), { control: n = t.control, name: r, defaultValue: s, disabled: o, exact: i } = e || {}, a = oe.useRef(r), l = oe.useRef(s); a.current = r, oe.useEffect(() => n._subscribe({ name: a.current, formState: { values: !0 }, exact: i, callback: p => !o && c(Sx(a.current, n._names, p.values || n._formValues, !1, l.current)) }), [n, o, i]); const [u, c] = oe.useState(n._getWatch(r, s)); return oe.useEffect(() => n._removeUnmounted()), u } function Gb(e) { const t = tu(), { name: n, disabled: r, control: s = t.control, shouldUnregister: o } = e, i = gx(s._names.array, n), a = Qb({ control: s, name: n, defaultValue: U(s._formValues, n, U(s._defaultValues, n, e.defaultValue)), exact: !0 }), l = Kb({ control: s, name: n, exact: !0 }), u = oe.useRef(e), c = oe.useRef(s.register(n, { ...e.rules, value: a, ...Pt(e.disabled) ? { disabled: e.disabled } : {} })), p = oe.useMemo(() => Object.defineProperties({}, { invalid: { enumerable: !0, get: () => !!U(l.errors, n) }, isDirty: { enumerable: !0, get: () => !!U(l.dirtyFields, n) }, isTouched: { enumerable: !0, get: () => !!U(l.touchedFields, n) }, isValidating: { enumerable: !0, get: () => !!U(l.validatingFields, n) }, error: { enumerable: !0, get: () => U(l.errors, n) } }), [l, n]), h = oe.useCallback(x => c.current.onChange({ target: { value: vx(x), name: n }, type: ml.CHANGE }), [n]), w = oe.useCallback(() => c.current.onBlur({ target: { value: U(s._formValues, n), name: n }, type: ml.BLUR }), [n, s._formValues]), S = oe.useCallback(x => { const g = U(s._fields, n); g && x && (g._f.ref = { focus: () => x.focus(), select: () => x.select(), setCustomValidity: f => x.setCustomValidity(f), reportValidity: () => x.reportValidity() }) }, [s._fields, n]), m = oe.useMemo(() => ({ name: n, value: a, ...Pt(r) || l.disabled ? { disabled: l.disabled || r } : {}, onChange: h, onBlur: w, ref: S }), [n, r, l.disabled, h, w, S, a]); return oe.useEffect(() => { const x = s._options.shouldUnregister || o; s.register(n, { ...u.current.rules, ...Pt(u.current.disabled) ? { disabled: u.current.disabled } : {} }); const g = (f, y) => { const _ = U(s._fields, f); _ && _._f && (_._f.mount = y) }; if (g(n, !0), x) { const f = Ye(U(s._options.defaultValues, n)); ye(s._defaultValues, n, f), Fe(U(s._formValues, n)) && ye(s._formValues, n, f) } return !i && s.register(n), () => { (i ? x && !s._state.action : x) ? s.unregister(n) : g(n, !1) } }, [n, s, i, o]), oe.useEffect(() => { s._setDisabledField({ disabled: r, name: n }) }, [r, n, s]), oe.useMemo(() => ({ field: m, formState: l, fieldState: p }), [m, l, p]) } const qb = e => e.render(Gb(e)); var _x = (e, t, n, r, s) => t ? { ...n[e], types: { ...n[e] && n[e].types ? n[e].types : {}, [r]: s || !0 } } : {}, Xo = e => Array.isArray(e) ? e : [e], Ah = () => { let e = []; return { get observers() { return e }, next: s => { for (const o of e) o.next && o.next(s) }, subscribe: s => (e.push(s), { unsubscribe: () => { e = e.filter(o => o !== s) } }), unsubscribe: () => { e = [] } } }, od = e => ht(e) || !mx(e); function rr(e, t) { if (od(e) || od(t)) return e === t; if ($r(e) && $r(t)) return e.getTime() === t.getTime(); const n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (const s of n) { const o = e[s]; if (!r.includes(s)) return !1; if (s !== "ref") { const i = t[s]; if ($r(o) && $r(i) || ze(o) && ze(i) || Array.isArray(o) && Array.isArray(i) ? !rr(o, i) : o !== i) return !1 } } return !0 } var ft = e => ze(e) && !Object.keys(e).length, Df = e => e.type === "file", en = e => typeof e == "function", vl = e => { if (!If) return !1; const t = e ? e.ownerDocument : 0; return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement) }, Cx = e => e.type === "select-multiple", Ff = e => e.type === "radio", Yb = e => Ff(e) || Hi(e), Zu = e => vl(e) && e.isConnected; function Xb(e, t) { const n = t.slice(0, -1).length; let r = 0; for (; r < n;)e = Fe(e) ? r++ : e[t[r++]]; return e } function Jb(e) { for (const t in e) if (e.hasOwnProperty(t) && !Fe(e[t])) return !1; return !0 } function We(e, t) { const n = Array.isArray(t) ? t : Lf(t) ? [t] : yx(t), r = n.length === 1 ? e : Xb(e, n), s = n.length - 1, o = n[s]; return r && delete r[o], s !== 0 && (ze(r) && ft(r) || Array.isArray(r) && Jb(r)) && We(e, n.slice(0, -1)), e } var kx = e => { for (const t in e) if (en(e[t])) return !0; return !1 }; function gl(e, t = {}) { const n = Array.isArray(e); if (ze(e) || n) for (const r in e) Array.isArray(e[r]) || ze(e[r]) && !kx(e[r]) ? (t[r] = Array.isArray(e[r]) ? [] : {}, gl(e[r], t[r])) : ht(e[r]) || (t[r] = !0); return t } function bx(e, t, n) { const r = Array.isArray(e); if (ze(e) || r) for (const s in e) Array.isArray(e[s]) || ze(e[s]) && !kx(e[s]) ? Fe(t) || od(n[s]) ? n[s] = Array.isArray(e[s]) ? gl(e[s], []) : { ...gl(e[s]) } : bx(e[s], ht(t) ? {} : t[s], n[s]) : n[s] = !rr(e[s], t[s]); return n } var No = (e, t) => bx(e, t, gl(t)); const jh = { value: !1, isValid: !1 }, Oh = { value: !0, isValid: !0 }; var Ex = e => { if (Array.isArray(e)) { if (e.length > 1) { const t = e.filter(n => n && n.checked && !n.disabled).map(n => n.value); return { value: t, isValid: !!t.length } } return e[0].checked && !e[0].disabled ? e[0].attributes && !Fe(e[0].attributes.value) ? Fe(e[0].value) || e[0].value === "" ? Oh : { value: e[0].value, isValid: !0 } : Oh : jh } return jh }, Tx = (e, { valueAsNumber: t, valueAsDate: n, setValueAs: r }) => Fe(e) ? e : t ? e === "" ? NaN : e && +e : n && gn(e) ? new Date(e) : r ? r(e) : e; const Mh = { isValid: !1, value: null }; var Nx = e => Array.isArray(e) ? e.reduce((t, n) => n && n.checked && !n.disabled ? { isValid: !0, value: n.value } : t, Mh) : Mh; function Ih(e) { const t = e.ref; return Df(t) ? t.files : Ff(t) ? Nx(e.refs).value : Cx(t) ? [...t.selectedOptions].map(({ value: n }) => n) : Hi(t) ? Ex(e.refs).value : Tx(Fe(t.value) ? e.ref.value : t.value, e) } var eE = (e, t, n, r) => { const s = {}; for (const o of e) { const i = U(t, o); i && ye(s, o, i._f) } return { criteriaMode: n, names: [...e], fields: s, shouldUseNativeValidation: r } }, yl = e => e instanceof RegExp, Po = e => Fe(e) ? e : yl(e) ? e.source : ze(e) ? yl(e.value) ? e.value.source : e.value : e, Lh = e => ({ isOnSubmit: !e || e === Jt.onSubmit, isOnBlur: e === Jt.onBlur, isOnChange: e === Jt.onChange, isOnAll: e === Jt.all, isOnTouch: e === Jt.onTouched }); const Dh = "AsyncFunction"; var tE = e => !!e && !!e.validate && !!(en(e.validate) && e.validate.constructor.name === Dh || ze(e.validate) && Object.values(e.validate).find(t => t.constructor.name === Dh)), nE = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate), Fh = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some(r => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length)))); const Jo = (e, t, n, r) => { for (const s of n || Object.keys(e)) { const o = U(e, s); if (o) { const { _f: i, ...a } = o; if (i) { if (i.refs && i.refs[0] && t(i.refs[0], s) && !r) return !0; if (i.ref && t(i.ref, i.name) && !r) return !0; if (Jo(a, t)) break } else if (ze(a) && Jo(a, t)) break } } }; function Vh(e, t, n) { const r = U(e, n); if (r || Lf(n)) return { error: r, name: n }; const s = n.split("."); for (; s.length;) { const o = s.join("."), i = U(t, o), a = U(e, o); if (i && !Array.isArray(i) && n !== o) return { name: n }; if (a && a.type) return { name: o, error: a }; s.pop() } return { name: n } } var rE = (e, t, n, r) => { n(e); const { name: s, ...o } = e; return ft(o) || Object.keys(o).length >= Object.keys(t).length || Object.keys(o).find(i => t[i] === (!r || Jt.all)) }, sE = (e, t, n) => !e || !t || e === t || Xo(e).some(r => r && (n ? r === t : r.startsWith(t) || t.startsWith(r))), oE = (e, t, n, r, s) => s.isOnAll ? !1 : !n && s.isOnTouch ? !(t || e) : (n ? r.isOnBlur : s.isOnBlur) ? !e : (n ? r.isOnChange : s.isOnChange) ? e : !0, iE = (e, t) => !eu(U(e, t)).length && We(e, t), aE = (e, t, n) => { const r = Xo(U(e, n)); return ye(r, "root", t[n]), ye(e, n, r), e }, Da = e => gn(e); function zh(e, t, n = "validate") { if (Da(e) || Array.isArray(e) && e.every(Da) || Pt(e) && !e) return { type: n, message: Da(e) ? e : "", ref: t } } var fs = e => ze(e) && !yl(e) ? e : { value: e, message: "" }, $h = async (e, t, n, r, s, o) => { const { ref: i, refs: a, required: l, maxLength: u, minLength: c, min: p, max: h, pattern: w, validate: S, name: m, valueAsNumber: x, mount: g } = e._f, f = U(n, m); if (!g || t.has(m)) return {}; const y = a ? a[0] : i, _ = O => { s && y.reportValidity && (y.setCustomValidity(Pt(O) ? "" : O || ""), y.reportValidity()) }, k = {}, T = Ff(i), b = Hi(i), R = T || b, F = (x || Df(i)) && Fe(i.value) && Fe(f) || vl(i) && i.value === "" || f === "" || Array.isArray(f) && !f.length, V = _x.bind(null, m, r, k), Y = (O, z, j, X = Tn.maxLength, K = Tn.minLength) => { const J = O ? z : j; k[m] = { type: O ? X : K, message: J, ref: i, ...V(O ? X : K, J) } }; if (o ? !Array.isArray(f) || !f.length : l && (!R && (F || ht(f)) || Pt(f) && !f || b && !Ex(a).isValid || T && !Nx(a).isValid)) { const { value: O, message: z } = Da(l) ? { value: !!l, message: l } : fs(l); if (O && (k[m] = { type: Tn.required, message: z, ref: y, ...V(Tn.required, z) }, !r)) return _(z), k } if (!F && (!ht(p) || !ht(h))) { let O, z; const j = fs(h), X = fs(p); if (!ht(f) && !isNaN(f)) { const K = i.valueAsNumber || f && +f; ht(j.value) || (O = K > j.value), ht(X.value) || (z = K < X.value) } else { const K = i.valueAsDate || new Date(f), J = Q => new Date(new Date().toDateString() + " " + Q), P = i.type == "time", D = i.type == "week"; gn(j.value) && f && (O = P ? J(f) > J(j.value) : D ? f > j.value : K > new Date(j.value)), gn(X.value) && f && (z = P ? J(f) < J(X.value) : D ? f < X.value : K < new Date(X.value)) } if ((O || z) && (Y(!!O, j.message, X.message, Tn.max, Tn.min), !r)) return _(k[m].message), k } if ((u || c) && !F && (gn(f) || o && Array.isArray(f))) { const O = fs(u), z = fs(c), j = !ht(O.value) && f.length > +O.value, X = !ht(z.value) && f.length < +z.value; if ((j || X) && (Y(j, O.message, z.message), !r)) return _(k[m].message), k } if (w && !F && gn(f)) { const { value: O, message: z } = fs(w); if (yl(O) && !f.match(O) && (k[m] = { type: Tn.pattern, message: z, ref: i, ...V(Tn.pattern, z) }, !r)) return _(z), k } if (S) { if (en(S)) { const O = await S(f, n), z = zh(O, y); if (z && (k[m] = { ...z, ...V(Tn.validate, z.message) }, !r)) return _(z.message), k } else if (ze(S)) { let O = {}; for (const z in S) { if (!ft(O) && !r) break; const j = zh(await S[z](f, n), y, z); j && (O = { ...j, ...V(z, j.message) }, _(j.message), r && (k[m] = O)) } if (!ft(O) && (k[m] = { ref: y, ...O }, !r)) return k } } return _(!0), k }; const lE = { mode: Jt.onSubmit, reValidateMode: Jt.onChange, shouldFocusError: !0 }; function uE(e = {}) { let t = { ...lE, ...e }, n = { submitCount: 0, isDirty: !1, isLoading: en(t.defaultValues), isValidating: !1, isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, touchedFields: {}, dirtyFields: {}, validatingFields: {}, errors: t.errors || {}, disabled: t.disabled || !1 }; const r = {}; let s = ze(t.defaultValues) || ze(t.values) ? Ye(t.values || t.defaultValues) || {} : {}, o = t.shouldUnregister ? {} : Ye(s), i = { action: !1, mount: !1, watch: !1 }, a = { mount: new Set, disabled: new Set, unMount: new Set, array: new Set, watch: new Set }, l, u = 0; const c = { isDirty: !1, dirtyFields: !1, validatingFields: !1, touchedFields: !1, isValidating: !1, isValid: !1, errors: !1 }; let p = { ...c }; const h = { array: Ah(), state: Ah() }, w = Lh(t.mode), S = Lh(t.reValidateMode), m = t.criteriaMode === Jt.all, x = C => E => { clearTimeout(u), u = setTimeout(C, E) }, g = async C => { if (!t.disabled && (c.isValid || p.isValid || C)) { const E = t.resolver ? ft((await F()).errors) : await Y(r, !0); E !== n.isValid && h.state.next({ isValid: E }) } }, f = (C, E) => { !t.disabled && (c.isValidating || c.validatingFields || p.isValidating || p.validatingFields) && ((C || Array.from(a.mount)).forEach(A => { A && (E ? ye(n.validatingFields, A, E) : We(n.validatingFields, A)) }), h.state.next({ validatingFields: n.validatingFields, isValidating: !ft(n.validatingFields) })) }, y = (C, E = [], A, H, $ = !0, L = !0) => { if (H && A && !t.disabled) { if (i.action = !0, L && Array.isArray(U(r, C))) { const G = A(U(r, C), H.argA, H.argB); $ && ye(r, C, G) } if (L && Array.isArray(U(n.errors, C))) { const G = A(U(n.errors, C), H.argA, H.argB); $ && ye(n.errors, C, G), iE(n.errors, C) } if ((c.touchedFields || p.touchedFields) && L && Array.isArray(U(n.touchedFields, C))) { const G = A(U(n.touchedFields, C), H.argA, H.argB); $ && ye(n.touchedFields, C, G) } (c.dirtyFields || p.dirtyFields) && (n.dirtyFields = No(s, o)), h.state.next({ name: C, isDirty: z(C, E), dirtyFields: n.dirtyFields, errors: n.errors, isValid: n.isValid }) } else ye(o, C, E) }, _ = (C, E) => { ye(n.errors, C, E), h.state.next({ errors: n.errors }) }, k = C => { n.errors = C, h.state.next({ errors: n.errors, isValid: !1 }) }, T = (C, E, A, H) => { const $ = U(r, C); if ($) { const L = U(o, C, Fe(A) ? U(s, C) : A); Fe(L) || H && H.defaultChecked || E ? ye(o, C, E ? L : Ih($._f)) : K(C, L), i.mount && g() } }, b = (C, E, A, H, $) => { let L = !1, G = !1; const me = { name: C }; if (!t.disabled) { if (!A || H) { (c.isDirty || p.isDirty) && (G = n.isDirty, n.isDirty = me.isDirty = z(), L = G !== me.isDirty); const Ue = rr(U(s, C), E); G = !!U(n.dirtyFields, C), Ue ? We(n.dirtyFields, C) : ye(n.dirtyFields, C, !0), me.dirtyFields = n.dirtyFields, L = L || (c.dirtyFields || p.dirtyFields) && G !== !Ue } if (A) { const Ue = U(n.touchedFields, C); Ue || (ye(n.touchedFields, C, A), me.touchedFields = n.touchedFields, L = L || (c.touchedFields || p.touchedFields) && Ue !== A) } L && $ && h.state.next(me) } return L ? me : {} }, R = (C, E, A, H) => { const $ = U(n.errors, C), L = (c.isValid || p.isValid) && Pt(E) && n.isValid !== E; if (t.delayError && A ? (l = x(() => _(C, A)), l(t.delayError)) : (clearTimeout(u), l = null, A ? ye(n.errors, C, A) : We(n.errors, C)), (A ? !rr($, A) : $) || !ft(H) || L) { const G = { ...H, ...L && Pt(E) ? { isValid: E } : {}, errors: n.errors, name: C }; n = { ...n, ...G }, h.state.next(G) } }, F = async C => { f(C, !0); const E = await t.resolver(o, t.context, eE(C || a.mount, r, t.criteriaMode, t.shouldUseNativeValidation)); return f(C), E }, V = async C => { const { errors: E } = await F(C); if (C) for (const A of C) { const H = U(E, A); H ? ye(n.errors, A, H) : We(n.errors, A) } else n.errors = E; return E }, Y = async (C, E, A = { valid: !0 }) => { for (const H in C) { const $ = C[H]; if ($) { const { _f: L, ...G } = $; if (L) { const me = a.array.has(L.name), Ue = $._f && tE($._f); Ue && c.validatingFields && f([H], !0); const nt = await $h($, a.disabled, o, m, t.shouldUseNativeValidation && !E, me); if (Ue && c.validatingFields && f([H]), nt[L.name] && (A.valid = !1, E)) break; !E && (U(nt, L.name) ? me ? aE(n.errors, nt, L.name) : ye(n.errors, L.name, nt[L.name]) : We(n.errors, L.name)) } !ft(G) && await Y(G, E, A) } } return A.valid }, O = () => { for (const C of a.unMount) { const E = U(r, C); E && (E._f.refs ? E._f.refs.every(A => !Zu(A)) : !Zu(E._f.ref)) && $e(C) } a.unMount = new Set }, z = (C, E) => !t.disabled && (C && E && ye(o, C, E), !rr(ve(), s)), j = (C, E, A) => Sx(C, a, { ...i.mount ? o : Fe(E) ? s : gn(C) ? { [C]: E } : E }, A, E), X = C => eu(U(i.mount ? o : s, C, t.shouldUnregister ? U(s, C, []) : [])), K = (C, E, A = {}) => { const H = U(r, C); let $ = E; if (H) { const L = H._f; L && (!L.disabled && ye(o, C, Tx(E, L)), $ = vl(L.ref) && ht(E) ? "" : E, Cx(L.ref) ? [...L.ref.options].forEach(G => G.selected = $.includes(G.value)) : L.refs ? Hi(L.ref) ? L.refs.length > 1 ? L.refs.forEach(G => (!G.defaultChecked || !G.disabled) && (G.checked = Array.isArray($) ? !!$.find(me => me === G.value) : $ === G.value)) : L.refs[0] && (L.refs[0].checked = !!$) : L.refs.forEach(G => G.checked = G.value === $) : Df(L.ref) ? L.ref.value = "" : (L.ref.value = $, L.ref.type || h.state.next({ name: C, values: Ye(o) }))) } (A.shouldDirty || A.shouldTouch) && b(C, $, A.shouldTouch, A.shouldDirty, !0), A.shouldValidate && re(C) }, J = (C, E, A) => { for (const H in E) { const $ = E[H], L = `${C}.${H}`, G = U(r, L); (a.array.has(C) || ze($) || G && !G._f) && !$r($) ? J(L, $, A) : K(L, $, A) } }, P = (C, E, A = {}) => { const H = U(r, C), $ = a.array.has(C), L = Ye(E); ye(o, C, L), $ ? (h.array.next({ name: C, values: Ye(o) }), (c.isDirty || c.dirtyFields || p.isDirty || p.dirtyFields) && A.shouldDirty && h.state.next({ name: C, dirtyFields: No(s, o), isDirty: z(C, L) })) : H && !H._f && !ht(L) ? J(C, L, A) : K(C, L, A), Fh(C, a) && h.state.next({ ...n }), h.state.next({ name: i.mount ? C : void 0, values: Ye(o) }) }, D = async C => { i.mount = !0; const E = C.target; let A = E.name, H = !0; const $ = U(r, A), L = G => { H = Number.isNaN(G) || $r(G) && isNaN(G.getTime()) || rr(G, U(o, A, G)) }; if ($) { let G, me; const Ue = E.type ? Ih($._f) : vx(C), nt = C.type === ml.BLUR || C.type === ml.FOCUS_OUT, W0 = !nE($._f) && !t.resolver && !U(n.errors, A) && !$._f.deps || oE(nt, U(n.touchedFields, A), n.isSubmitted, S, w), uu = Fh(A, a, nt); ye(o, A, Ue), nt ? ($._f.onBlur && $._f.onBlur(C), l && l(0)) : $._f.onChange && $._f.onChange(C); const cu = b(A, Ue, nt), H0 = !ft(cu) || uu; if (!nt && h.state.next({ name: A, type: C.type, values: Ye(o) }), W0) return (c.isValid || p.isValid) && (t.mode === "onBlur" ? nt && g() : nt || g()), H0 && h.state.next({ name: A, ...uu ? {} : cu }); if (!nt && uu && h.state.next({ ...n }), t.resolver) { const { errors: Uf } = await F([A]); if (L(Ue), H) { const Z0 = Vh(n.errors, r, A), Bf = Vh(Uf, r, Z0.name || A); G = Bf.error, A = Bf.name, me = ft(Uf) } } else f([A], !0), G = (await $h($, a.disabled, o, m, t.shouldUseNativeValidation))[A], f([A]), L(Ue), H && (G ? me = !1 : (c.isValid || p.isValid) && (me = await Y(r, !0))); H && ($._f.deps && re($._f.deps), R(A, me, G, cu)) } }, Q = (C, E) => { if (U(n.errors, E) && C.focus) return C.focus(), 1 }, re = async (C, E = {}) => { let A, H; const $ = Xo(C); if (t.resolver) { const L = await V(Fe(C) ? C : $); A = ft(L), H = C ? !$.some(G => U(L, G)) : A } else C ? (H = (await Promise.all($.map(async L => { const G = U(r, L); return await Y(G && G._f ? { [L]: G } : G) }))).every(Boolean), !(!H && !n.isValid) && g()) : H = A = await Y(r); return h.state.next({ ...!gn(C) || (c.isValid || p.isValid) && A !== n.isValid ? {} : { name: C }, ...t.resolver || !C ? { isValid: A } : {}, errors: n.errors }), E.shouldFocus && !H && Jo(r, Q, C ? $ : a.mount), H }, ve = C => { const E = { ...i.mount ? o : s }; return Fe(C) ? E : gn(C) ? U(E, C) : C.map(A => U(E, A)) }, Ke = (C, E) => ({ invalid: !!U((E || n).errors, C), isDirty: !!U((E || n).dirtyFields, C), error: U((E || n).errors, C), isValidating: !!U(n.validatingFields, C), isTouched: !!U((E || n).touchedFields, C) }), Le = C => { C && Xo(C).forEach(E => We(n.errors, E)), h.state.next({ errors: C ? n.errors : {} }) }, bt = (C, E, A) => { const H = (U(r, C, { _f: {} })._f || {}).ref, $ = U(n.errors, C) || {}, { ref: L, message: G, type: me, ...Ue } = $; ye(n.errors, C, { ...Ue, ...E, ref: H }), h.state.next({ name: C, errors: n.errors, isValid: !1 }), A && A.shouldFocus && H && H.focus && H.focus() }, qe = (C, E) => en(C) ? h.state.subscribe({ next: A => C(j(void 0, E), A) }) : j(C, E, !0), ee = C => h.state.subscribe({ next: E => { sE(C.name, E.name, C.exact) && rE(E, C.formState || c, cs, C.reRenderRoot) && C.callback({ values: { ...o }, ...n, ...E }) } }).unsubscribe, Ce = C => (i.mount = !0, p = { ...p, ...C.formState }, ee({ ...C, formState: p })), $e = (C, E = {}) => { for (const A of C ? Xo(C) : a.mount) a.mount.delete(A), a.array.delete(A), E.keepValue || (We(r, A), We(o, A)), !E.keepError && We(n.errors, A), !E.keepDirty && We(n.dirtyFields, A), !E.keepTouched && We(n.touchedFields, A), !E.keepIsValidating && We(n.validatingFields, A), !t.shouldUnregister && !E.keepDefaultValue && We(s, A); h.state.next({ values: Ye(o) }), h.state.next({ ...n, ...E.keepDirty ? { isDirty: z() } : {} }), !E.keepIsValid && g() }, xe = ({ disabled: C, name: E }) => { (Pt(C) && i.mount || C || a.disabled.has(E)) && (C ? a.disabled.add(E) : a.disabled.delete(E)) }, he = (C, E = {}) => { let A = U(r, C); const H = Pt(E.disabled) || Pt(t.disabled); return ye(r, C, { ...A || {}, _f: { ...A && A._f ? A._f : { ref: { name: C } }, name: C, mount: !0, ...E } }), a.mount.add(C), A ? xe({ disabled: Pt(E.disabled) ? E.disabled : t.disabled, name: C }) : T(C, !0, E.value), { ...H ? { disabled: E.disabled || t.disabled } : {}, ...t.progressive ? { required: !!E.required, min: Po(E.min), max: Po(E.max), minLength: Po(E.minLength), maxLength: Po(E.maxLength), pattern: Po(E.pattern) } : {}, name: C, onChange: D, onBlur: D, ref: $ => { if ($) { he(C, E), A = U(r, C); const L = Fe($.value) && $.querySelectorAll && $.querySelectorAll("input,select,textarea")[0] || $, G = Yb(L), me = A._f.refs || []; if (G ? me.find(Ue => Ue === L) : L === A._f.ref) return; ye(r, C, { _f: { ...A._f, ...G ? { refs: [...me.filter(Zu), L, ...Array.isArray(U(s, C)) ? [{}] : []], ref: { type: L.type, name: C } } : { ref: L } } }), T(C, !1, void 0, L) } else A = U(r, C, {}), A._f && (A._f.mount = !1), (t.shouldUnregister || E.shouldUnregister) && !(gx(a.array, C) && i.action) && a.unMount.add(C) } } }, ge = () => t.shouldFocusError && Jo(r, Q, a.mount), ct = C => { Pt(C) && (h.state.next({ disabled: C }), Jo(r, (E, A) => { const H = U(r, A); H && (E.disabled = H._f.disabled || C, Array.isArray(H._f.refs) && H._f.refs.forEach($ => { $.disabled = H._f.disabled || C })) }, 0, !1)) }, Et = (C, E) => async A => { let H; A && (A.preventDefault && A.preventDefault(), A.persist && A.persist()); let $ = Ye(o); if (h.state.next({ isSubmitting: !0 }), t.resolver) { const { errors: L, values: G } = await F(); n.errors = L, $ = G } else await Y(r); if (a.disabled.size) for (const L of a.disabled) ye($, L, void 0); if (We(n.errors, "root"), ft(n.errors)) { h.state.next({ errors: {} }); try { await C($, A) } catch (L) { H = L } } else E && await E({ ...n.errors }, A), ge(), setTimeout(ge); if (h.state.next({ isSubmitted: !0, isSubmitting: !1, isSubmitSuccessful: ft(n.errors) && !H, submitCount: n.submitCount + 1, errors: n.errors }), H) throw H }, Ir = (C, E = {}) => { U(r, C) && (Fe(E.defaultValue) ? P(C, Ye(U(s, C))) : (P(C, E.defaultValue), ye(s, C, Ye(E.defaultValue))), E.keepTouched || We(n.touchedFields, C), E.keepDirty || (We(n.dirtyFields, C), n.isDirty = E.defaultValue ? z(C, Ye(U(s, C))) : z()), E.keepError || (We(n.errors, C), c.isValid && g()), h.state.next({ ...n })) }, Zn = (C, E = {}) => { const A = C ? Ye(C) : s, H = Ye(A), $ = ft(C), L = $ ? s : H; if (E.keepDefaultValues || (s = A), !E.keepValues) { if (E.keepDirtyValues) { const G = new Set([...a.mount, ...Object.keys(No(s, o))]); for (const me of Array.from(G)) U(n.dirtyFields, me) ? ye(L, me, U(o, me)) : P(me, U(L, me)) } else { if (If && Fe(C)) for (const G of a.mount) { const me = U(r, G); if (me && me._f) { const Ue = Array.isArray(me._f.refs) ? me._f.refs[0] : me._f.ref; if (vl(Ue)) { const nt = Ue.closest("form"); if (nt) { nt.reset(); break } } } } for (const G of a.mount) P(G, U(L, G)) } o = Ye(L), h.array.next({ values: { ...L } }), h.state.next({ values: { ...L } }) } a = { mount: E.keepDirtyValues ? a.mount : new Set, unMount: new Set, array: new Set, disabled: new Set, watch: new Set, watchAll: !1, focus: "" }, i.mount = !c.isValid || !!E.keepIsValid || !!E.keepDirtyValues, i.watch = !!t.shouldUnregister, h.state.next({ submitCount: E.keepSubmitCount ? n.submitCount : 0, isDirty: $ ? !1 : E.keepDirty ? n.isDirty : !!(E.keepDefaultValues && !rr(C, s)), isSubmitted: E.keepIsSubmitted ? n.isSubmitted : !1, dirtyFields: $ ? {} : E.keepDirtyValues ? E.keepDefaultValues && o ? No(s, o) : n.dirtyFields : E.keepDefaultValues && C ? No(s, C) : E.keepDirty ? n.dirtyFields : {}, touchedFields: E.keepTouched ? n.touchedFields : {}, errors: E.keepErrors ? n.errors : {}, isSubmitSuccessful: E.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1, isSubmitting: !1 }) }, Kn = (C, E) => Zn(en(C) ? C(o) : C, E), lu = (C, E = {}) => { const A = U(r, C), H = A && A._f; if (H) { const $ = H.refs ? H.refs[0] : H.ref; $.focus && ($.focus(), E.shouldSelect && en($.select) && $.select()) } }, cs = C => { n = { ...n, ...C } }, $f = { control: { register: he, unregister: $e, getFieldState: Ke, handleSubmit: Et, setError: bt, _subscribe: ee, _runSchema: F, _getWatch: j, _getDirty: z, _setValid: g, _setFieldArray: y, _setDisabledField: xe, _setErrors: k, _getFieldArray: X, _reset: Zn, _resetDefaultValues: () => en(t.defaultValues) && t.defaultValues().then(C => { Kn(C, t.resetOptions), h.state.next({ isLoading: !1 }) }), _removeUnmounted: O, _disableForm: ct, _subjects: h, _proxyFormState: c, get _fields() { return r }, get _formValues() { return o }, get _state() { return i }, set _state(C) { i = C }, get _defaultValues() { return s }, get _names() { return a }, set _names(C) { a = C }, get _formState() { return n }, get _options() { return t }, set _options(C) { t = { ...t, ...C } } }, subscribe: Ce, trigger: re, register: he, handleSubmit: Et, watch: qe, setValue: P, getValues: ve, reset: Kn, resetField: Ir, clearErrors: Le, unregister: $e, setError: bt, setFocus: lu, getFieldState: Ke }; return { ...$f, formControl: $f } } function cE(e = {}) { const t = oe.useRef(void 0), n = oe.useRef(void 0), [r, s] = oe.useState({ isDirty: !1, isValidating: !1, isLoading: en(e.defaultValues), isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, submitCount: 0, dirtyFields: {}, touchedFields: {}, validatingFields: {}, errors: e.errors || {}, disabled: e.disabled || !1, defaultValues: en(e.defaultValues) ? void 0 : e.defaultValues }); t.current || (t.current = { ...e.formControl ? e.formControl : uE(e), formState: r }, e.formControl && e.defaultValues && !en(e.defaultValues) && e.formControl.reset(e.defaultValues, e.resetOptions)); const o = t.current.control; return o._options = e, oe.useLayoutEffect(() => o._subscribe({ formState: o._proxyFormState, callback: () => s({ ...o._formState }), reRenderRoot: !0 }), [o]), oe.useEffect(() => o._disableForm(e.disabled), [o, e.disabled]), oe.useEffect(() => { if (o._proxyFormState.isDirty) { const i = o._getDirty(); i !== r.isDirty && o._subjects.state.next({ isDirty: i }) } }, [o, r.isDirty]), oe.useEffect(() => { e.values && !rr(e.values, n.current) ? (o._reset(e.values, o._options.resetOptions), n.current = e.values, s(i => ({ ...i }))) : o._resetDefaultValues() }, [e.values, o]), oe.useEffect(() => { e.errors && !ft(e.errors) && o._setErrors(e.errors) }, [e.errors, o]), oe.useEffect(() => { o._state.mount || (o._setValid(), o._state.mount = !0), o._state.watch && (o._state.watch = !1, o._subjects.state.next({ ...o._formState })), o._removeUnmounted() }), oe.useEffect(() => { e.shouldUnregister && o._subjects.state.next({ values: o._getWatch() }) }, [e.shouldUnregister, o]), t.current.formState = wx(r, o), t.current } const Uh = (e, t, n) => { if (e && "reportValidity" in e) { const r = U(n, t); e.setCustomValidity(r && r.message || ""), e.reportValidity() } }, Px = (e, t) => { for (const n in t.fields) { const r = t.fields[n]; r && r.ref && "reportValidity" in r.ref ? Uh(r.ref, n, e) : r.refs && r.refs.forEach(s => Uh(s, n, e)) } }, dE = (e, t) => { t.shouldUseNativeValidation && Px(e, t); const n = {}; for (const r in e) { const s = U(t.fields, r), o = Object.assign(e[r] || {}, { ref: s && s.ref }); if (fE(t.names || Object.keys(e), r)) { const i = Object.assign({}, U(n, r)); ye(i, "root", o), ye(n, r, i) } else ye(n, r, o) } return n }, fE = (e, t) => e.some(n => n.startsWith(t + ".")); var pE = function (e, t) { for (var n = {}; e.length;) { var r = e[0], s = r.code, o = r.message, i = r.path.join("."); if (!n[i]) if ("unionErrors" in r) { var a = r.unionErrors[0].errors[0]; n[i] = { message: a.message, type: a.code } } else n[i] = { message: o, type: s }; if ("unionErrors" in r && r.unionErrors.forEach(function (c) { return c.errors.forEach(function (p) { return e.push(p) }) }), t) { var l = n[i].types, u = l && l[r.code]; n[i] = _x(i, t, n, s, u ? [].concat(u, r.message) : r.message) } e.shift() } return n }, hE = function (e, t, n) { return n === void 0 && (n = {}), function (r, s, o) { try { return Promise.resolve(function (i, a) { try { var l = Promise.resolve(e[n.mode === "sync" ? "parse" : "parseAsync"](r, t)).then(function (u) { return o.shouldUseNativeValidation && Px({}, o), { errors: {}, values: n.raw ? r : u } }) } catch (u) { return a(u) } return l && l.then ? l.then(void 0, a) : l }(0, function (i) { if (function (a) { return Array.isArray(a == null ? void 0 : a.errors) }(i)) return { values: {}, errors: dE(pE(i.errors, !o.shouldUseNativeValidation && o.criteriaMode === "all"), o) }; throw i })) } catch (i) { return Promise.reject(i) } } }, fe; (function (e) { e.assertEqual = s => s; function t(s) { } e.assertIs = t; function n(s) { throw new Error } e.assertNever = n, e.arrayToEnum = s => { const o = {}; for (const i of s) o[i] = i; return o }, e.getValidEnumValues = s => { const o = e.objectKeys(s).filter(a => typeof s[s[a]] != "number"), i = {}; for (const a of o) i[a] = s[a]; return e.objectValues(i) }, e.objectValues = s => e.objectKeys(s).map(function (o) { return s[o] }), e.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => { const o = []; for (const i in s) Object.prototype.hasOwnProperty.call(s, i) && o.push(i); return o }, e.find = (s, o) => { for (const i of s) if (o(i)) return i }, e.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && isFinite(s) && Math.floor(s) === s; function r(s, o = " | ") { return s.map(i => typeof i == "string" ? `'${i}'` : i).join(o) } e.joinValues = r, e.jsonStringifyReplacer = (s, o) => typeof o == "bigint" ? o.toString() : o })(fe || (fe = {})); var id; (function (e) { e.mergeShapes = (t, n) => ({ ...t, ...n }) })(id || (id = {})); const W = fe.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), jn = e => { switch (typeof e) { case "undefined": return W.undefined; case "string": return W.string; case "number": return isNaN(e) ? W.nan : W.number; case "boolean": return W.boolean; case "function": return W.function; case "bigint": return W.bigint; case "symbol": return W.symbol; case "object": return Array.isArray(e) ? W.array : e === null ? W.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? W.promise : typeof Map < "u" && e instanceof Map ? W.map : typeof Set < "u" && e instanceof Set ? W.set : typeof Date < "u" && e instanceof Date ? W.date : W.object; default: return W.unknown } }, M = fe.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), mE = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"); class Mt extends Error { get errors() { return this.issues } constructor(t) { super(), this.issues = [], this.addIssue = r => { this.issues = [...this.issues, r] }, this.addIssues = (r = []) => { this.issues = [...this.issues, ...r] }; const n = new.target.prototype; Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t } format(t) { const n = t || function (o) { return o.message }, r = { _errors: [] }, s = o => { for (const i of o.issues) if (i.code === "invalid_union") i.unionErrors.map(s); else if (i.code === "invalid_return_type") s(i.returnTypeError); else if (i.code === "invalid_arguments") s(i.argumentsError); else if (i.path.length === 0) r._errors.push(n(i)); else { let a = r, l = 0; for (; l < i.path.length;) { const u = i.path[l]; l === i.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(i))) : a[u] = a[u] || { _errors: [] }, a = a[u], l++ } } }; return s(this), r } static assert(t) { if (!(t instanceof Mt)) throw new Error(`Not a ZodError: ${t}`) } toString() { return this.message } get message() { return JSON.stringify(this.issues, fe.jsonStringifyReplacer, 2) } get isEmpty() { return this.issues.length === 0 } flatten(t = n => n.message) { const n = {}, r = []; for (const s of this.issues) s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(t(s))) : r.push(t(s)); return { formErrors: r, fieldErrors: n } } get formErrors() { return this.flatten() } } Mt.create = e => new Mt(e); const ao = (e, t) => { let n; switch (e.code) { case M.invalid_type: e.received === W.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`; break; case M.invalid_literal: n = `Invalid literal value, expected ${JSON.stringify(e.expected, fe.jsonStringifyReplacer)}`; break; case M.unrecognized_keys: n = `Unrecognized key(s) in object: ${fe.joinValues(e.keys, ", ")}`; break; case M.invalid_union: n = "Invalid input"; break; case M.invalid_union_discriminator: n = `Invalid discriminator value. Expected ${fe.joinValues(e.options)}`; break; case M.invalid_enum_value: n = `Invalid enum value. Expected ${fe.joinValues(e.options)}, received '${e.received}'`; break; case M.invalid_arguments: n = "Invalid function arguments"; break; case M.invalid_return_type: n = "Invalid function return type"; break; case M.invalid_date: n = "Invalid date"; break; case M.invalid_string: typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : fe.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid"; break; case M.too_small: e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input"; break; case M.too_big: e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input"; break; case M.custom: n = "Invalid input"; break; case M.invalid_intersection_types: n = "Intersection results could not be merged"; break; case M.not_multiple_of: n = `Number must be a multiple of ${e.multipleOf}`; break; case M.not_finite: n = "Number must be finite"; break; default: n = t.defaultError, fe.assertNever(e) }return { message: n } }; let Rx = ao; function vE(e) { Rx = e } function xl() { return Rx } const wl = e => { const { data: t, path: n, errorMaps: r, issueData: s } = e, o = [...n, ...s.path || []], i = { ...s, path: o }; if (s.message !== void 0) return { ...s, path: o, message: s.message }; let a = ""; const l = r.filter(u => !!u).slice().reverse(); for (const u of l) a = u(i, { data: t, defaultError: a }).message; return { ...s, path: o, message: a } }, gE = []; function B(e, t) { const n = xl(), r = wl({ issueData: t, data: e.data, path: e.path, errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === ao ? void 0 : ao].filter(s => !!s) }); e.common.issues.push(r) } class ut { constructor() { this.value = "valid" } dirty() { this.value === "valid" && (this.value = "dirty") } abort() { this.value !== "aborted" && (this.value = "aborted") } static mergeArray(t, n) { const r = []; for (const s of n) { if (s.status === "aborted") return ne; s.status === "dirty" && t.dirty(), r.push(s.value) } return { status: t.value, value: r } } static async mergeObjectAsync(t, n) { const r = []; for (const s of n) { const o = await s.key, i = await s.value; r.push({ key: o, value: i }) } return ut.mergeObjectSync(t, r) } static mergeObjectSync(t, n) { const r = {}; for (const s of n) { const { key: o, value: i } = s; if (o.status === "aborted" || i.status === "aborted") return ne; o.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof i.value < "u" || s.alwaysSet) && (r[o.value] = i.value) } return { status: t.value, value: r } } } const ne = Object.freeze({ status: "aborted" }), Rs = e => ({ status: "dirty", value: e }), vt = e => ({ status: "valid", value: e }), ad = e => e.status === "aborted", ld = e => e.status === "dirty", ns = e => e.status === "valid", Si = e => typeof Promise < "u" && e instanceof Promise; function Sl(e, t, n, r) { if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return t.get(e) } function Ax(e, t, n, r, s) { if (typeof t == "function" ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return t.set(e, n), n } var q; (function (e) { e.errToObj = t => typeof t == "string" ? { message: t } : t || {}, e.toString = t => typeof t == "string" ? t : t == null ? void 0 : t.message })(q || (q = {})); var Io, Lo; class Cn { constructor(t, n, r, s) { this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = s } get path() { return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath } } const Bh = (e, t) => { if (ns(t)) return { success: !0, data: t.value }; if (!e.common.issues.length) throw new Error("Validation failed but no issues detected."); return { success: !1, get error() { if (this._error) return this._error; const n = new Mt(e.common.issues); return this._error = n, this._error } } }; function ie(e) { if (!e) return {}; const { errorMap: t, invalid_type_error: n, required_error: r, description: s } = e; if (t && (n || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`); return t ? { errorMap: t, description: s } : { errorMap: (i, a) => { var l, u; const { message: c } = e; return i.code === "invalid_enum_value" ? { message: c ?? a.defaultError } : typeof a.data > "u" ? { message: (l = c ?? r) !== null && l !== void 0 ? l : a.defaultError } : i.code !== "invalid_type" ? { message: a.defaultError } : { message: (u = c ?? n) !== null && u !== void 0 ? u : a.defaultError } }, description: s } } class le { get description() { return this._def.description } _getType(t) { return jn(t.data) } _getOrReturnCtx(t, n) { return n || { common: t.parent.common, data: t.data, parsedType: jn(t.data), schemaErrorMap: this._def.errorMap, path: t.path, parent: t.parent } } _processInputParams(t) { return { status: new ut, ctx: { common: t.parent.common, data: t.data, parsedType: jn(t.data), schemaErrorMap: this._def.errorMap, path: t.path, parent: t.parent } } } _parseSync(t) { const n = this._parse(t); if (Si(n)) throw new Error("Synchronous parse encountered promise."); return n } _parseAsync(t) { const n = this._parse(t); return Promise.resolve(n) } parse(t, n) { const r = this.safeParse(t, n); if (r.success) return r.data; throw r.error } safeParse(t, n) { var r; const s = { common: { issues: [], async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1, contextualErrorMap: n == null ? void 0 : n.errorMap }, path: (n == null ? void 0 : n.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: t, parsedType: jn(t) }, o = this._parseSync({ data: t, path: s.path, parent: s }); return Bh(s, o) } "~validate"(t) { var n, r; const s = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: t, parsedType: jn(t) }; if (!this["~standard"].async) try { const o = this._parseSync({ data: t, path: [], parent: s }); return ns(o) ? { value: o.value } : { issues: s.common.issues } } catch (o) { !((r = (n = o == null ? void 0 : o.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || r === void 0) && r.includes("encountered") && (this["~standard"].async = !0), s.common = { issues: [], async: !0 } } return this._parseAsync({ data: t, path: [], parent: s }).then(o => ns(o) ? { value: o.value } : { issues: s.common.issues }) } async parseAsync(t, n) { const r = await this.safeParseAsync(t, n); if (r.success) return r.data; throw r.error } async safeParseAsync(t, n) { const r = { common: { issues: [], contextualErrorMap: n == null ? void 0 : n.errorMap, async: !0 }, path: (n == null ? void 0 : n.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: t, parsedType: jn(t) }, s = this._parse({ data: t, path: r.path, parent: r }), o = await (Si(s) ? s : Promise.resolve(s)); return Bh(r, o) } refine(t, n) { const r = s => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n; return this._refinement((s, o) => { const i = t(s), a = () => o.addIssue({ code: M.custom, ...r(s) }); return typeof Promise < "u" && i instanceof Promise ? i.then(l => l ? !0 : (a(), !1)) : i ? !0 : (a(), !1) }) } refinement(t, n) { return this._refinement((r, s) => t(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1)) } _refinement(t) { return new un({ schema: this, typeName: te.ZodEffects, effect: { type: "refinement", refinement: t } }) } superRefine(t) { return this._refinement(t) } constructor(t) { this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: n => this["~validate"](n) } } optional() { return Sn.create(this, this._def) } nullable() { return Pr.create(this, this._def) } nullish() { return this.nullable().optional() } array() { return sn.create(this) } promise() { return uo.create(this, this._def) } or(t) { return bi.create([this, t], this._def) } and(t) { return Ei.create(this, t, this._def) } transform(t) { return new un({ ...ie(this._def), schema: this, typeName: te.ZodEffects, effect: { type: "transform", transform: t } }) } default(t) { const n = typeof t == "function" ? t : () => t; return new Ai({ ...ie(this._def), innerType: this, defaultValue: n, typeName: te.ZodDefault }) } brand() { return new Vf({ typeName: te.ZodBranded, type: this, ...ie(this._def) }) } catch(t) { const n = typeof t == "function" ? t : () => t; return new ji({ ...ie(this._def), innerType: this, catchValue: n, typeName: te.ZodCatch }) } describe(t) { const n = this.constructor; return new n({ ...this._def, description: t }) } pipe(t) { return Zi.create(this, t) } readonly() { return Oi.create(this) } isOptional() { return this.safeParse(void 0).success } isNullable() { return this.safeParse(null).success } } const yE = /^c[^\s-]{8,}$/i, xE = /^[0-9a-z]+$/, wE = /^[0-9A-HJKMNP-TV-Z]{26}$/i, SE = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, _E = /^[a-z0-9_-]{21}$/i, CE = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, kE = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, bE = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, EE = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$"; let Ku; const TE = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, NE = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, PE = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, RE = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, AE = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, jE = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, jx = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", OE = new RegExp(`^${jx}$`); function Ox(e) { let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"; return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t } function ME(e) { return new RegExp(`^${Ox(e)}$`) } function Mx(e) { let t = `${jx}T${Ox(e)}`; const n = []; return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`) } function IE(e, t) { return !!((t === "v4" || !t) && TE.test(e) || (t === "v6" || !t) && PE.test(e)) } function LE(e, t) { if (!CE.test(e)) return !1; try { const [n] = e.split("."), r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), s = JSON.parse(atob(r)); return !(typeof s != "object" || s === null || !s.typ || !s.alg || t && s.alg !== t) } catch { return !1 } } function DE(e, t) { return !!((t === "v4" || !t) && NE.test(e) || (t === "v6" || !t) && RE.test(e)) } class tn extends le { _parse(t) { if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== W.string) { const o = this._getOrReturnCtx(t); return B(o, { code: M.invalid_type, expected: W.string, received: o.parsedType }), ne } const r = new ut; let s; for (const o of this._def.checks) if (o.kind === "min") t.data.length < o.value && (s = this._getOrReturnCtx(t, s), B(s, { code: M.too_small, minimum: o.value, type: "string", inclusive: !0, exact: !1, message: o.message }), r.dirty()); else if (o.kind === "max") t.data.length > o.value && (s = this._getOrReturnCtx(t, s), B(s, { code: M.too_big, maximum: o.value, type: "string", inclusive: !0, exact: !1, message: o.message }), r.dirty()); else if (o.kind === "length") { const i = t.data.length > o.value, a = t.data.length < o.value; (i || a) && (s = this._getOrReturnCtx(t, s), i ? B(s, { code: M.too_big, maximum: o.value, type: "string", inclusive: !0, exact: !0, message: o.message }) : a && B(s, { code: M.too_small, minimum: o.value, type: "string", inclusive: !0, exact: !0, message: o.message }), r.dirty()) } else if (o.kind === "email") bE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "email", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "emoji") Ku || (Ku = new RegExp(EE, "u")), Ku.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "emoji", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "uuid") SE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "uuid", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "nanoid") _E.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "nanoid", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "cuid") yE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "cuid", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "cuid2") xE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "cuid2", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "ulid") wE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "ulid", code: M.invalid_string, message: o.message }), r.dirty()); else if (o.kind === "url") try { new URL(t.data) } catch { s = this._getOrReturnCtx(t, s), B(s, { validation: "url", code: M.invalid_string, message: o.message }), r.dirty() } else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "regex", code: M.invalid_string, message: o.message }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (s = this._getOrReturnCtx(t, s), B(s, { code: M.invalid_string, validation: { includes: o.value, position: o.position }, message: o.message }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (s = this._getOrReturnCtx(t, s), B(s, { code: M.invalid_string, validation: { startsWith: o.value }, message: o.message }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (s = this._getOrReturnCtx(t, s), B(s, { code: M.invalid_string, validation: { endsWith: o.value }, message: o.message }), r.dirty()) : o.kind === "datetime" ? Mx(o).test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { code: M.invalid_string, validation: "datetime", message: o.message }), r.dirty()) : o.kind === "date" ? OE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { code: M.invalid_string, validation: "date", message: o.message }), r.dirty()) : o.kind === "time" ? ME(o).test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { code: M.invalid_string, validation: "time", message: o.message }), r.dirty()) : o.kind === "duration" ? kE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "duration", code: M.invalid_string, message: o.message }), r.dirty()) : o.kind === "ip" ? IE(t.data, o.version) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "ip", code: M.invalid_string, message: o.message }), r.dirty()) : o.kind === "jwt" ? LE(t.data, o.alg) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "jwt", code: M.invalid_string, message: o.message }), r.dirty()) : o.kind === "cidr" ? DE(t.data, o.version) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "cidr", code: M.invalid_string, message: o.message }), r.dirty()) : o.kind === "base64" ? AE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "base64", code: M.invalid_string, message: o.message }), r.dirty()) : o.kind === "base64url" ? jE.test(t.data) || (s = this._getOrReturnCtx(t, s), B(s, { validation: "base64url", code: M.invalid_string, message: o.message }), r.dirty()) : fe.assertNever(o); return { status: r.value, value: t.data } } _regex(t, n, r) { return this.refinement(s => t.test(s), { validation: n, code: M.invalid_string, ...q.errToObj(r) }) } _addCheck(t) { return new tn({ ...this._def, checks: [...this._def.checks, t] }) } email(t) { return this._addCheck({ kind: "email", ...q.errToObj(t) }) } url(t) { return this._addCheck({ kind: "url", ...q.errToObj(t) }) } emoji(t) { return this._addCheck({ kind: "emoji", ...q.errToObj(t) }) } uuid(t) { return this._addCheck({ kind: "uuid", ...q.errToObj(t) }) } nanoid(t) { return this._addCheck({ kind: "nanoid", ...q.errToObj(t) }) } cuid(t) { return this._addCheck({ kind: "cuid", ...q.errToObj(t) }) } cuid2(t) { return this._addCheck({ kind: "cuid2", ...q.errToObj(t) }) } ulid(t) { return this._addCheck({ kind: "ulid", ...q.errToObj(t) }) } base64(t) { return this._addCheck({ kind: "base64", ...q.errToObj(t) }) } base64url(t) { return this._addCheck({ kind: "base64url", ...q.errToObj(t) }) } jwt(t) { return this._addCheck({ kind: "jwt", ...q.errToObj(t) }) } ip(t) { return this._addCheck({ kind: "ip", ...q.errToObj(t) }) } cidr(t) { return this._addCheck({ kind: "cidr", ...q.errToObj(t) }) } datetime(t) { var n, r; return typeof t == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: t }) : this._addCheck({ kind: "datetime", precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision, offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1, local: (r = t == null ? void 0 : t.local) !== null && r !== void 0 ? r : !1, ...q.errToObj(t == null ? void 0 : t.message) }) } date(t) { return this._addCheck({ kind: "date", message: t }) } time(t) { return typeof t == "string" ? this._addCheck({ kind: "time", precision: null, message: t }) : this._addCheck({ kind: "time", precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision, ...q.errToObj(t == null ? void 0 : t.message) }) } duration(t) { return this._addCheck({ kind: "duration", ...q.errToObj(t) }) } regex(t, n) { return this._addCheck({ kind: "regex", regex: t, ...q.errToObj(n) }) } includes(t, n) { return this._addCheck({ kind: "includes", value: t, position: n == null ? void 0 : n.position, ...q.errToObj(n == null ? void 0 : n.message) }) } startsWith(t, n) { return this._addCheck({ kind: "startsWith", value: t, ...q.errToObj(n) }) } endsWith(t, n) { return this._addCheck({ kind: "endsWith", value: t, ...q.errToObj(n) }) } min(t, n) { return this._addCheck({ kind: "min", value: t, ...q.errToObj(n) }) } max(t, n) { return this._addCheck({ kind: "max", value: t, ...q.errToObj(n) }) } length(t, n) { return this._addCheck({ kind: "length", value: t, ...q.errToObj(n) }) } nonempty(t) { return this.min(1, q.errToObj(t)) } trim() { return new tn({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }) } toLowerCase() { return new tn({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] }) } toUpperCase() { return new tn({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] }) } get isDatetime() { return !!this._def.checks.find(t => t.kind === "datetime") } get isDate() { return !!this._def.checks.find(t => t.kind === "date") } get isTime() { return !!this._def.checks.find(t => t.kind === "time") } get isDuration() { return !!this._def.checks.find(t => t.kind === "duration") } get isEmail() { return !!this._def.checks.find(t => t.kind === "email") } get isURL() { return !!this._def.checks.find(t => t.kind === "url") } get isEmoji() { return !!this._def.checks.find(t => t.kind === "emoji") } get isUUID() { return !!this._def.checks.find(t => t.kind === "uuid") } get isNANOID() { return !!this._def.checks.find(t => t.kind === "nanoid") } get isCUID() { return !!this._def.checks.find(t => t.kind === "cuid") } get isCUID2() { return !!this._def.checks.find(t => t.kind === "cuid2") } get isULID() { return !!this._def.checks.find(t => t.kind === "ulid") } get isIP() { return !!this._def.checks.find(t => t.kind === "ip") } get isCIDR() { return !!this._def.checks.find(t => t.kind === "cidr") } get isBase64() { return !!this._def.checks.find(t => t.kind === "base64") } get isBase64url() { return !!this._def.checks.find(t => t.kind === "base64url") } get minLength() { let t = null; for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value); return t } get maxLength() { let t = null; for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value); return t } } tn.create = e => { var t; return new tn({ checks: [], typeName: te.ZodString, coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1, ...ie(e) }) }; function FE(e, t) { const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, s = n > r ? n : r, o = parseInt(e.toFixed(s).replace(".", "")), i = parseInt(t.toFixed(s).replace(".", "")); return o % i / Math.pow(10, s) } class Er extends le { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf } _parse(t) { if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== W.number) { const o = this._getOrReturnCtx(t); return B(o, { code: M.invalid_type, expected: W.number, received: o.parsedType }), ne } let r; const s = new ut; for (const o of this._def.checks) o.kind === "int" ? fe.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), B(r, { code: M.invalid_type, expected: "integer", received: "float", message: o.message }), s.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), B(r, { code: M.too_small, minimum: o.value, type: "number", inclusive: o.inclusive, exact: !1, message: o.message }), s.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), B(r, { code: M.too_big, maximum: o.value, type: "number", inclusive: o.inclusive, exact: !1, message: o.message }), s.dirty()) : o.kind === "multipleOf" ? FE(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), B(r, { code: M.not_multiple_of, multipleOf: o.value, message: o.message }), s.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), B(r, { code: M.not_finite, message: o.message }), s.dirty()) : fe.assertNever(o); return { status: s.value, value: t.data } } gte(t, n) { return this.setLimit("min", t, !0, q.toString(n)) } gt(t, n) { return this.setLimit("min", t, !1, q.toString(n)) } lte(t, n) { return this.setLimit("max", t, !0, q.toString(n)) } lt(t, n) { return this.setLimit("max", t, !1, q.toString(n)) } setLimit(t, n, r, s) { return new Er({ ...this._def, checks: [...this._def.checks, { kind: t, value: n, inclusive: r, message: q.toString(s) }] }) } _addCheck(t) { return new Er({ ...this._def, checks: [...this._def.checks, t] }) } int(t) { return this._addCheck({ kind: "int", message: q.toString(t) }) } positive(t) { return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: q.toString(t) }) } negative(t) { return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: q.toString(t) }) } nonpositive(t) { return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: q.toString(t) }) } nonnegative(t) { return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: q.toString(t) }) } multipleOf(t, n) { return this._addCheck({ kind: "multipleOf", value: t, message: q.toString(n) }) } finite(t) { return this._addCheck({ kind: "finite", message: q.toString(t) }) } safe(t) { return this._addCheck({ kind: "min", inclusive: !0, value: Number.MIN_SAFE_INTEGER, message: q.toString(t) })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: q.toString(t) }) } get minValue() { let t = null; for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value); return t } get maxValue() { let t = null; for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value); return t } get isInt() { return !!this._def.checks.find(t => t.kind === "int" || t.kind === "multipleOf" && fe.isInteger(t.value)) } get isFinite() { let t = null, n = null; for (const r of this._def.checks) { if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0; r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value) } return Number.isFinite(n) && Number.isFinite(t) } } Er.create = e => new Er({ checks: [], typeName: te.ZodNumber, coerce: (e == null ? void 0 : e.coerce) || !1, ...ie(e) }); class Tr extends le { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte } _parse(t) { if (this._def.coerce) try { t.data = BigInt(t.data) } catch { return this._getInvalidInput(t) } if (this._getType(t) !== W.bigint) return this._getInvalidInput(t); let r; const s = new ut; for (const o of this._def.checks) o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), B(r, { code: M.too_small, type: "bigint", minimum: o.value, inclusive: o.inclusive, message: o.message }), s.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), B(r, { code: M.too_big, type: "bigint", maximum: o.value, inclusive: o.inclusive, message: o.message }), s.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), B(r, { code: M.not_multiple_of, multipleOf: o.value, message: o.message }), s.dirty()) : fe.assertNever(o); return { status: s.value, value: t.data } } _getInvalidInput(t) { const n = this._getOrReturnCtx(t); return B(n, { code: M.invalid_type, expected: W.bigint, received: n.parsedType }), ne } gte(t, n) { return this.setLimit("min", t, !0, q.toString(n)) } gt(t, n) { return this.setLimit("min", t, !1, q.toString(n)) } lte(t, n) { return this.setLimit("max", t, !0, q.toString(n)) } lt(t, n) { return this.setLimit("max", t, !1, q.toString(n)) } setLimit(t, n, r, s) { return new Tr({ ...this._def, checks: [...this._def.checks, { kind: t, value: n, inclusive: r, message: q.toString(s) }] }) } _addCheck(t) { return new Tr({ ...this._def, checks: [...this._def.checks, t] }) } positive(t) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: q.toString(t) }) } negative(t) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: q.toString(t) }) } nonpositive(t) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: q.toString(t) }) } nonnegative(t) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: q.toString(t) }) } multipleOf(t, n) { return this._addCheck({ kind: "multipleOf", value: t, message: q.toString(n) }) } get minValue() { let t = null; for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value); return t } get maxValue() { let t = null; for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value); return t } } Tr.create = e => { var t; return new Tr({ checks: [], typeName: te.ZodBigInt, coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1, ...ie(e) }) }; class _i extends le { _parse(t) { if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== W.boolean) { const r = this._getOrReturnCtx(t); return B(r, { code: M.invalid_type, expected: W.boolean, received: r.parsedType }), ne } return vt(t.data) } } _i.create = e => new _i({ typeName: te.ZodBoolean, coerce: (e == null ? void 0 : e.coerce) || !1, ...ie(e) }); class rs extends le { _parse(t) { if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== W.date) { const o = this._getOrReturnCtx(t); return B(o, { code: M.invalid_type, expected: W.date, received: o.parsedType }), ne } if (isNaN(t.data.getTime())) { const o = this._getOrReturnCtx(t); return B(o, { code: M.invalid_date }), ne } const r = new ut; let s; for (const o of this._def.checks) o.kind === "min" ? t.data.getTime() < o.value && (s = this._getOrReturnCtx(t, s), B(s, { code: M.too_small, message: o.message, inclusive: !0, exact: !1, minimum: o.value, type: "date" }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (s = this._getOrReturnCtx(t, s), B(s, { code: M.too_big, message: o.message, inclusive: !0, exact: !1, maximum: o.value, type: "date" }), r.dirty()) : fe.assertNever(o); return { status: r.value, value: new Date(t.data.getTime()) } } _addCheck(t) { return new rs({ ...this._def, checks: [...this._def.checks, t] }) } min(t, n) { return this._addCheck({ kind: "min", value: t.getTime(), message: q.toString(n) }) } max(t, n) { return this._addCheck({ kind: "max", value: t.getTime(), message: q.toString(n) }) } get minDate() { let t = null; for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value); return t != null ? new Date(t) : null } get maxDate() { let t = null; for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value); return t != null ? new Date(t) : null } } rs.create = e => new rs({ checks: [], coerce: (e == null ? void 0 : e.coerce) || !1, typeName: te.ZodDate, ...ie(e) }); class _l extends le { _parse(t) { if (this._getType(t) !== W.symbol) { const r = this._getOrReturnCtx(t); return B(r, { code: M.invalid_type, expected: W.symbol, received: r.parsedType }), ne } return vt(t.data) } } _l.create = e => new _l({ typeName: te.ZodSymbol, ...ie(e) }); class Ci extends le { _parse(t) { if (this._getType(t) !== W.undefined) { const r = this._getOrReturnCtx(t); return B(r, { code: M.invalid_type, expected: W.undefined, received: r.parsedType }), ne } return vt(t.data) } } Ci.create = e => new Ci({ typeName: te.ZodUndefined, ...ie(e) }); class ki extends le { _parse(t) { if (this._getType(t) !== W.null) { const r = this._getOrReturnCtx(t); return B(r, { code: M.invalid_type, expected: W.null, received: r.parsedType }), ne } return vt(t.data) } } ki.create = e => new ki({ typeName: te.ZodNull, ...ie(e) }); class lo extends le { constructor() { super(...arguments), this._any = !0 } _parse(t) { return vt(t.data) } } lo.create = e => new lo({ typeName: te.ZodAny, ...ie(e) }); class Qr extends le { constructor() { super(...arguments), this._unknown = !0 } _parse(t) { return vt(t.data) } } Qr.create = e => new Qr({ typeName: te.ZodUnknown, ...ie(e) }); class Wn extends le { _parse(t) { const n = this._getOrReturnCtx(t); return B(n, { code: M.invalid_type, expected: W.never, received: n.parsedType }), ne } } Wn.create = e => new Wn({ typeName: te.ZodNever, ...ie(e) }); class Cl extends le { _parse(t) { if (this._getType(t) !== W.undefined) { const r = this._getOrReturnCtx(t); return B(r, { code: M.invalid_type, expected: W.void, received: r.parsedType }), ne } return vt(t.data) } } Cl.create = e => new Cl({ typeName: te.ZodVoid, ...ie(e) }); class sn extends le { _parse(t) { const { ctx: n, status: r } = this._processInputParams(t), s = this._def; if (n.parsedType !== W.array) return B(n, { code: M.invalid_type, expected: W.array, received: n.parsedType }), ne; if (s.exactLength !== null) { const i = n.data.length > s.exactLength.value, a = n.data.length < s.exactLength.value; (i || a) && (B(n, { code: i ? M.too_big : M.too_small, minimum: a ? s.exactLength.value : void 0, maximum: i ? s.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: s.exactLength.message }), r.dirty()) } if (s.minLength !== null && n.data.length < s.minLength.value && (B(n, { code: M.too_small, minimum: s.minLength.value, type: "array", inclusive: !0, exact: !1, message: s.minLength.message }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (B(n, { code: M.too_big, maximum: s.maxLength.value, type: "array", inclusive: !0, exact: !1, message: s.maxLength.message }), r.dirty()), n.common.async) return Promise.all([...n.data].map((i, a) => s.type._parseAsync(new Cn(n, i, n.path, a)))).then(i => ut.mergeArray(r, i)); const o = [...n.data].map((i, a) => s.type._parseSync(new Cn(n, i, n.path, a))); return ut.mergeArray(r, o) } get element() { return this._def.type } min(t, n) { return new sn({ ...this._def, minLength: { value: t, message: q.toString(n) } }) } max(t, n) { return new sn({ ...this._def, maxLength: { value: t, message: q.toString(n) } }) } length(t, n) { return new sn({ ...this._def, exactLength: { value: t, message: q.toString(n) } }) } nonempty(t) { return this.min(1, t) } } sn.create = (e, t) => new sn({ type: e, minLength: null, maxLength: null, exactLength: null, typeName: te.ZodArray, ...ie(t) }); function vs(e) { if (e instanceof Pe) { const t = {}; for (const n in e.shape) { const r = e.shape[n]; t[n] = Sn.create(vs(r)) } return new Pe({ ...e._def, shape: () => t }) } else return e instanceof sn ? new sn({ ...e._def, type: vs(e.element) }) : e instanceof Sn ? Sn.create(vs(e.unwrap())) : e instanceof Pr ? Pr.create(vs(e.unwrap())) : e instanceof kn ? kn.create(e.items.map(t => vs(t))) : e } class Pe extends le { constructor() { super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend } _getCached() { if (this._cached !== null) return this._cached; const t = this._def.shape(), n = fe.objectKeys(t); return this._cached = { shape: t, keys: n } } _parse(t) { if (this._getType(t) !== W.object) { const u = this._getOrReturnCtx(t); return B(u, { code: M.invalid_type, expected: W.object, received: u.parsedType }), ne } const { status: r, ctx: s } = this._processInputParams(t), { shape: o, keys: i } = this._getCached(), a = []; if (!(this._def.catchall instanceof Wn && this._def.unknownKeys === "strip")) for (const u in s.data) i.includes(u) || a.push(u); const l = []; for (const u of i) { const c = o[u], p = s.data[u]; l.push({ key: { status: "valid", value: u }, value: c._parse(new Cn(s, p, s.path, u)), alwaysSet: u in s.data }) } if (this._def.catchall instanceof Wn) { const u = this._def.unknownKeys; if (u === "passthrough") for (const c of a) l.push({ key: { status: "valid", value: c }, value: { status: "valid", value: s.data[c] } }); else if (u === "strict") a.length > 0 && (B(s, { code: M.unrecognized_keys, keys: a }), r.dirty()); else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.") } else { const u = this._def.catchall; for (const c of a) { const p = s.data[c]; l.push({ key: { status: "valid", value: c }, value: u._parse(new Cn(s, p, s.path, c)), alwaysSet: c in s.data }) } } return s.common.async ? Promise.resolve().then(async () => { const u = []; for (const c of l) { const p = await c.key, h = await c.value; u.push({ key: p, value: h, alwaysSet: c.alwaysSet }) } return u }).then(u => ut.mergeObjectSync(r, u)) : ut.mergeObjectSync(r, l) } get shape() { return this._def.shape() } strict(t) { return q.errToObj, new Pe({ ...this._def, unknownKeys: "strict", ...t !== void 0 ? { errorMap: (n, r) => { var s, o, i, a; const l = (i = (o = (s = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(s, n, r).message) !== null && i !== void 0 ? i : r.defaultError; return n.code === "unrecognized_keys" ? { message: (a = q.errToObj(t).message) !== null && a !== void 0 ? a : l } : { message: l } } } : {} }) } strip() { return new Pe({ ...this._def, unknownKeys: "strip" }) } passthrough() { return new Pe({ ...this._def, unknownKeys: "passthrough" }) } extend(t) { return new Pe({ ...this._def, shape: () => ({ ...this._def.shape(), ...t }) }) } merge(t) { return new Pe({ unknownKeys: t._def.unknownKeys, catchall: t._def.catchall, shape: () => ({ ...this._def.shape(), ...t._def.shape() }), typeName: te.ZodObject }) } setKey(t, n) { return this.augment({ [t]: n }) } catchall(t) { return new Pe({ ...this._def, catchall: t }) } pick(t) { const n = {}; return fe.objectKeys(t).forEach(r => { t[r] && this.shape[r] && (n[r] = this.shape[r]) }), new Pe({ ...this._def, shape: () => n }) } omit(t) { const n = {}; return fe.objectKeys(this.shape).forEach(r => { t[r] || (n[r] = this.shape[r]) }), new Pe({ ...this._def, shape: () => n }) } deepPartial() { return vs(this) } partial(t) { const n = {}; return fe.objectKeys(this.shape).forEach(r => { const s = this.shape[r]; t && !t[r] ? n[r] = s : n[r] = s.optional() }), new Pe({ ...this._def, shape: () => n }) } required(t) { const n = {}; return fe.objectKeys(this.shape).forEach(r => { if (t && !t[r]) n[r] = this.shape[r]; else { let o = this.shape[r]; for (; o instanceof Sn;)o = o._def.innerType; n[r] = o } }), new Pe({ ...this._def, shape: () => n }) } keyof() { return Ix(fe.objectKeys(this.shape)) } } Pe.create = (e, t) => new Pe({ shape: () => e, unknownKeys: "strip", catchall: Wn.create(), typeName: te.ZodObject, ...ie(t) }); Pe.strictCreate = (e, t) => new Pe({ shape: () => e, unknownKeys: "strict", catchall: Wn.create(), typeName: te.ZodObject, ...ie(t) }); Pe.lazycreate = (e, t) => new Pe({ shape: e, unknownKeys: "strip", catchall: Wn.create(), typeName: te.ZodObject, ...ie(t) }); class bi extends le { _parse(t) { const { ctx: n } = this._processInputParams(t), r = this._def.options; function s(o) { for (const a of o) if (a.result.status === "valid") return a.result; for (const a of o) if (a.result.status === "dirty") return n.common.issues.push(...a.ctx.common.issues), a.result; const i = o.map(a => new Mt(a.ctx.common.issues)); return B(n, { code: M.invalid_union, unionErrors: i }), ne } if (n.common.async) return Promise.all(r.map(async o => { const i = { ...n, common: { ...n.common, issues: [] }, parent: null }; return { result: await o._parseAsync({ data: n.data, path: n.path, parent: i }), ctx: i } })).then(s); { let o; const i = []; for (const l of r) { const u = { ...n, common: { ...n.common, issues: [] }, parent: null }, c = l._parseSync({ data: n.data, path: n.path, parent: u }); if (c.status === "valid") return c; c.status === "dirty" && !o && (o = { result: c, ctx: u }), u.common.issues.length && i.push(u.common.issues) } if (o) return n.common.issues.push(...o.ctx.common.issues), o.result; const a = i.map(l => new Mt(l)); return B(n, { code: M.invalid_union, unionErrors: a }), ne } } get options() { return this._def.options } } bi.create = (e, t) => new bi({ options: e, typeName: te.ZodUnion, ...ie(t) }); const Pn = e => e instanceof Ni ? Pn(e.schema) : e instanceof un ? Pn(e.innerType()) : e instanceof Pi ? [e.value] : e instanceof Nr ? e.options : e instanceof Ri ? fe.objectValues(e.enum) : e instanceof Ai ? Pn(e._def.innerType) : e instanceof Ci ? [void 0] : e instanceof ki ? [null] : e instanceof Sn ? [void 0, ...Pn(e.unwrap())] : e instanceof Pr ? [null, ...Pn(e.unwrap())] : e instanceof Vf || e instanceof Oi ? Pn(e.unwrap()) : e instanceof ji ? Pn(e._def.innerType) : []; class nu extends le { _parse(t) { const { ctx: n } = this._processInputParams(t); if (n.parsedType !== W.object) return B(n, { code: M.invalid_type, expected: W.object, received: n.parsedType }), ne; const r = this.discriminator, s = n.data[r], o = this.optionsMap.get(s); return o ? n.common.async ? o._parseAsync({ data: n.data, path: n.path, parent: n }) : o._parseSync({ data: n.data, path: n.path, parent: n }) : (B(n, { code: M.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [r] }), ne) } get discriminator() { return this._def.discriminator } get options() { return this._def.options } get optionsMap() { return this._def.optionsMap } static create(t, n, r) { const s = new Map; for (const o of n) { const i = Pn(o.shape[t]); if (!i.length) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`); for (const a of i) { if (s.has(a)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`); s.set(a, o) } } return new nu({ typeName: te.ZodDiscriminatedUnion, discriminator: t, options: n, optionsMap: s, ...ie(r) }) } } function ud(e, t) { const n = jn(e), r = jn(t); if (e === t) return { valid: !0, data: e }; if (n === W.object && r === W.object) { const s = fe.objectKeys(t), o = fe.objectKeys(e).filter(a => s.indexOf(a) !== -1), i = { ...e, ...t }; for (const a of o) { const l = ud(e[a], t[a]); if (!l.valid) return { valid: !1 }; i[a] = l.data } return { valid: !0, data: i } } else if (n === W.array && r === W.array) { if (e.length !== t.length) return { valid: !1 }; const s = []; for (let o = 0; o < e.length; o++) { const i = e[o], a = t[o], l = ud(i, a); if (!l.valid) return { valid: !1 }; s.push(l.data) } return { valid: !0, data: s } } else return n === W.date && r === W.date && +e == +t ? { valid: !0, data: e } : { valid: !1 } } class Ei extends le { _parse(t) { const { status: n, ctx: r } = this._processInputParams(t), s = (o, i) => { if (ad(o) || ad(i)) return ne; const a = ud(o.value, i.value); return a.valid ? ((ld(o) || ld(i)) && n.dirty(), { status: n.value, value: a.data }) : (B(r, { code: M.invalid_intersection_types }), ne) }; return r.common.async ? Promise.all([this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }), this._def.right._parseAsync({ data: r.data, path: r.path, parent: r })]).then(([o, i]) => s(o, i)) : s(this._def.left._parseSync({ data: r.data, path: r.path, parent: r }), this._def.right._parseSync({ data: r.data, path: r.path, parent: r })) } } Ei.create = (e, t, n) => new Ei({ left: e, right: t, typeName: te.ZodIntersection, ...ie(n) }); class kn extends le { _parse(t) { const { status: n, ctx: r } = this._processInputParams(t); if (r.parsedType !== W.array) return B(r, { code: M.invalid_type, expected: W.array, received: r.parsedType }), ne; if (r.data.length < this._def.items.length) return B(r, { code: M.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), ne; !this._def.rest && r.data.length > this._def.items.length && (B(r, { code: M.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), n.dirty()); const o = [...r.data].map((i, a) => { const l = this._def.items[a] || this._def.rest; return l ? l._parse(new Cn(r, i, r.path, a)) : null }).filter(i => !!i); return r.common.async ? Promise.all(o).then(i => ut.mergeArray(n, i)) : ut.mergeArray(n, o) } get items() { return this._def.items } rest(t) { return new kn({ ...this._def, rest: t }) } } kn.create = (e, t) => { if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])"); return new kn({ items: e, typeName: te.ZodTuple, rest: null, ...ie(t) }) }; class Ti extends le { get keySchema() { return this._def.keyType } get valueSchema() { return this._def.valueType } _parse(t) { const { status: n, ctx: r } = this._processInputParams(t); if (r.parsedType !== W.object) return B(r, { code: M.invalid_type, expected: W.object, received: r.parsedType }), ne; const s = [], o = this._def.keyType, i = this._def.valueType; for (const a in r.data) s.push({ key: o._parse(new Cn(r, a, r.path, a)), value: i._parse(new Cn(r, r.data[a], r.path, a)), alwaysSet: a in r.data }); return r.common.async ? ut.mergeObjectAsync(n, s) : ut.mergeObjectSync(n, s) } get element() { return this._def.valueType } static create(t, n, r) { return n instanceof le ? new Ti({ keyType: t, valueType: n, typeName: te.ZodRecord, ...ie(r) }) : new Ti({ keyType: tn.create(), valueType: t, typeName: te.ZodRecord, ...ie(n) }) } } class kl extends le { get keySchema() { return this._def.keyType } get valueSchema() { return this._def.valueType } _parse(t) { const { status: n, ctx: r } = this._processInputParams(t); if (r.parsedType !== W.map) return B(r, { code: M.invalid_type, expected: W.map, received: r.parsedType }), ne; const s = this._def.keyType, o = this._def.valueType, i = [...r.data.entries()].map(([a, l], u) => ({ key: s._parse(new Cn(r, a, r.path, [u, "key"])), value: o._parse(new Cn(r, l, r.path, [u, "value"])) })); if (r.common.async) { const a = new Map; return Promise.resolve().then(async () => { for (const l of i) { const u = await l.key, c = await l.value; if (u.status === "aborted" || c.status === "aborted") return ne; (u.status === "dirty" || c.status === "dirty") && n.dirty(), a.set(u.value, c.value) } return { status: n.value, value: a } }) } else { const a = new Map; for (const l of i) { const u = l.key, c = l.value; if (u.status === "aborted" || c.status === "aborted") return ne; (u.status === "dirty" || c.status === "dirty") && n.dirty(), a.set(u.value, c.value) } return { status: n.value, value: a } } } } kl.create = (e, t, n) => new kl({ valueType: t, keyType: e, typeName: te.ZodMap, ...ie(n) }); class ss extends le { _parse(t) { const { status: n, ctx: r } = this._processInputParams(t); if (r.parsedType !== W.set) return B(r, { code: M.invalid_type, expected: W.set, received: r.parsedType }), ne; const s = this._def; s.minSize !== null && r.data.size < s.minSize.value && (B(r, { code: M.too_small, minimum: s.minSize.value, type: "set", inclusive: !0, exact: !1, message: s.minSize.message }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (B(r, { code: M.too_big, maximum: s.maxSize.value, type: "set", inclusive: !0, exact: !1, message: s.maxSize.message }), n.dirty()); const o = this._def.valueType; function i(l) { const u = new Set; for (const c of l) { if (c.status === "aborted") return ne; c.status === "dirty" && n.dirty(), u.add(c.value) } return { status: n.value, value: u } } const a = [...r.data.values()].map((l, u) => o._parse(new Cn(r, l, r.path, u))); return r.common.async ? Promise.all(a).then(l => i(l)) : i(a) } min(t, n) { return new ss({ ...this._def, minSize: { value: t, message: q.toString(n) } }) } max(t, n) { return new ss({ ...this._def, maxSize: { value: t, message: q.toString(n) } }) } size(t, n) { return this.min(t, n).max(t, n) } nonempty(t) { return this.min(1, t) } } ss.create = (e, t) => new ss({ valueType: e, minSize: null, maxSize: null, typeName: te.ZodSet, ...ie(t) }); class Vs extends le { constructor() { super(...arguments), this.validate = this.implement } _parse(t) { const { ctx: n } = this._processInputParams(t); if (n.parsedType !== W.function) return B(n, { code: M.invalid_type, expected: W.function, received: n.parsedType }), ne; function r(a, l) { return wl({ data: a, path: n.path, errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, xl(), ao].filter(u => !!u), issueData: { code: M.invalid_arguments, argumentsError: l } }) } function s(a, l) { return wl({ data: a, path: n.path, errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, xl(), ao].filter(u => !!u), issueData: { code: M.invalid_return_type, returnTypeError: l } }) } const o = { errorMap: n.common.contextualErrorMap }, i = n.data; if (this._def.returns instanceof uo) { const a = this; return vt(async function (...l) { const u = new Mt([]), c = await a._def.args.parseAsync(l, o).catch(w => { throw u.addIssue(r(l, w)), u }), p = await Reflect.apply(i, this, c); return await a._def.returns._def.type.parseAsync(p, o).catch(w => { throw u.addIssue(s(p, w)), u }) }) } else { const a = this; return vt(function (...l) { const u = a._def.args.safeParse(l, o); if (!u.success) throw new Mt([r(l, u.error)]); const c = Reflect.apply(i, this, u.data), p = a._def.returns.safeParse(c, o); if (!p.success) throw new Mt([s(c, p.error)]); return p.data }) } } parameters() { return this._def.args } returnType() { return this._def.returns } args(...t) { return new Vs({ ...this._def, args: kn.create(t).rest(Qr.create()) }) } returns(t) { return new Vs({ ...this._def, returns: t }) } implement(t) { return this.parse(t) } strictImplement(t) { return this.parse(t) } static create(t, n, r) { return new Vs({ args: t || kn.create([]).rest(Qr.create()), returns: n || Qr.create(), typeName: te.ZodFunction, ...ie(r) }) } } class Ni extends le { get schema() { return this._def.getter() } _parse(t) { const { ctx: n } = this._processInputParams(t); return this._def.getter()._parse({ data: n.data, path: n.path, parent: n }) } } Ni.create = (e, t) => new Ni({ getter: e, typeName: te.ZodLazy, ...ie(t) }); class Pi extends le { _parse(t) { if (t.data !== this._def.value) { const n = this._getOrReturnCtx(t); return B(n, { received: n.data, code: M.invalid_literal, expected: this._def.value }), ne } return { status: "valid", value: t.data } } get value() { return this._def.value } } Pi.create = (e, t) => new Pi({ value: e, typeName: te.ZodLiteral, ...ie(t) }); function Ix(e, t) { return new Nr({ values: e, typeName: te.ZodEnum, ...ie(t) }) } class Nr extends le { constructor() { super(...arguments), Io.set(this, void 0) } _parse(t) { if (typeof t.data != "string") { const n = this._getOrReturnCtx(t), r = this._def.values; return B(n, { expected: fe.joinValues(r), received: n.parsedType, code: M.invalid_type }), ne } if (Sl(this, Io) || Ax(this, Io, new Set(this._def.values)), !Sl(this, Io).has(t.data)) { const n = this._getOrReturnCtx(t), r = this._def.values; return B(n, { received: n.data, code: M.invalid_enum_value, options: r }), ne } return vt(t.data) } get options() { return this._def.values } get enum() { const t = {}; for (const n of this._def.values) t[n] = n; return t } get Values() { const t = {}; for (const n of this._def.values) t[n] = n; return t } get Enum() { const t = {}; for (const n of this._def.values) t[n] = n; return t } extract(t, n = this._def) { return Nr.create(t, { ...this._def, ...n }) } exclude(t, n = this._def) { return Nr.create(this.options.filter(r => !t.includes(r)), { ...this._def, ...n }) } } Io = new WeakMap; Nr.create = Ix; class Ri extends le { constructor() { super(...arguments), Lo.set(this, void 0) } _parse(t) { const n = fe.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t); if (r.parsedType !== W.string && r.parsedType !== W.number) { const s = fe.objectValues(n); return B(r, { expected: fe.joinValues(s), received: r.parsedType, code: M.invalid_type }), ne } if (Sl(this, Lo) || Ax(this, Lo, new Set(fe.getValidEnumValues(this._def.values))), !Sl(this, Lo).has(t.data)) { const s = fe.objectValues(n); return B(r, { received: r.data, code: M.invalid_enum_value, options: s }), ne } return vt(t.data) } get enum() { return this._def.values } } Lo = new WeakMap; Ri.create = (e, t) => new Ri({ values: e, typeName: te.ZodNativeEnum, ...ie(t) }); class uo extends le { unwrap() { return this._def.type } _parse(t) { const { ctx: n } = this._processInputParams(t); if (n.parsedType !== W.promise && n.common.async === !1) return B(n, { code: M.invalid_type, expected: W.promise, received: n.parsedType }), ne; const r = n.parsedType === W.promise ? n.data : Promise.resolve(n.data); return vt(r.then(s => this._def.type.parseAsync(s, { path: n.path, errorMap: n.common.contextualErrorMap }))) } } uo.create = (e, t) => new uo({ type: e, typeName: te.ZodPromise, ...ie(t) }); class un extends le { innerType() { return this._def.schema } sourceType() { return this._def.schema._def.typeName === te.ZodEffects ? this._def.schema.sourceType() : this._def.schema } _parse(t) { const { status: n, ctx: r } = this._processInputParams(t), s = this._def.effect || null, o = { addIssue: i => { B(r, i), i.fatal ? n.abort() : n.dirty() }, get path() { return r.path } }; if (o.addIssue = o.addIssue.bind(o), s.type === "preprocess") { const i = s.transform(r.data, o); if (r.common.async) return Promise.resolve(i).then(async a => { if (n.value === "aborted") return ne; const l = await this._def.schema._parseAsync({ data: a, path: r.path, parent: r }); return l.status === "aborted" ? ne : l.status === "dirty" || n.value === "dirty" ? Rs(l.value) : l }); { if (n.value === "aborted") return ne; const a = this._def.schema._parseSync({ data: i, path: r.path, parent: r }); return a.status === "aborted" ? ne : a.status === "dirty" || n.value === "dirty" ? Rs(a.value) : a } } if (s.type === "refinement") { const i = a => { const l = s.refinement(a, o); if (r.common.async) return Promise.resolve(l); if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead."); return a }; if (r.common.async === !1) { const a = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r }); return a.status === "aborted" ? ne : (a.status === "dirty" && n.dirty(), i(a.value), { status: n.value, value: a.value }) } else return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then(a => a.status === "aborted" ? ne : (a.status === "dirty" && n.dirty(), i(a.value).then(() => ({ status: n.value, value: a.value })))) } if (s.type === "transform") if (r.common.async === !1) { const i = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r }); if (!ns(i)) return i; const a = s.transform(i.value, o); if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."); return { status: n.value, value: a } } else return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then(i => ns(i) ? Promise.resolve(s.transform(i.value, o)).then(a => ({ status: n.value, value: a })) : i); fe.assertNever(s) } } un.create = (e, t, n) => new un({ schema: e, typeName: te.ZodEffects, effect: t, ...ie(n) }); un.createWithPreprocess = (e, t, n) => new un({ schema: t, effect: { type: "preprocess", transform: e }, typeName: te.ZodEffects, ...ie(n) }); class Sn extends le { _parse(t) { return this._getType(t) === W.undefined ? vt(void 0) : this._def.innerType._parse(t) } unwrap() { return this._def.innerType } } Sn.create = (e, t) => new Sn({ innerType: e, typeName: te.ZodOptional, ...ie(t) }); class Pr extends le { _parse(t) { return this._getType(t) === W.null ? vt(null) : this._def.innerType._parse(t) } unwrap() { return this._def.innerType } } Pr.create = (e, t) => new Pr({ innerType: e, typeName: te.ZodNullable, ...ie(t) }); class Ai extends le { _parse(t) { const { ctx: n } = this._processInputParams(t); let r = n.data; return n.parsedType === W.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({ data: r, path: n.path, parent: n }) } removeDefault() { return this._def.innerType } } Ai.create = (e, t) => new Ai({ innerType: e, typeName: te.ZodDefault, defaultValue: typeof t.default == "function" ? t.default : () => t.default, ...ie(t) }); class ji extends le { _parse(t) { const { ctx: n } = this._processInputParams(t), r = { ...n, common: { ...n.common, issues: [] } }, s = this._def.innerType._parse({ data: r.data, path: r.path, parent: { ...r } }); return Si(s) ? s.then(o => ({ status: "valid", value: o.status === "valid" ? o.value : this._def.catchValue({ get error() { return new Mt(r.common.issues) }, input: r.data }) })) : { status: "valid", value: s.status === "valid" ? s.value : this._def.catchValue({ get error() { return new Mt(r.common.issues) }, input: r.data }) } } removeCatch() { return this._def.innerType } } ji.create = (e, t) => new ji({ innerType: e, typeName: te.ZodCatch, catchValue: typeof t.catch == "function" ? t.catch : () => t.catch, ...ie(t) }); class bl extends le { _parse(t) { if (this._getType(t) !== W.nan) { const r = this._getOrReturnCtx(t); return B(r, { code: M.invalid_type, expected: W.nan, received: r.parsedType }), ne } return { status: "valid", value: t.data } } } bl.create = e => new bl({ typeName: te.ZodNaN, ...ie(e) }); const VE = Symbol("zod_brand"); class Vf extends le { _parse(t) { const { ctx: n } = this._processInputParams(t), r = n.data; return this._def.type._parse({ data: r, path: n.path, parent: n }) } unwrap() { return this._def.type } } class Zi extends le { _parse(t) { const { status: n, ctx: r } = this._processInputParams(t); if (r.common.async) return (async () => { const o = await this._def.in._parseAsync({ data: r.data, path: r.path, parent: r }); return o.status === "aborted" ? ne : o.status === "dirty" ? (n.dirty(), Rs(o.value)) : this._def.out._parseAsync({ data: o.value, path: r.path, parent: r }) })(); { const s = this._def.in._parseSync({ data: r.data, path: r.path, parent: r }); return s.status === "aborted" ? ne : s.status === "dirty" ? (n.dirty(), { status: "dirty", value: s.value }) : this._def.out._parseSync({ data: s.value, path: r.path, parent: r }) } } static create(t, n) { return new Zi({ in: t, out: n, typeName: te.ZodPipeline }) } } class Oi extends le { _parse(t) { const n = this._def.innerType._parse(t), r = s => (ns(s) && (s.value = Object.freeze(s.value)), s); return Si(n) ? n.then(s => r(s)) : r(n) } unwrap() { return this._def.innerType } } Oi.create = (e, t) => new Oi({ innerType: e, typeName: te.ZodReadonly, ...ie(t) }); function Wh(e, t) { const n = typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e; return typeof n == "string" ? { message: n } : n } function Lx(e, t = {}, n) { return e ? lo.create().superRefine((r, s) => { var o, i; const a = e(r); if (a instanceof Promise) return a.then(l => { var u, c; if (!l) { const p = Wh(t, r), h = (c = (u = p.fatal) !== null && u !== void 0 ? u : n) !== null && c !== void 0 ? c : !0; s.addIssue({ code: "custom", ...p, fatal: h }) } }); if (!a) { const l = Wh(t, r), u = (i = (o = l.fatal) !== null && o !== void 0 ? o : n) !== null && i !== void 0 ? i : !0; s.addIssue({ code: "custom", ...l, fatal: u }) } }) : lo.create() } const zE = { object: Pe.lazycreate }; var te; (function (e) { e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly" })(te || (te = {})); const $E = (e, t = { message: `Input not instance of ${e.name}` }) => Lx(n => n instanceof e, t), Dx = tn.create, Fx = Er.create, UE = bl.create, BE = Tr.create, Vx = _i.create, WE = rs.create, HE = _l.create, ZE = Ci.create, KE = ki.create, QE = lo.create, GE = Qr.create, qE = Wn.create, YE = Cl.create, XE = sn.create, JE = Pe.create, eT = Pe.strictCreate, tT = bi.create, nT = nu.create, rT = Ei.create, sT = kn.create, oT = Ti.create, iT = kl.create, aT = ss.create, lT = Vs.create, uT = Ni.create, cT = Pi.create, dT = Nr.create, fT = Ri.create, pT = uo.create, Hh = un.create, hT = Sn.create, mT = Pr.create, vT = un.createWithPreprocess, gT = Zi.create, yT = () => Dx().optional(), xT = () => Fx().optional(), wT = () => Vx().optional(), ST = { string: e => tn.create({ ...e, coerce: !0 }), number: e => Er.create({ ...e, coerce: !0 }), boolean: e => _i.create({ ...e, coerce: !0 }), bigint: e => Tr.create({ ...e, coerce: !0 }), date: e => rs.create({ ...e, coerce: !0 }) }, _T = ne; var Ro = Object.freeze({ __proto__: null, defaultErrorMap: ao, setErrorMap: vE, getErrorMap: xl, makeIssue: wl, EMPTY_PATH: gE, addIssueToContext: B, ParseStatus: ut, INVALID: ne, DIRTY: Rs, OK: vt, isAborted: ad, isDirty: ld, isValid: ns, isAsync: Si, get util() { return fe }, get objectUtil() { return id }, ZodParsedType: W, getParsedType: jn, ZodType: le, datetimeRegex: Mx, ZodString: tn, ZodNumber: Er, ZodBigInt: Tr, ZodBoolean: _i, ZodDate: rs, ZodSymbol: _l, ZodUndefined: Ci, ZodNull: ki, ZodAny: lo, ZodUnknown: Qr, ZodNever: Wn, ZodVoid: Cl, ZodArray: sn, ZodObject: Pe, ZodUnion: bi, ZodDiscriminatedUnion: nu, ZodIntersection: Ei, ZodTuple: kn, ZodRecord: Ti, ZodMap: kl, ZodSet: ss, ZodFunction: Vs, ZodLazy: Ni, ZodLiteral: Pi, ZodEnum: Nr, ZodNativeEnum: Ri, ZodPromise: uo, ZodEffects: un, ZodTransformer: un, ZodOptional: Sn, ZodNullable: Pr, ZodDefault: Ai, ZodCatch: ji, ZodNaN: bl, BRAND: VE, ZodBranded: Vf, ZodPipeline: Zi, ZodReadonly: Oi, custom: Lx, Schema: le, ZodSchema: le, late: zE, get ZodFirstPartyTypeKind() { return te }, coerce: ST, any: QE, array: XE, bigint: BE, boolean: Vx, date: WE, discriminatedUnion: nT, effect: Hh, enum: dT, function: lT, instanceof: $E, intersection: rT, lazy: uT, literal: cT, map: iT, nan: UE, nativeEnum: fT, never: qE, null: KE, nullable: mT, number: Fx, object: JE, oboolean: wT, onumber: xT, optional: hT, ostring: yT, pipeline: gT, preprocess: vT, promise: pT, record: oT, set: aT, strictObject: eT, string: Dx, symbol: HE, transformer: Hh, tuple: sT, undefined: ZE, union: tT, unknown: GE, void: YE, NEVER: _T, ZodIssueCode: M, quotelessJson: mE, ZodError: Mt }); const cd = v.forwardRef(({ className: e, type: t, ...n }, r) => d.jsx("input", { type: t, className: Se("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e), ref: r, ...n })); cd.displayName = "Input"; const zx = v.forwardRef(({ className: e, ...t }, n) => d.jsx("textarea", { className: Se("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e), ref: n, ...t })); zx.displayName = "Textarea"; function Zh(e, [t, n]) { return Math.min(n, Math.max(t, e)) } var CT = v.createContext(void 0); function kT(e) { const t = v.useContext(CT); return e || t || "ltr" } var Qu = 0; function bT() { v.useEffect(() => { const e = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", e[0] ?? Kh()), document.body.insertAdjacentElement("beforeend", e[1] ?? Kh()), Qu++, () => { Qu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()), Qu-- } }, []) } function Kh() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e } var Gu = "focusScope.autoFocusOnMount", qu = "focusScope.autoFocusOnUnmount", Qh = { bubbles: !1, cancelable: !0 }, ET = "FocusScope", $x = v.forwardRef((e, t) => { const { loop: n = !1, trapped: r = !1, onMountAutoFocus: s, onUnmountAutoFocus: o, ...i } = e, [a, l] = v.useState(null), u = Lt(s), c = Lt(o), p = v.useRef(null), h = Ie(t, m => l(m)), w = v.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; v.useEffect(() => { if (r) { let m = function (y) { if (w.paused || !a) return; const _ = y.target; a.contains(_) ? p.current = _ : Xn(p.current, { select: !0 }) }, x = function (y) { if (w.paused || !a) return; const _ = y.relatedTarget; _ !== null && (a.contains(_) || Xn(p.current, { select: !0 })) }, g = function (y) { if (document.activeElement === document.body) for (const k of y) k.removedNodes.length > 0 && Xn(a) }; document.addEventListener("focusin", m), document.addEventListener("focusout", x); const f = new MutationObserver(g); return a && f.observe(a, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", m), document.removeEventListener("focusout", x), f.disconnect() } } }, [r, a, w.paused]), v.useEffect(() => { if (a) { qh.add(w); const m = document.activeElement; if (!a.contains(m)) { const g = new CustomEvent(Gu, Qh); a.addEventListener(Gu, u), a.dispatchEvent(g), g.defaultPrevented || (TT(jT(Ux(a)), { select: !0 }), document.activeElement === m && Xn(a)) } return () => { a.removeEventListener(Gu, u), setTimeout(() => { const g = new CustomEvent(qu, Qh); a.addEventListener(qu, c), a.dispatchEvent(g), g.defaultPrevented || Xn(m ?? document.body, { select: !0 }), a.removeEventListener(qu, c), qh.remove(w) }, 0) } } }, [a, u, c, w]); const S = v.useCallback(m => { if (!n && !r || w.paused) return; const x = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, g = document.activeElement; if (x && g) { const f = m.currentTarget, [y, _] = NT(f); y && _ ? !m.shiftKey && g === _ ? (m.preventDefault(), n && Xn(y, { select: !0 })) : m.shiftKey && g === y && (m.preventDefault(), n && Xn(_, { select: !0 })) : g === f && m.preventDefault() } }, [n, r, w.paused]); return d.jsx(_e.div, { tabIndex: -1, ...i, ref: h, onKeyDown: S }) }); $x.displayName = ET; function TT(e, { select: t = !1 } = {}) { const n = document.activeElement; for (const r of e) if (Xn(r, { select: t }), document.activeElement !== n) return } function NT(e) { const t = Ux(e), n = Gh(t, e), r = Gh(t.reverse(), e); return [n, r] } function Ux(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const s = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function Gh(e, t) { for (const n of e) if (!PT(n, { upTo: t })) return n } function PT(e, { upTo: t }) { if (getComputedStyle(e).visibility === "hidden") return !0; for (; e;) { if (t !== void 0 && e === t) return !1; if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } return !1 } function RT(e) { return e instanceof HTMLInputElement && "select" in e } function Xn(e, { select: t = !1 } = {}) { if (e && e.focus) { const n = document.activeElement; e.focus({ preventScroll: !0 }), e !== n && RT(e) && t && e.select() } } var qh = AT(); function AT() { let e = []; return { add(t) { const n = e[0]; t !== n && (n == null || n.pause()), e = Yh(e, t), e.unshift(t) }, remove(t) { var n; e = Yh(e, t), (n = e[0]) == null || n.resume() } } } function Yh(e, t) { const n = [...e], r = n.indexOf(t); return r !== -1 && n.splice(r, 1), n } function jT(e) { return e.filter(t => t.tagName !== "A") } function OT(e) { const t = v.useRef({ value: e, previous: e }); return v.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]) } var MT = function (e) { if (typeof document > "u") return null; var t = Array.isArray(e) ? e[0] : e; return t.ownerDocument.body }, ps = new WeakMap, va = new WeakMap, ga = {}, Yu = 0, Bx = function (e) { return e && (e.host || Bx(e.parentNode)) }, IT = function (e, t) { return t.map(function (n) { if (e.contains(n)) return n; var r = Bx(n); return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null) }).filter(function (n) { return !!n }) }, LT = function (e, t, n, r) { var s = IT(t, Array.isArray(e) ? e : [e]); ga[n] || (ga[n] = new WeakMap); var o = ga[n], i = [], a = new Set, l = new Set(s), u = function (p) { !p || a.has(p) || (a.add(p), u(p.parentNode)) }; s.forEach(u); var c = function (p) { !p || l.has(p) || Array.prototype.forEach.call(p.children, function (h) { if (a.has(h)) c(h); else try { var w = h.getAttribute(r), S = w !== null && w !== "false", m = (ps.get(h) || 0) + 1, x = (o.get(h) || 0) + 1; ps.set(h, m), o.set(h, x), i.push(h), m === 1 && S && va.set(h, !0), x === 1 && h.setAttribute(n, "true"), S || h.setAttribute(r, "true") } catch (g) { console.error("aria-hidden: cannot operate on ", h, g) } }) }; return c(t), a.clear(), Yu++, function () { i.forEach(function (p) { var h = ps.get(p) - 1, w = o.get(p) - 1; ps.set(p, h), o.set(p, w), h || (va.has(p) || p.removeAttribute(r), va.delete(p)), w || p.removeAttribute(n) }), Yu--, Yu || (ps = new WeakMap, ps = new WeakMap, va = new WeakMap, ga = {}) } }, DT = function (e, t, n) { n === void 0 && (n = "data-aria-hidden"); var r = Array.from(Array.isArray(e) ? e : [e]), s = MT(e); return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), LT(r, s, n, "aria-hidden")) : function () { return null } }, vn = function () { return vn = Object.assign || function (t) { for (var n, r = 1, s = arguments.length; r < s; r++) { n = arguments[r]; for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]) } return t }, vn.apply(this, arguments) }; function Wx(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++)t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]); return n } function FT(e, t, n) { if (n || arguments.length === 2) for (var r = 0, s = t.length, o; r < s; r++)(o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]); return e.concat(o || Array.prototype.slice.call(t)) } var Fa = "right-scroll-bar-position", Va = "width-before-scroll-bar", VT = "with-scroll-bars-hidden", zT = "--removed-body-scroll-bar-size"; function Xu(e, t) { return typeof e == "function" ? e(t) : e && (e.current = t), e } function $T(e, t) { var n = v.useState(function () { return { value: e, callback: t, facade: { get current() { return n.value }, set current(r) { var s = n.value; s !== r && (n.value = r, n.callback(r, s)) } } } })[0]; return n.callback = t, n.facade } var UT = typeof window < "u" ? v.useLayoutEffect : v.useEffect, Xh = new WeakMap; function BT(e, t) { var n = $T(null, function (r) { return e.forEach(function (s) { return Xu(s, r) }) }); return UT(function () { var r = Xh.get(n); if (r) { var s = new Set(r), o = new Set(e), i = n.current; s.forEach(function (a) { o.has(a) || Xu(a, null) }), o.forEach(function (a) { s.has(a) || Xu(a, i) }) } Xh.set(n, e) }, [e]), n } function WT(e) { return e } function HT(e, t) { t === void 0 && (t = WT); var n = [], r = !1, s = { read: function () { if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return n.length ? n[n.length - 1] : e }, useMedium: function (o) { var i = t(o, r); return n.push(i), function () { n = n.filter(function (a) { return a !== i }) } }, assignSyncMedium: function (o) { for (r = !0; n.length;) { var i = n; n = [], i.forEach(o) } n = { push: function (a) { return o(a) }, filter: function () { return n } } }, assignMedium: function (o) { r = !0; var i = []; if (n.length) { var a = n; n = [], a.forEach(o), i = n } var l = function () { var c = i; i = [], c.forEach(o) }, u = function () { return Promise.resolve().then(l) }; u(), n = { push: function (c) { i.push(c), u() }, filter: function (c) { return i = i.filter(c), n } } } }; return s } function ZT(e) { e === void 0 && (e = {}); var t = HT(null); return t.options = vn({ async: !0, ssr: !1 }, e), t } var Hx = function (e) { var t = e.sideCar, n = Wx(e, ["sideCar"]); if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var r = t.read(); if (!r) throw new Error("Sidecar medium not found"); return v.createElement(r, vn({}, n)) }; Hx.isSideCarExport = !0; function KT(e, t) { return e.useMedium(t), Hx } var Zx = ZT(), Ju = function () { }, ru = v.forwardRef(function (e, t) { var n = v.useRef(null), r = v.useState({ onScrollCapture: Ju, onWheelCapture: Ju, onTouchMoveCapture: Ju }), s = r[0], o = r[1], i = e.forwardProps, a = e.children, l = e.className, u = e.removeScrollBar, c = e.enabled, p = e.shards, h = e.sideCar, w = e.noIsolation, S = e.inert, m = e.allowPinchZoom, x = e.as, g = x === void 0 ? "div" : x, f = e.gapMode, y = Wx(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), _ = h, k = BT([n, t]), T = vn(vn({}, y), s); return v.createElement(v.Fragment, null, c && v.createElement(_, { sideCar: Zx, removeScrollBar: u, shards: p, noIsolation: w, inert: S, setCallbacks: o, allowPinchZoom: !!m, lockRef: n, gapMode: f }), i ? v.cloneElement(v.Children.only(a), vn(vn({}, T), { ref: k })) : v.createElement(g, vn({}, T, { className: l, ref: k }), a)) }); ru.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; ru.classNames = { fullWidth: Va, zeroRight: Fa }; var QT = function () { if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function GT() { if (!document) return null; var e = document.createElement("style"); e.type = "text/css"; var t = QT(); return t && e.setAttribute("nonce", t), e } function qT(e, t) { e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t)) } function YT(e) { var t = document.head || document.getElementsByTagName("head")[0]; t.appendChild(e) } var XT = function () { var e = 0, t = null; return { add: function (n) { e == 0 && (t = GT()) && (qT(t, n), YT(t)), e++ }, remove: function () { e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null) } } }, JT = function () { var e = XT(); return function (t, n) { v.useEffect(function () { return e.add(t), function () { e.remove() } }, [t && n]) } }, Kx = function () { var e = JT(), t = function (n) { var r = n.styles, s = n.dynamic; return e(r, s), null }; return t }, eN = { left: 0, top: 0, right: 0, gap: 0 }, ec = function (e) { return parseInt(e || "", 10) || 0 }, tN = function (e) { var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], s = t[e === "padding" ? "paddingRight" : "marginRight"]; return [ec(n), ec(r), ec(s)] }, nN = function (e) { if (e === void 0 && (e = "margin"), typeof window > "u") return eN; var t = tN(e), n = document.documentElement.clientWidth, r = window.innerWidth; return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) } }, rN = Kx(), zs = "data-scroll-locked", sN = function (e, t, n, r) {
  var s = e.left, o = e.top, i = e.right, a = e.gap; return n === void 0 && (n = "margin"), `
  .`.concat(VT, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(zs, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Fa, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Va, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Fa, " .").concat(Fa, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Va, " .").concat(Va, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(zs, `] {
    `).concat(zT, ": ").concat(a, `px;
  }
`)
}, Jh = function () { var e = parseInt(document.body.getAttribute(zs) || "0", 10); return isFinite(e) ? e : 0 }, oN = function () { v.useEffect(function () { return document.body.setAttribute(zs, (Jh() + 1).toString()), function () { var e = Jh() - 1; e <= 0 ? document.body.removeAttribute(zs) : document.body.setAttribute(zs, e.toString()) } }, []) }, iN = function (e) { var t = e.noRelative, n = e.noImportant, r = e.gapMode, s = r === void 0 ? "margin" : r; oN(); var o = v.useMemo(function () { return nN(s) }, [s]); return v.createElement(rN, { styles: sN(o, !t, s, n ? "" : "!important") }) }, dd = !1; if (typeof window < "u") try { var ya = Object.defineProperty({}, "passive", { get: function () { return dd = !0, !0 } }); window.addEventListener("test", ya, ya), window.removeEventListener("test", ya, ya) } catch { dd = !1 } var hs = dd ? { passive: !1 } : !1, aN = function (e) { return e.tagName === "TEXTAREA" }, Qx = function (e, t) { if (!(e instanceof Element)) return !1; var n = window.getComputedStyle(e); return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !aN(e) && n[t] === "visible") }, lN = function (e) { return Qx(e, "overflowY") }, uN = function (e) { return Qx(e, "overflowX") }, em = function (e, t) { var n = t.ownerDocument, r = t; do { typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host); var s = Gx(e, r); if (s) { var o = qx(e, r), i = o[1], a = o[2]; if (i > a) return !0 } r = r.parentNode } while (r && r !== n.body); return !1 }, cN = function (e) { var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight; return [t, n, r] }, dN = function (e) { var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth; return [t, n, r] }, Gx = function (e, t) { return e === "v" ? lN(t) : uN(t) }, qx = function (e, t) { return e === "v" ? cN(t) : dN(t) }, fN = function (e, t) { return e === "h" && t === "rtl" ? -1 : 1 }, pN = function (e, t, n, r, s) { var o = fN(e, window.getComputedStyle(t).direction), i = o * r, a = n.target, l = t.contains(a), u = !1, c = i > 0, p = 0, h = 0; do { var w = qx(e, a), S = w[0], m = w[1], x = w[2], g = m - x - o * S; (S || g) && Gx(e, a) && (p += g, h += S), a instanceof ShadowRoot ? a = a.host : a = a.parentNode } while (!l && a !== document.body || l && (t.contains(a) || t === a)); return (c && (Math.abs(p) < 1 || !s) || !c && (Math.abs(h) < 1 || !s)) && (u = !0), u }, xa = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, tm = function (e) { return [e.deltaX, e.deltaY] }, nm = function (e) { return e && "current" in e ? e.current : e }, hN = function (e, t) { return e[0] === t[0] && e[1] === t[1] }, mN = function (e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
}, vN = 0, ms = []; function gN(e) { var t = v.useRef([]), n = v.useRef([0, 0]), r = v.useRef(), s = v.useState(vN++)[0], o = v.useState(Kx)[0], i = v.useRef(e); v.useEffect(function () { i.current = e }, [e]), v.useEffect(function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(s)); var m = FT([e.lockRef.current], (e.shards || []).map(nm), !0).filter(Boolean); return m.forEach(function (x) { return x.classList.add("allow-interactivity-".concat(s)) }), function () { document.body.classList.remove("block-interactivity-".concat(s)), m.forEach(function (x) { return x.classList.remove("allow-interactivity-".concat(s)) }) } } }, [e.inert, e.lockRef.current, e.shards]); var a = v.useCallback(function (m, x) { if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey) return !i.current.allowPinchZoom; var g = xa(m), f = n.current, y = "deltaX" in m ? m.deltaX : f[0] - g[0], _ = "deltaY" in m ? m.deltaY : f[1] - g[1], k, T = m.target, b = Math.abs(y) > Math.abs(_) ? "h" : "v"; if ("touches" in m && b === "h" && T.type === "range") return !1; var R = em(b, T); if (!R) return !0; if (R ? k = b : (k = b === "v" ? "h" : "v", R = em(b, T)), !R) return !1; if (!r.current && "changedTouches" in m && (y || _) && (r.current = k), !k) return !0; var F = r.current || k; return pN(F, x, m, F === "h" ? y : _, !0) }, []), l = v.useCallback(function (m) { var x = m; if (!(!ms.length || ms[ms.length - 1] !== o)) { var g = "deltaY" in x ? tm(x) : xa(x), f = t.current.filter(function (k) { return k.name === x.type && (k.target === x.target || x.target === k.shadowParent) && hN(k.delta, g) })[0]; if (f && f.should) { x.cancelable && x.preventDefault(); return } if (!f) { var y = (i.current.shards || []).map(nm).filter(Boolean).filter(function (k) { return k.contains(x.target) }), _ = y.length > 0 ? a(x, y[0]) : !i.current.noIsolation; _ && x.cancelable && x.preventDefault() } } }, []), u = v.useCallback(function (m, x, g, f) { var y = { name: m, delta: x, target: g, should: f, shadowParent: yN(g) }; t.current.push(y), setTimeout(function () { t.current = t.current.filter(function (_) { return _ !== y }) }, 1) }, []), c = v.useCallback(function (m) { n.current = xa(m), r.current = void 0 }, []), p = v.useCallback(function (m) { u(m.type, tm(m), m.target, a(m, e.lockRef.current)) }, []), h = v.useCallback(function (m) { u(m.type, xa(m), m.target, a(m, e.lockRef.current)) }, []); v.useEffect(function () { return ms.push(o), e.setCallbacks({ onScrollCapture: p, onWheelCapture: p, onTouchMoveCapture: h }), document.addEventListener("wheel", l, hs), document.addEventListener("touchmove", l, hs), document.addEventListener("touchstart", c, hs), function () { ms = ms.filter(function (m) { return m !== o }), document.removeEventListener("wheel", l, hs), document.removeEventListener("touchmove", l, hs), document.removeEventListener("touchstart", c, hs) } }, []); var w = e.removeScrollBar, S = e.inert; return v.createElement(v.Fragment, null, S ? v.createElement(o, { styles: mN(s) }) : null, w ? v.createElement(iN, { gapMode: e.gapMode }) : null) } function yN(e) { for (var t = null; e !== null;)e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode; return t } const xN = KT(Zx, gN); var Yx = v.forwardRef(function (e, t) { return v.createElement(ru, vn({}, e, { ref: t, sideCar: xN })) }); Yx.classNames = ru.classNames; var wN = [" ", "Enter", "ArrowUp", "ArrowDown"], SN = [" ", "Enter"], Ki = "Select", [su, ou, _N] = Xg(Ki), [go, wP] = Ui(Ki, [_N, Yl]), iu = Yl(), [CN, Or] = go(Ki), [kN, bN] = go(Ki), Xx = e => { const { __scopeSelect: t, children: n, open: r, defaultOpen: s, onOpenChange: o, value: i, defaultValue: a, onValueChange: l, dir: u, name: c, autoComplete: p, disabled: h, required: w, form: S } = e, m = iu(t), [x, g] = v.useState(null), [f, y] = v.useState(null), [_, k] = v.useState(!1), T = kT(u), [b = !1, R] = qc({ prop: r, defaultProp: s, onChange: o }), [F, V] = qc({ prop: i, defaultProp: a, onChange: l }), Y = v.useRef(null), O = x ? S || !!x.closest("form") : !0, [z, j] = v.useState(new Set), X = Array.from(z).map(K => K.props.value).join(";"); return d.jsx(vb, { ...m, children: d.jsxs(CN, { required: w, scope: t, trigger: x, onTriggerChange: g, valueNode: f, onValueNodeChange: y, valueNodeHasChildren: _, onValueNodeHasChildrenChange: k, contentId: kf(), value: F, onValueChange: V, open: b, onOpenChange: R, dir: T, triggerPointerDownPosRef: Y, disabled: h, children: [d.jsx(su.Provider, { scope: t, children: d.jsx(kN, { scope: e.__scopeSelect, onNativeOptionAdd: v.useCallback(K => { j(J => new Set(J).add(K)) }, []), onNativeOptionRemove: v.useCallback(K => { j(J => { const P = new Set(J); return P.delete(K), P }) }, []), children: n }) }), O ? d.jsxs(C0, { "aria-hidden": !0, required: w, tabIndex: -1, name: c, autoComplete: p, value: F, onChange: K => V(K.target.value), disabled: h, form: S, children: [F === void 0 ? d.jsx("option", { value: "" }) : null, Array.from(z)] }, X) : null] }) }) }; Xx.displayName = Ki; var Jx = "SelectTrigger", e0 = v.forwardRef((e, t) => { const { __scopeSelect: n, disabled: r = !1, ...s } = e, o = iu(n), i = Or(Jx, n), a = i.disabled || r, l = Ie(t, i.onTriggerChange), u = ou(n), c = v.useRef("touch"), [p, h, w] = k0(m => { const x = u().filter(y => !y.disabled), g = x.find(y => y.value === i.value), f = b0(x, m, g); f !== void 0 && i.onValueChange(f.value) }), S = m => { a || (i.onOpenChange(!0), w()), m && (i.triggerPointerDownPosRef.current = { x: Math.round(m.pageX), y: Math.round(m.pageY) }) }; return d.jsx(sx, { asChild: !0, ...o, children: d.jsx(_e.button, { type: "button", role: "combobox", "aria-controls": i.contentId, "aria-expanded": i.open, "aria-required": i.required, "aria-autocomplete": "none", dir: i.dir, "data-state": i.open ? "open" : "closed", disabled: a, "data-disabled": a ? "" : void 0, "data-placeholder": _0(i.value) ? "" : void 0, ...s, ref: l, onClick: ce(s.onClick, m => { m.currentTarget.focus(), c.current !== "mouse" && S(m) }), onPointerDown: ce(s.onPointerDown, m => { c.current = m.pointerType; const x = m.target; x.hasPointerCapture(m.pointerId) && x.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && m.pointerType === "mouse" && (S(m), m.preventDefault()) }), onKeyDown: ce(s.onKeyDown, m => { const x = p.current !== ""; !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && h(m.key), !(x && m.key === " ") && wN.includes(m.key) && (S(), m.preventDefault()) }) }) }) }); e0.displayName = Jx; var t0 = "SelectValue", n0 = v.forwardRef((e, t) => { const { __scopeSelect: n, className: r, style: s, children: o, placeholder: i = "", ...a } = e, l = Or(t0, n), { onValueNodeHasChildrenChange: u } = l, c = o !== void 0, p = Ie(t, l.onValueNodeChange); return lt(() => { u(c) }, [u, c]), d.jsx(_e.span, { ...a, ref: p, style: { pointerEvents: "none" }, children: _0(l.value) ? d.jsx(d.Fragment, { children: i }) : o }) }); n0.displayName = t0; var EN = "SelectIcon", r0 = v.forwardRef((e, t) => { const { __scopeSelect: n, children: r, ...s } = e; return d.jsx(_e.span, { "aria-hidden": !0, ...s, ref: t, children: r || "" }) }); r0.displayName = EN; var TN = "SelectPortal", s0 = e => d.jsx(gf, { asChild: !0, ...e }); s0.displayName = TN; var os = "SelectContent", o0 = v.forwardRef((e, t) => { const n = Or(os, e.__scopeSelect), [r, s] = v.useState(); if (lt(() => { s(new DocumentFragment) }, []), !n.open) { const o = r; return o ? ls.createPortal(d.jsx(i0, { scope: e.__scopeSelect, children: d.jsx(su.Slot, { scope: e.__scopeSelect, children: d.jsx("div", { children: e.children }) }) }), o) : null } return d.jsx(a0, { ...e, ref: t }) }); o0.displayName = os; var Kt = 10, [i0, Mr] = go(os), NN = "SelectContentImpl", PN = yi("SelectContent.RemoveScroll"), a0 = v.forwardRef((e, t) => { const { __scopeSelect: n, position: r = "item-aligned", onCloseAutoFocus: s, onEscapeKeyDown: o, onPointerDownOutside: i, side: a, sideOffset: l, align: u, alignOffset: c, arrowPadding: p, collisionBoundary: h, collisionPadding: w, sticky: S, hideWhenDetached: m, avoidCollisions: x, ...g } = e, f = Or(os, n), [y, _] = v.useState(null), [k, T] = v.useState(null), b = Ie(t, ee => _(ee)), [R, F] = v.useState(null), [V, Y] = v.useState(null), O = ou(n), [z, j] = v.useState(!1), X = v.useRef(!1); v.useEffect(() => { if (y) return DT(y) }, [y]), bT(); const K = v.useCallback(ee => { const [Ce, ...$e] = O().map(ge => ge.ref.current), [xe] = $e.slice(-1), he = document.activeElement; for (const ge of ee) if (ge === he || (ge == null || ge.scrollIntoView({ block: "nearest" }), ge === Ce && k && (k.scrollTop = 0), ge === xe && k && (k.scrollTop = k.scrollHeight), ge == null || ge.focus(), document.activeElement !== he)) return }, [O, k]), J = v.useCallback(() => K([R, y]), [K, R, y]); v.useEffect(() => { z && J() }, [z, J]); const { onOpenChange: P, triggerPointerDownPosRef: D } = f; v.useEffect(() => { if (y) { let ee = { x: 0, y: 0 }; const Ce = xe => { var he, ge; ee = { x: Math.abs(Math.round(xe.pageX) - (((he = D.current) == null ? void 0 : he.x) ?? 0)), y: Math.abs(Math.round(xe.pageY) - (((ge = D.current) == null ? void 0 : ge.y) ?? 0)) } }, $e = xe => { ee.x <= 10 && ee.y <= 10 ? xe.preventDefault() : y.contains(xe.target) || P(!1), document.removeEventListener("pointermove", Ce), D.current = null }; return D.current !== null && (document.addEventListener("pointermove", Ce), document.addEventListener("pointerup", $e, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", Ce), document.removeEventListener("pointerup", $e, { capture: !0 }) } } }, [y, P, D]), v.useEffect(() => { const ee = () => P(!1); return window.addEventListener("blur", ee), window.addEventListener("resize", ee), () => { window.removeEventListener("blur", ee), window.removeEventListener("resize", ee) } }, [P]); const [Q, re] = k0(ee => { const Ce = O().filter(he => !he.disabled), $e = Ce.find(he => he.ref.current === document.activeElement), xe = b0(Ce, ee, $e); xe && setTimeout(() => xe.ref.current.focus()) }), ve = v.useCallback((ee, Ce, $e) => { const xe = !X.current && !$e; (f.value !== void 0 && f.value === Ce || xe) && (F(ee), xe && (X.current = !0)) }, [f.value]), Ke = v.useCallback(() => y == null ? void 0 : y.focus(), [y]), Le = v.useCallback((ee, Ce, $e) => { const xe = !X.current && !$e; (f.value !== void 0 && f.value === Ce || xe) && Y(ee) }, [f.value]), bt = r === "popper" ? fd : l0, qe = bt === fd ? { side: a, sideOffset: l, align: u, alignOffset: c, arrowPadding: p, collisionBoundary: h, collisionPadding: w, sticky: S, hideWhenDetached: m, avoidCollisions: x } : {}; return d.jsx(i0, { scope: n, content: y, viewport: k, onViewportChange: T, itemRefCallback: ve, selectedItem: R, onItemLeave: Ke, itemTextRefCallback: Le, focusSelectedItem: J, selectedItemText: V, position: r, isPositioned: z, searchRef: Q, children: d.jsx(Yx, { as: PN, allowPinchZoom: !0, children: d.jsx($x, { asChild: !0, trapped: f.open, onMountAutoFocus: ee => { ee.preventDefault() }, onUnmountAutoFocus: ce(s, ee => { var Ce; (Ce = f.trigger) == null || Ce.focus({ preventScroll: !0 }), ee.preventDefault() }), children: d.jsx(Hl, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: o, onPointerDownOutside: i, onFocusOutside: ee => ee.preventDefault(), onDismiss: () => f.onOpenChange(!1), children: d.jsx(bt, { role: "listbox", id: f.contentId, "data-state": f.open ? "open" : "closed", dir: f.dir, onContextMenu: ee => ee.preventDefault(), ...g, ...qe, onPlaced: () => j(!0), ref: b, style: { display: "flex", flexDirection: "column", outline: "none", ...g.style }, onKeyDown: ce(g.onKeyDown, ee => { const Ce = ee.ctrlKey || ee.altKey || ee.metaKey; if (ee.key === "Tab" && ee.preventDefault(), !Ce && ee.key.length === 1 && re(ee.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(ee.key)) { let xe = O().filter(he => !he.disabled).map(he => he.ref.current); if (["ArrowUp", "End"].includes(ee.key) && (xe = xe.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(ee.key)) { const he = ee.target, ge = xe.indexOf(he); xe = xe.slice(ge + 1) } setTimeout(() => K(xe)), ee.preventDefault() } }) }) }) }) }) }) }); a0.displayName = NN; var RN = "SelectItemAlignedPosition", l0 = v.forwardRef((e, t) => { const { __scopeSelect: n, onPlaced: r, ...s } = e, o = Or(os, n), i = Mr(os, n), [a, l] = v.useState(null), [u, c] = v.useState(null), p = Ie(t, b => c(b)), h = ou(n), w = v.useRef(!1), S = v.useRef(!0), { viewport: m, selectedItem: x, selectedItemText: g, focusSelectedItem: f } = i, y = v.useCallback(() => { if (o.trigger && o.valueNode && a && u && m && x && g) { const b = o.trigger.getBoundingClientRect(), R = u.getBoundingClientRect(), F = o.valueNode.getBoundingClientRect(), V = g.getBoundingClientRect(); if (o.dir !== "rtl") { const he = V.left - R.left, ge = F.left - he, ct = b.left - ge, Et = b.width + ct, Ir = Math.max(Et, R.width), Zn = window.innerWidth - Kt, Kn = Zh(ge, [Kt, Math.max(Kt, Zn - Ir)]); a.style.minWidth = Et + "px", a.style.left = Kn + "px" } else { const he = R.right - V.right, ge = window.innerWidth - F.right - he, ct = window.innerWidth - b.right - ge, Et = b.width + ct, Ir = Math.max(Et, R.width), Zn = window.innerWidth - Kt, Kn = Zh(ge, [Kt, Math.max(Kt, Zn - Ir)]); a.style.minWidth = Et + "px", a.style.right = Kn + "px" } const Y = h(), O = window.innerHeight - Kt * 2, z = m.scrollHeight, j = window.getComputedStyle(u), X = parseInt(j.borderTopWidth, 10), K = parseInt(j.paddingTop, 10), J = parseInt(j.borderBottomWidth, 10), P = parseInt(j.paddingBottom, 10), D = X + K + z + P + J, Q = Math.min(x.offsetHeight * 5, D), re = window.getComputedStyle(m), ve = parseInt(re.paddingTop, 10), Ke = parseInt(re.paddingBottom, 10), Le = b.top + b.height / 2 - Kt, bt = O - Le, qe = x.offsetHeight / 2, ee = x.offsetTop + qe, Ce = X + K + ee, $e = D - Ce; if (Ce <= Le) { const he = Y.length > 0 && x === Y[Y.length - 1].ref.current; a.style.bottom = "0px"; const ge = u.clientHeight - m.offsetTop - m.offsetHeight, ct = Math.max(bt, qe + (he ? Ke : 0) + ge + J), Et = Ce + ct; a.style.height = Et + "px" } else { const he = Y.length > 0 && x === Y[0].ref.current; a.style.top = "0px"; const ct = Math.max(Le, X + m.offsetTop + (he ? ve : 0) + qe) + $e; a.style.height = ct + "px", m.scrollTop = Ce - Le + m.offsetTop } a.style.margin = `${Kt}px 0`, a.style.minHeight = Q + "px", a.style.maxHeight = O + "px", r == null || r(), requestAnimationFrame(() => w.current = !0) } }, [h, o.trigger, o.valueNode, a, u, m, x, g, o.dir, r]); lt(() => y(), [y]); const [_, k] = v.useState(); lt(() => { u && k(window.getComputedStyle(u).zIndex) }, [u]); const T = v.useCallback(b => { b && S.current === !0 && (y(), f == null || f(), S.current = !1) }, [y, f]); return d.jsx(jN, { scope: n, contentWrapper: a, shouldExpandOnScrollRef: w, onScrollButtonChange: T, children: d.jsx("div", { ref: l, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: _ }, children: d.jsx(_e.div, { ...s, ref: p, style: { boxSizing: "border-box", maxHeight: "100%", ...s.style } }) }) }) }); l0.displayName = RN; var AN = "SelectPopperPosition", fd = v.forwardRef((e, t) => { const { __scopeSelect: n, align: r = "start", collisionPadding: s = Kt, ...o } = e, i = iu(n); return d.jsx(ox, { ...i, ...o, ref: t, align: r, collisionPadding: s, style: { boxSizing: "border-box", ...o.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); fd.displayName = AN; var [jN, zf] = go(os, {}), pd = "SelectViewport", u0 = v.forwardRef((e, t) => { const { __scopeSelect: n, nonce: r, ...s } = e, o = Mr(pd, n), i = zf(pd, n), a = Ie(t, o.onViewportChange), l = v.useRef(0); return d.jsxs(d.Fragment, { children: [d.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: r }), d.jsx(su.Slot, { scope: n, children: d.jsx(_e.div, { "data-radix-select-viewport": "", role: "presentation", ...s, ref: a, style: { position: "relative", flex: 1, overflow: "hidden auto", ...s.style }, onScroll: ce(s.onScroll, u => { const c = u.currentTarget, { contentWrapper: p, shouldExpandOnScrollRef: h } = i; if (h != null && h.current && p) { const w = Math.abs(l.current - c.scrollTop); if (w > 0) { const S = window.innerHeight - Kt * 2, m = parseFloat(p.style.minHeight), x = parseFloat(p.style.height), g = Math.max(m, x); if (g < S) { const f = g + w, y = Math.min(S, f), _ = f - y; p.style.height = y + "px", p.style.bottom === "0px" && (c.scrollTop = _ > 0 ? _ : 0, p.style.justifyContent = "flex-end") } } } l.current = c.scrollTop }) }) })] }) }); u0.displayName = pd; var c0 = "SelectGroup", [ON, MN] = go(c0), IN = v.forwardRef((e, t) => { const { __scopeSelect: n, ...r } = e, s = kf(); return d.jsx(ON, { scope: n, id: s, children: d.jsx(_e.div, { role: "group", "aria-labelledby": s, ...r, ref: t }) }) }); IN.displayName = c0; var d0 = "SelectLabel", f0 = v.forwardRef((e, t) => { const { __scopeSelect: n, ...r } = e, s = MN(d0, n); return d.jsx(_e.div, { id: s.id, ...r, ref: t }) }); f0.displayName = d0; var El = "SelectItem", [LN, p0] = go(El), h0 = v.forwardRef((e, t) => { const { __scopeSelect: n, value: r, disabled: s = !1, textValue: o, ...i } = e, a = Or(El, n), l = Mr(El, n), u = a.value === r, [c, p] = v.useState(o ?? ""), [h, w] = v.useState(!1), S = Ie(t, f => { var y; return (y = l.itemRefCallback) == null ? void 0 : y.call(l, f, r, s) }), m = kf(), x = v.useRef("touch"), g = () => { s || (a.onValueChange(r), a.onOpenChange(!1)) }; if (r === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return d.jsx(LN, { scope: n, value: r, disabled: s, textId: m, isSelected: u, onItemTextChange: v.useCallback(f => { p(y => y || ((f == null ? void 0 : f.textContent) ?? "").trim()) }, []), children: d.jsx(su.ItemSlot, { scope: n, value: r, disabled: s, textValue: c, children: d.jsx(_e.div, { role: "option", "aria-labelledby": m, "data-highlighted": h ? "" : void 0, "aria-selected": u && h, "data-state": u ? "checked" : "unchecked", "aria-disabled": s || void 0, "data-disabled": s ? "" : void 0, tabIndex: s ? void 0 : -1, ...i, ref: S, onFocus: ce(i.onFocus, () => w(!0)), onBlur: ce(i.onBlur, () => w(!1)), onClick: ce(i.onClick, () => { x.current !== "mouse" && g() }), onPointerUp: ce(i.onPointerUp, () => { x.current === "mouse" && g() }), onPointerDown: ce(i.onPointerDown, f => { x.current = f.pointerType }), onPointerMove: ce(i.onPointerMove, f => { var y; x.current = f.pointerType, s ? (y = l.onItemLeave) == null || y.call(l) : x.current === "mouse" && f.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: ce(i.onPointerLeave, f => { var y; f.currentTarget === document.activeElement && ((y = l.onItemLeave) == null || y.call(l)) }), onKeyDown: ce(i.onKeyDown, f => { var _; ((_ = l.searchRef) == null ? void 0 : _.current) !== "" && f.key === " " || (SN.includes(f.key) && g(), f.key === " " && f.preventDefault()) }) }) }) }) }); h0.displayName = El; var Do = "SelectItemText", m0 = v.forwardRef((e, t) => { const { __scopeSelect: n, className: r, style: s, ...o } = e, i = Or(Do, n), a = Mr(Do, n), l = p0(Do, n), u = bN(Do, n), [c, p] = v.useState(null), h = Ie(t, g => p(g), l.onItemTextChange, g => { var f; return (f = a.itemTextRefCallback) == null ? void 0 : f.call(a, g, l.value, l.disabled) }), w = c == null ? void 0 : c.textContent, S = v.useMemo(() => d.jsx("option", { value: l.value, disabled: l.disabled, children: w }, l.value), [l.disabled, l.value, w]), { onNativeOptionAdd: m, onNativeOptionRemove: x } = u; return lt(() => (m(S), () => x(S)), [m, x, S]), d.jsxs(d.Fragment, { children: [d.jsx(_e.span, { id: l.textId, ...o, ref: h }), l.isSelected && i.valueNode && !i.valueNodeHasChildren ? ls.createPortal(o.children, i.valueNode) : null] }) }); m0.displayName = Do; var v0 = "SelectItemIndicator", g0 = v.forwardRef((e, t) => { const { __scopeSelect: n, ...r } = e; return p0(v0, n).isSelected ? d.jsx(_e.span, { "aria-hidden": !0, ...r, ref: t }) : null }); g0.displayName = v0; var hd = "SelectScrollUpButton", y0 = v.forwardRef((e, t) => { const n = Mr(hd, e.__scopeSelect), r = zf(hd, e.__scopeSelect), [s, o] = v.useState(!1), i = Ie(t, r.onScrollButtonChange); return lt(() => { if (n.viewport && n.isPositioned) { let a = function () { const u = l.scrollTop > 0; o(u) }; const l = n.viewport; return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a) } }, [n.viewport, n.isPositioned]), s ? d.jsx(w0, { ...e, ref: i, onAutoScroll: () => { const { viewport: a, selectedItem: l } = n; a && l && (a.scrollTop = a.scrollTop - l.offsetHeight) } }) : null }); y0.displayName = hd; var md = "SelectScrollDownButton", x0 = v.forwardRef((e, t) => { const n = Mr(md, e.__scopeSelect), r = zf(md, e.__scopeSelect), [s, o] = v.useState(!1), i = Ie(t, r.onScrollButtonChange); return lt(() => { if (n.viewport && n.isPositioned) { let a = function () { const u = l.scrollHeight - l.clientHeight, c = Math.ceil(l.scrollTop) < u; o(c) }; const l = n.viewport; return a(), l.addEventListener("scroll", a), () => l.removeEventListener("scroll", a) } }, [n.viewport, n.isPositioned]), s ? d.jsx(w0, { ...e, ref: i, onAutoScroll: () => { const { viewport: a, selectedItem: l } = n; a && l && (a.scrollTop = a.scrollTop + l.offsetHeight) } }) : null }); x0.displayName = md; var w0 = v.forwardRef((e, t) => { const { __scopeSelect: n, onAutoScroll: r, ...s } = e, o = Mr("SelectScrollButton", n), i = v.useRef(null), a = ou(n), l = v.useCallback(() => { i.current !== null && (window.clearInterval(i.current), i.current = null) }, []); return v.useEffect(() => () => l(), [l]), lt(() => { var c; const u = a().find(p => p.ref.current === document.activeElement); (c = u == null ? void 0 : u.ref.current) == null || c.scrollIntoView({ block: "nearest" }) }, [a]), d.jsx(_e.div, { "aria-hidden": !0, ...s, ref: t, style: { flexShrink: 0, ...s.style }, onPointerDown: ce(s.onPointerDown, () => { i.current === null && (i.current = window.setInterval(r, 50)) }), onPointerMove: ce(s.onPointerMove, () => { var u; (u = o.onItemLeave) == null || u.call(o), i.current === null && (i.current = window.setInterval(r, 50)) }), onPointerLeave: ce(s.onPointerLeave, () => { l() }) }) }), DN = "SelectSeparator", S0 = v.forwardRef((e, t) => { const { __scopeSelect: n, ...r } = e; return d.jsx(_e.div, { "aria-hidden": !0, ...r, ref: t }) }); S0.displayName = DN; var vd = "SelectArrow", FN = v.forwardRef((e, t) => { const { __scopeSelect: n, ...r } = e, s = iu(n), o = Or(vd, n), i = Mr(vd, n); return o.open && i.position === "popper" ? d.jsx(ix, { ...s, ...r, ref: t }) : null }); FN.displayName = vd; function _0(e) { return e === "" || e === void 0 } var C0 = v.forwardRef((e, t) => { const { value: n, ...r } = e, s = v.useRef(null), o = Ie(t, s), i = OT(n); return v.useEffect(() => { const a = s.current, l = window.HTMLSelectElement.prototype, c = Object.getOwnPropertyDescriptor(l, "value").set; if (i !== n && c) { const p = new Event("change", { bubbles: !0 }); c.call(a, n), a.dispatchEvent(p) } }, [i, n]), d.jsx(Bi, { asChild: !0, children: d.jsx("select", { ...r, ref: o, defaultValue: n }) }) }); C0.displayName = "BubbleSelect"; function k0(e) { const t = Lt(e), n = v.useRef(""), r = v.useRef(0), s = v.useCallback(i => { const a = n.current + i; t(a), function l(u) { n.current = u, window.clearTimeout(r.current), u !== "" && (r.current = window.setTimeout(() => l(""), 1e3)) }(a) }, [t]), o = v.useCallback(() => { n.current = "", window.clearTimeout(r.current) }, []); return v.useEffect(() => () => window.clearTimeout(r.current), []), [n, s, o] } function b0(e, t, n) { const s = t.length > 1 && Array.from(t).every(u => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1; let i = VN(e, Math.max(o, 0)); s.length === 1 && (i = i.filter(u => u !== n)); const l = i.find(u => u.textValue.toLowerCase().startsWith(s.toLowerCase())); return l !== n ? l : void 0 } function VN(e, t) { return e.map((n, r) => e[(t + r) % e.length]) } var zN = Xx, E0 = e0, $N = n0, UN = r0, BN = s0, T0 = o0, WN = u0, N0 = f0, P0 = h0, HN = m0, ZN = g0, R0 = y0, A0 = x0, j0 = S0; const KN = zN, QN = $N, O0 = v.forwardRef(({ className: e, children: t, ...n }, r) => d.jsxs(E0, { ref: r, className: Se("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", e), ...n, children: [t, d.jsx(UN, { asChild: !0, children: d.jsx(Ey, { className: "h-4 w-4 opacity-50" }) })] })); O0.displayName = E0.displayName; const M0 = v.forwardRef(({ className: e, ...t }, n) => d.jsx(R0, { ref: n, className: Se("flex cursor-default items-center justify-center py-1", e), ...t, children: d.jsx(_C, { className: "h-4 w-4" }) })); M0.displayName = R0.displayName; const I0 = v.forwardRef(({ className: e, ...t }, n) => d.jsx(A0, { ref: n, className: Se("flex cursor-default items-center justify-center py-1", e), ...t, children: d.jsx(Ey, { className: "h-4 w-4" }) })); I0.displayName = A0.displayName; const L0 = v.forwardRef(({ className: e, children: t, position: n = "popper", ...r }, s) => d.jsx(BN, { children: d.jsxs(T0, { ref: s, className: Se("relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]", n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", e), position: n, ...r, children: [d.jsx(M0, {}), d.jsx(WN, { className: Se("p-1", n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"), children: t }), d.jsx(I0, {})] }) })); L0.displayName = T0.displayName; const GN = v.forwardRef(({ className: e, ...t }, n) => d.jsx(N0, { ref: n, className: Se("py-1.5 pl-8 pr-2 text-sm font-semibold", e), ...t })); GN.displayName = N0.displayName; const gs = v.forwardRef(({ className: e, children: t, ...n }, r) => d.jsxs(P0, { ref: r, className: Se("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", e), ...n, children: [d.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: d.jsx(ZN, { children: d.jsx(by, { className: "h-4 w-4" }) }) }), d.jsx(HN, { children: t })] })); gs.displayName = P0.displayName; const qN = v.forwardRef(({ className: e, ...t }, n) => d.jsx(j0, { ref: n, className: Se("-mx-1 my-1 h-px bg-muted", e), ...t })); qN.displayName = j0.displayName; var YN = "Label", D0 = v.forwardRef((e, t) => d.jsx(_e.label, { ...e, ref: t, onMouseDown: n => { var s; n.target.closest("button, input, select, textarea") || ((s = e.onMouseDown) == null || s.call(e, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault()) } })); D0.displayName = YN; var F0 = D0; const XN = _f("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), V0 = v.forwardRef(({ className: e, ...t }, n) => d.jsx(F0, { ref: n, className: Se(XN(), e), ...t })); V0.displayName = F0.displayName; const JN = Zb, z0 = v.createContext({}), wa = ({ ...e }) => d.jsx(z0.Provider, { value: { name: e.name }, children: d.jsx(qb, { ...e }) }), au = () => { const e = v.useContext(z0), t = v.useContext($0), { getFieldState: n, formState: r } = tu(), s = n(e.name, r); if (!e) throw new Error("useFormField should be used within <FormField>"); const { id: o } = t; return { id: o, name: e.name, formItemId: `${o}-form-item`, formDescriptionId: `${o}-form-item-description`, formMessageId: `${o}-form-item-message`, ...s } }, $0 = v.createContext({}), Fo = v.forwardRef(({ className: e, ...t }, n) => { const r = v.useId(); return d.jsx($0.Provider, { value: { id: r }, children: d.jsx("div", { ref: n, className: Se("space-y-2", e), ...t }) }) }); Fo.displayName = "FormItem"; const Vo = v.forwardRef(({ className: e, ...t }, n) => { const { error: r, formItemId: s } = au(); return d.jsx(V0, { ref: n, className: Se(r && "text-destructive", e), htmlFor: s, ...t }) }); Vo.displayName = "FormLabel"; const zo = v.forwardRef(({ ...e }, t) => { const { error: n, formItemId: r, formDescriptionId: s, formMessageId: o } = au(); return d.jsx(qg, { ref: t, id: r, "aria-describedby": n ? `${s} ${o}` : `${s}`, "aria-invalid": !!n, ...e }) }); zo.displayName = "FormControl"; const eP = v.forwardRef(({ className: e, ...t }, n) => { const { formDescriptionId: r } = au(); return d.jsx("p", { ref: n, id: r, className: Se("text-sm text-muted-foreground", e), ...t }) }); eP.displayName = "FormDescription"; const $o = v.forwardRef(({ className: e, children: t, ...n }, r) => { const { error: s, formMessageId: o } = au(), i = s ? String((s == null ? void 0 : s.message) ?? "") : t; return i ? d.jsx("p", { ref: r, id: o, className: Se("text-sm font-medium text-destructive", e), ...n, children: i }) : null }); $o.displayName = "FormMessage"; const tP = Ro.object({ name: Ro.string().min(2, "Name must be at least 2 characters"), email: Ro.string().email("Please enter a valid email address"), fitnessGoal: Ro.string().min(1, "Please select a fitness goal"), message: Ro.string().min(10, "Message must be at least 10 characters") }); function nP() { const { toast: e } = Qg(), [t, n] = v.useState(!1), r = cE({ resolver: hE(tP), defaultValues: { name: "", email: "", fitnessGoal: "", message: "" } }), s = C_({ mutationFn: async i => (await k_("POST", "/api/contact", i)).json(), onSuccess: () => { e({ title: "Message sent successfully!", description: "Thank you for your message. We will get back to you soon." }), r.reset() }, onError: i => { e({ title: "Error sending message", description: i.message || "Please try again later.", variant: "destructive" }) }, onSettled: () => { n(!1) } }), o = async i => { n(!0), s.mutate(i) }; return d.jsx("section", { id: "contact", className: "section-padding bg-white", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "text-center mb-12", children: [d.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-primary mb-4", children: "Get In Touch" }), d.jsx("p", { className: "text-secondary text-lg", children: "Ready to start your fitness journey? Let's connect!" })] }), d.jsxs("div", { className: "grid md:grid-cols-2 gap-12", children: [d.jsxs("div", { children: [d.jsx("h3", { className: "text-2xl font-semibold text-primary mb-6", children: "Contact Information" }), d.jsxs("div", { className: "space-y-4", children: [d.jsxs("div", { className: "flex items-center space-x-4", children: [d.jsx("div", { className: "bg-whatsapp text-white p-3 rounded-full", children: d.jsx("i", { className: "fab fa-whatsapp" }) }), d.jsxs("div", { children: [d.jsx("p", { className: "font-semibold text-primary", children: "WhatsApp" }), d.jsx("p", { className: "text-secondary", children: "+91 8795705808" })] })] }), d.jsxs("div", { className: "flex items-center space-x-4", children: [d.jsx("div", { className: "bg-accent text-white p-3 rounded-full", children: d.jsx("i", { className: "fas fa-envelope" }) }), d.jsxs("div", { children: [d.jsx("p", { className: "font-semibold text-primary", children: "Email" }), d.jsx("p", { className: "text-secondary", children: "aupadhyay045@gmail.com" })] })] }), d.jsxs("div", { className: "flex items-center space-x-4", children: [d.jsx("div", { className: "bg-primary text-white p-3 rounded-full", children: d.jsx("i", { className: "fas fa-clock" }) }), d.jsxs("div", { children: [d.jsx("p", { className: "font-semibold text-primary", children: "Consultation Hours" }), d.jsx("p", { className: "text-secondary", children: "Mon-Sat: 6:00 AM - 10:00 PM" })] })] })] }), d.jsxs("div", { className: "mt-8", children: [d.jsx("h4", { className: "text-lg font-semibold text-primary mb-4", children: "Follow on Social Media" }), d.jsxs("div", { className: "flex space-x-4", children: [d.jsx("a", { href: "#", className: "bg-primary text-white p-3 rounded-full hover:bg-primary/80 transition-colors", children: d.jsx("i", { className: "fab fa-instagram" }) }), d.jsx("a", { href: "#", className: "bg-primary text-white p-3 rounded-full hover:bg-primary/80 transition-colors", children: d.jsx("i", { className: "fab fa-facebook" }) }), d.jsx("a", { href: "#", className: "bg-primary text-white p-3 rounded-full hover:bg-primary/80 transition-colors", children: d.jsx("i", { className: "fab fa-youtube" }) })] })] })] }), d.jsxs("div", { children: [d.jsx("h3", { className: "text-2xl font-semibold text-primary mb-6", children: "Send a Message" }), d.jsx(JN, { ...r, children: d.jsxs("form", { onSubmit: r.handleSubmit(o), className: "space-y-6", children: [d.jsx(wa, { control: r.control, name: "name", render: ({ field: i }) => d.jsxs(Fo, { children: [d.jsx(Vo, { children: "Name" }), d.jsx(zo, { children: d.jsx(cd, { placeholder: "Your full name", ...i }) }), d.jsx($o, {})] }) }), d.jsx(wa, { control: r.control, name: "email", render: ({ field: i }) => d.jsxs(Fo, { children: [d.jsx(Vo, { children: "Email" }), d.jsx(zo, { children: d.jsx(cd, { type: "email", placeholder: "your.email@example.com", ...i }) }), d.jsx($o, {})] }) }), d.jsx(wa, { control: r.control, name: "fitnessGoal", render: ({ field: i }) => d.jsxs(Fo, { children: [d.jsx(Vo, { children: "Fitness Goal" }), d.jsxs(KN, { onValueChange: i.onChange, defaultValue: i.value, children: [d.jsx(zo, { children: d.jsx(O0, { children: d.jsx(QN, { placeholder: "Select your fitness goal" }) }) }), d.jsxs(L0, { children: [d.jsx(gs, { value: "weight-loss", children: "Weight Loss" }), d.jsx(gs, { value: "muscle-gain", children: "Muscle Gain" }), d.jsx(gs, { value: "body-transformation", children: "Body Transformation" }), d.jsx(gs, { value: "general-fitness", children: "General Fitness" }), d.jsx(gs, { value: "strength-training", children: "Strength Training" })] })] }), d.jsx($o, {})] }) }), d.jsx(wa, { control: r.control, name: "message", render: ({ field: i }) => d.jsxs(Fo, { children: [d.jsx(Vo, { children: "Message" }), d.jsx(zo, { children: d.jsx(zx, { placeholder: "Tell us about your fitness goals and how we can help you...", rows: 4, ...i }) }), d.jsx($o, {})] }) }), d.jsx(io, { type: "submit", className: "w-full bg-accent text-white hover:bg-accent/90 transition-colors", disabled: t, children: t ? "Sending..." : "Send Message" })] }) })] })] })] }) }) } function rP() { const e = t => { const n = document.getElementById(t); n && n.scrollIntoView({ behavior: "smooth" }) }; return d.jsx("footer", { className: "bg-primary text-white py-12", children: d.jsxs("div", { className: "container-padding", children: [d.jsxs("div", { className: "grid md:grid-cols-4 gap-8", children: [d.jsxs("div", { children: [d.jsx("h3", { className: "text-2xl font-bold mb-4", children: "Ashwani Upadhyay" }), d.jsx("p", { className: "text-gray-300 mb-4", children: "Certified fitness trainer dedicated to helping you build your best self through science-based training." }), d.jsxs("a", { href: "https://wa.me/918400408888", target: "_blank", rel: "noopener noreferrer", className: "inline-flex items-center space-x-2 text-whatsapp hover:text-green-400 transition-colors", children: [d.jsx("i", { className: "fab fa-whatsapp" }), d.jsx("span", { children: "WhatsApp: +91 8795705808" })] })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Quick Links" }), d.jsxs("ul", { className: "space-y-2", children: [d.jsx("li", { children: d.jsx("button", { onClick: () => e("home"), className: "text-gray-300 hover:text-white transition-colors", children: "Home" }) }), d.jsx("li", { children: d.jsx("button", { onClick: () => e("about"), className: "text-gray-300 hover:text-white transition-colors", children: "About" }) }), d.jsx("li", { children: d.jsx("button", { onClick: () => e("services"), className: "text-gray-300 hover:text-white transition-colors", children: "Services" }) }), d.jsx("li", { children: d.jsx("button", { onClick: () => e("pricing"), className: "text-gray-300 hover:text-white transition-colors", children: "Pricing" }) }), d.jsx("li", { children: d.jsx("button", { onClick: () => e("testimonials"), className: "text-gray-300 hover:text-white transition-colors", children: "Testimonials" }) })] })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Services" }), d.jsxs("ul", { className: "space-y-2", children: [d.jsx("li", { children: d.jsx("span", { className: "text-gray-300", children: "Personal Training" }) }), d.jsx("li", { children: d.jsx("span", { className: "text-gray-300", children: "Body Transformation" }) }), d.jsx("li", { children: d.jsx("span", { className: "text-gray-300", children: "Nutrition Guidance" }) }), d.jsx("li", { children: d.jsx("span", { className: "text-gray-300", children: "Online Coaching" }) }), d.jsx("li", { children: d.jsx("span", { className: "text-gray-300", children: "Mind-Muscle Connection" }) })] })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Contact" }), d.jsxs("ul", { className: "space-y-2", children: [d.jsx("li", { className: "text-gray-300", children: "aupadhyay045@gmail.com" }), d.jsx("li", { className: "text-gray-300", children: "Mon-Sat: 6:00 AM - 10:00 PM" }), d.jsx("li", { className: "text-gray-300", children: "WhatsApp: +91 8795705808" })] })] })] }), d.jsx("div", { className: "border-t border-gray-600 mt-8 pt-8 text-center", children: d.jsx("p", { className: "text-gray-300", children: " 2024 Ashwani Upadhyay. All rights reserved. | Professional Fitness Training Services" }) })] }) }) } function sP() { return d.jsx("a", { href: "https://wa.me/918400408888", target: "_blank", rel: "noopener noreferrer", className: "fixed bottom-6 right-6 bg-green-500 text-white p-4 rounded-full shadow-lg hover:bg-green-600 transition-all duration-300 hover:scale-110 z-50 whatsapp-float", title: "Chat on WhatsApp", children: d.jsx("i", { className: "fab fa-whatsapp text-2xl" }) }) } function oP() { return d.jsxs("div", { className: "min-h-screen", children: [d.jsx(Db, {}), d.jsx(Fb, {}), d.jsx(Vb, {}), d.jsx(zb, {}), d.jsx($b, {}), d.jsx(Ub, {}), d.jsx(Bb, {}), d.jsx(nP, {}), d.jsx(rP, {}), d.jsx(sP, {})] }) } const U0 = v.forwardRef(({ className: e, ...t }, n) => d.jsx("div", { ref: n, className: Se("rounded-lg border bg-card text-card-foreground shadow-sm", e), ...t })); U0.displayName = "Card"; const iP = v.forwardRef(({ className: e, ...t }, n) => d.jsx("div", { ref: n, className: Se("flex flex-col space-y-1.5 p-6", e), ...t })); iP.displayName = "CardHeader"; const aP = v.forwardRef(({ className: e, ...t }, n) => d.jsx("div", { ref: n, className: Se("text-2xl font-semibold leading-none tracking-tight", e), ...t })); aP.displayName = "CardTitle"; const lP = v.forwardRef(({ className: e, ...t }, n) => d.jsx("div", { ref: n, className: Se("text-sm text-muted-foreground", e), ...t })); lP.displayName = "CardDescription"; const B0 = v.forwardRef(({ className: e, ...t }, n) => d.jsx("div", { ref: n, className: Se("p-6 pt-0", e), ...t })); B0.displayName = "CardContent"; const uP = v.forwardRef(({ className: e, ...t }, n) => d.jsx("div", { ref: n, className: Se("flex items-center p-6 pt-0", e), ...t })); uP.displayName = "CardFooter"; function cP() { return d.jsx("div", { className: "min-h-screen w-full flex items-center justify-center bg-gray-50", children: d.jsx(U0, { className: "w-full max-w-md mx-4", children: d.jsxs(B0, { className: "pt-6", children: [d.jsxs("div", { className: "flex mb-4 gap-2", children: [d.jsx(CC, { className: "h-8 w-8 text-red-500" }), d.jsx("h1", { className: "text-2xl font-bold text-gray-900", children: "404 Page Not Found" })] }), d.jsx("p", { className: "mt-4 text-sm text-gray-600", children: "Did you forget to add the page to the router?" })] }) }) }) } function dP() { return d.jsxs(GS, { children: [d.jsx(oh, { path: "/", component: oP }), d.jsx(oh, { component: cP })] }) } function fP() { return d.jsx(w_, { client: E_, children: d.jsxs(Mb, { children: [d.jsx(ak, {}), d.jsx(dP, {})] }) }) } Eg(document.getElementById("root")).render(d.jsx(fP, {}));
